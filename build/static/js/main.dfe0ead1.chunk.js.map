{"version":3,"sources":["../../slate/packages/slate/lib/slate.es.js","../../slate/packages/slate-prop-types/lib/slate-prop-types.es.js","../../slate/packages/slate-dev-environment/lib/slate-dev-environment.es.js","../../slate/packages/slate-base64-serializer/lib/slate-base64-serializer.es.js","../../slate/packages/slate-plain-serializer/lib/slate-plain-serializer.es.js","../../slate/packages/slate-hotkeys/lib/slate-hotkeys.es.js","../../slate/packages/slate-react-placeholder/lib/slate-react-placeholder.es.js","../../slate/packages/slate-react/lib/slate-react.es.js","slate/renderAnnotation.js","Client.js","index.js"],"names":["global","__webpack_require__","d","__webpack_exports__","Block","Change","Data","Document","Editor","Inline","Leaf$1","Mark","Node","PathUtils","Range","Selection","Text","Value","immutable__WEBPACK_IMPORTED_MODULE_0__","is_plain_object__WEBPACK_IMPORTED_MODULE_1__","is_plain_object__WEBPACK_IMPORTED_MODULE_1___default","n","tiny_warning__WEBPACK_IMPORTED_MODULE_2__","tiny_invariant__WEBPACK_IMPORTED_MODULE_3__","debug__WEBPACK_IMPORTED_MODULE_4__","debug__WEBPACK_IMPORTED_MODULE_4___default","esrever__WEBPACK_IMPORTED_MODULE_5__","lodash_pick__WEBPACK_IMPORTED_MODULE_6__","lodash_pick__WEBPACK_IMPORTED_MODULE_6___default","lodash_omit__WEBPACK_IMPORTED_MODULE_7__","lodash_omit__WEBPACK_IMPORTED_MODULE_7___default","direction__WEBPACK_IMPORTED_MODULE_8__","direction__WEBPACK_IMPORTED_MODULE_8___default","generate","resetGenerator","KeyUtils","create","key","Error","setGenerator","func","_typeof","Symbol","iterator","obj","constructor","prototype","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","protoProps","staticProps","value","_extends","assign","arguments","source","hasOwnProperty","call","inherits","subClass","superClass","setPrototypeOf","__proto__","objectWithoutProperties","keys","indexOf","possibleConstructorReturn","self","ReferenceError","slicedToArray","arr","Array","isArray","_arr","_n","_d","_e","undefined","_s","_i","next","done","push","err","sliceIterator","toConsumableArray","arr2","from","compare","path","m","min","pv","get","tv","size","create$1","attrs","isList","crop","a","b","slice","decrement","increment","index","newValue","set","isAbove","_crop","_crop2","p","t","isEqual","equals","isYounger","_crop9","_crop10","pl","tl","Math","getAncestors","withMutations","list","isAfter","_crop3","_crop4","isBefore","_crop5","_crop6","isOlder","_crop7","_crop8","isPath","any","every","isSibling","butLast","lift","drop","max","relate","array","av","transform","operation","type","position","pIndex","pEqual","pYounger","pAbove","np","newPath","concat","paths","DEFAULTS","offset","Point","_Record","this","getPrototypeOf","apply","point","isUnset","range","isAfterPoint","end","start","isBeforePoint","node","last","getLastText","text","first","getFirstText","object","hasNode","moveForward","setOffset","moveBackward","merge","moveTo","getNode","getPath","_text","getTextAtOffset","before","getOffset","getClosestBlock","getNextText","options","toArray","preserveKeys","isSet","isPoint","fromJSON","_object$key","_object$offset","_object$path","isMap","fromJS","DEFAULTS$1","data","toJSON","isMark","elements","map","_object$data","item","DEFAULTS$2","anchor","focus","Decoration","properties","createProperties","isDecoration","isRange","mark","JSON","stringify","DEFAULTS$3","isFocused","marks","_properties","isSelection","createSet","_object$isFocused","_object$marks","TYPES","annotation","block","change","decoration","document","editor","inline","leaf","selection","isObject","DEFAULTS$4","DEFAULTS$5","Annotation","isAnnotation","DEFAULTS$6","nodes","isDocument","_object$nodes","createList","DEFAULTS$7","isInline","DEFAULTS$8","Leaf","annotations","decorations","add","union","leaves","split","at","compile","kind","formats","values","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","format","o","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","middle","after","_split","_split2","_split3","_split4","return","string","remove","newProperties","newMark","regenerateKey","other","isText","_object$text","isNode","forEach","el","texts","isBlock","DEFAULTS$9","DEFAULTS$10","addMark","insertNode","mapRanges","updatePoints","setPath","assertNode","insertText","mapPoints","newDocument","mergeNode","resolvePath","withPath","one","two","moveAnchorTo","moveFocusTo","newIndex","moveNode","delete","removeMark","prev","getPreviousText","removeNode","_range","moveStartTo","unset","moveEndTo","removeText","setNode","setMark","resolveAnnotation","_value15","setProperties","resolveSelection","splitNode","_range2","_value17","sel","createSelection","anns","createAnnotation","filter","preserveData","preserveAnnotations","toObject","preserveSelection","getClosestInline","getDescendant","getNextBlock","getPreviousBlock","getNextInline","getPreviousInline","getMarksAtRange","getActiveMarksAtRange","getLeafBlocksAtRange","getFragmentAtRange","getLeafInlinesAtRange","getTextsAtRange","isValue","_object$annotations","_object$document","_object$selection","createMap","moveToStartOfNode","debug","applyOperation","op","Operation","addAnnotation","_op3","_op4","_path","_op5","_path2","_path3","_op7","_path4","_annotation","removeAnnotation","_op9","_path5","_mark","_path6","_op11","_path7","_offset","_op12","setAnnotation","_op13","_path8","_newProperties","_op14","_path9","_newProperties2","_newProperties3","setSelection","_newProperties4","_op17","_path10","_properties2","debug$1","invertOperation","_op2","inversePath","inverseNewPath","_inversePath","_inversePath2","replace","OPERATION_ATTRIBUTES","add_mark","add_annotation","insert_node","insert_text","merge_node","move_node","remove_annotation","remove_mark","remove_node","remove_text","set_annotation","set_mark","set_node","set_selection","set_value","split_node","DEFAULTS$11","json","ATTRIBUTES","v","toJS","_v","_v2","_v3","_v4","_v5","_v6","isOperation","DEFAULTS$12","operations","isChange","_object$operations","CommandsPlugin","commands","onCommand","command","args","fn","onConstruct","registerCommand","SURROGATE_START","SURROGATE_END","SPACE","CHAMELEON","PUNCTUATION","isSurrogate","code","isWord","_char","remaining","test","charAt","getCharLength","_char2","charCodeAt","getCharOffset","getWordOffset","started","_char4","l","TextUtils","getCharOffsetBackward","getCharOffsetForward","getWordOffsetBackward","getWordOffsetForward","deleteExpandedAtRange","isExpanded","deleteAtRange","hasDescendant","moveToStart","normalize","Commands$1","addMarkAtRange","isCollapsed","withoutNormalizing","addMarkByKey","addMarksAtRange","snapshotSelection","startKey","startOffset","endKey","endOffset","isStartVoid","hasVoidParent","isEndVoid","startBlock","endBlock","isHanging","prevText","startVoid","getClosestVoid","nextText","removeNodeByKey","endVoid","_prevText","startText","endText","startLength","endLength","ancestor","getCommonAncestor","startChild","getFurthestChild","endChild","startParent","getParent","startParentIndex","endParentIndex","child","parent","_index","reverse","startChildIndex","endChildIndex","_parent","_index2","removeTextByKey","onlyChildAncestor","ancestors","_ref","moveNodeByKey","mergeNodeByKey","deleteBackwardAtRange","voidParent","isAtStartOfNode","prevBlock","prevVoid","moveFocusBackward","traversed","deleteCharBackwardAtRange","deleteCharForwardAtRange","deleteForwardAtRange","_range3","isVoid","nextBlock","isAtEndOfNode","_nextBlock","nextVoid","moveFocusForward","_next","deleteLineBackwardAtRange","deleteLineForwardAtRange","deleteWordBackwardAtRange","deleteWordForwardAtRange","wordOffset","insertBlockAtRange","startInline","extra","insertNodeByKey","atEnd","siblingText","splitRange","moveToEndOfNode","splitDescendantsByKey","insertFragmentAtRange","fragment","mapDescendants","isAtStart","blocks","getBlocks","firstChild","lastChild","firstBlock","lastBlock","insertionNode","findInsertionNode","hasBlockChildren","lonelyChild","getFurthest","startIndex","nextChild","getNextSibling","nextNodes","skipUntil","lastIndex","findDescendant","inlineChild","inlineIndex","hasSingleNode","firstNode","fragmentInner","documentInner","documentNode","insertInlineAtRange","assertDescendant","splitNodeByPath","insertTextAtRange","insertTextByPath","removeMarkAtRange","removeMarkByKey","setBlocksAtRange","sets","setNodeByKey","setInlinesAtRange","inlines","splitBlockAtRange","height","_range8","h","isBackward","flip","moveAnchorToStartOfNode","setFocus","resolveRange","splitInlineAtRange","Infinity","toggleMarkAtRange","some","unwrapBlockAtRange","wrappers","getClosest","isSuperset","exists","toOrderedSet","toList","children","firstMatch","lastMatch","takeUntil","firstText","unwrapInlineAtRange","wrapBlockAtRange","clear","firstblock","lastblock","siblings","p1","p2","indexes","reduce","ind","wrapInlineAtRange","inlineParent","wrapInlineByKey","endInline","endIndex","splitText","startInner","startInnerIndex","endInner","startInlines","endInlines","startNode","endNode","wrapTextAtRange","prefix","suffix","startRange","endRange","moveToEnd","Commands$2","addMarkByPath","addMarksByPath","insertFragmentByPath","insertNodeByPath","isAtomic","mergeNodeByPath","original","previous","getPreviousSibling","moveNodeByPath","newParentPath","removeMarkByPath","removeMarksByPath","removeAllMarksByPath","state","_ref2","pth","removeNodeByPath","removeTextByPath","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","replaceNodeByPath","newNode","parentPath","replaceTextByPath","setMarkByPath","setNodeByPath","prevProperties","setTextByPath","_options$target","splitDescendantsByPath","textPath","textOffset","lastPath","splitNodeByKey","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","_ref3","ancestorPath","unwrapInlineByPath","moveToRangeOfNode","unwrapBlockByPath","unwrapNodeByPath","parentIndex","grandPath","isFirst","isLast","updatedPath","unwrapChildrenByPath","childIndex","childPath","wrapBlockByPath","wrapInlineByPath","wrapNodeByPath","_loop","method","_len3","_key3","assertPath","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","newKey","_len","_key","textKey","_len2","_key2","Commands$3","save","_editor$tmp","tmp","undos","lastBatch","lastOperation","batch","pop","_batch","takeLast","withoutSaving","redos","newData","setData","redo","_op","undo","invert","inverse","_inverse","withoutMerging","Commands$4","proxy","_editor$value$selecti","_len41","_key41","select","pointEdgeObject","edge","toUpperCase","Edge","pointEdgeSideObject","side","Side","getDirectionNode","pointBackward","pointForward","isInBlock","isPreviousInVoid","isNextInVoid","pointWordBackward","pointName","pointWordForward","blur","deselect","moveAnchorBackward","moveAnchorWordBackward","moveAnchorForward","moveAnchorWordForward","_len4","_key4","_len5","_key5","moveAnchorToEndOfBlock","moveAnchorToEndOfInline","moveAnchorToEndOfDocument","moveAnchorToEndOfNode","moveToAnchor","moveAnchorToEndOfNextBlock","moveAnchorToEndOfNextInline","moveAnchorToEndOfNextText","_len6","_key6","moveAnchorToEndOfPreviousBlock","moveAnchorToEndOfPreviousInline","moveAnchorToEndOfPreviousText","moveAnchorToEndOfText","moveAnchorToStartOfBlock","moveAnchorToStartOfDocument","moveAnchorToStartOfInline","moveAnchorToStartOfNextBlock","moveAnchorToStartOfNextInline","moveAnchorToStartOfNextText","_len7","_key7","moveAnchorToStartOfPreviousBlock","moveAnchorToStartOfPreviousInline","moveAnchorToStartOfPreviousText","moveAnchorToStartOfText","_editor$moveAnchorBac","_len8","_key8","moveWordBackward","_len9","_key9","moveFocusWordBackward","moveToFocus","moveEndBackward","_len10","_key10","moveEndWordBackward","_len11","_key11","moveEndForward","_len12","_key12","moveEndWordForward","_len13","_key13","_len14","_key14","moveEndToEndOfBlock","moveEndToEndOfDocument","moveEndToEndOfNode","moveEndToEndOfInline","moveEndToEndOfNextBlock","moveEndToEndOfNextInline","moveEndToEndOfNextText","_len15","_key15","moveEndToEndOfPreviousBlock","moveEndToEndOfPreviousInline","moveEndToEndOfPreviousText","moveEndToEndOfText","moveEndToStartOfBlock","moveEndToStartOfDocument","moveEndToStartOfNode","moveEndToStartOfInline","moveEndToStartOfNextBlock","moveEndToStartOfNextInline","moveEndToStartOfNextText","_len16","_key16","moveEndToStartOfPreviousBlock","moveEndToStartOfPreviousInline","moveEndToStartOfPreviousText","moveEndToStartOfText","_len17","_key17","_len18","_key18","_len19","_key19","moveFocusWordForward","_len20","_key20","_len21","_key21","moveFocusToEndOfBlock","moveFocusToEndOfDocument","moveFocusToEndOfNode","moveFocusToEndOfInline","moveFocusToEndOfNextBlock","moveFocusToEndOfNextInline","moveFocusToEndOfNextText","_len22","_key22","moveFocusToEndOfPreviousBlock","moveFocusToEndOfPreviousInline","moveFocusToEndOfPreviousText","moveFocusToEndOfText","moveFocusToStartOfBlock","moveFocusToStartOfDocument","moveFocusToStartOfNode","moveFocusToStartOfInline","moveFocusToStartOfNextBlock","moveFocusToStartOfNextInline","moveFocusToStartOfNextText","_len23","_key23","moveFocusToStartOfPreviousBlock","moveFocusToStartOfPreviousInline","moveFocusToStartOfPreviousText","moveFocusToStartOfText","_editor$moveAnchorFor","_len24","_key24","moveWordForward","_editor$moveFocusWord","_len25","_key25","moveStartBackward","_len26","_key26","moveStartWordBackward","_len27","_key27","moveStartForward","_len28","_key28","moveStartWordForward","_len29","_key29","_len30","_key30","moveStartToEndOfBlock","moveStartToEndOfDocument","moveStartToEndOfNode","moveStartToEndOfInline","moveStartToEndOfNextBlock","moveStartToEndOfNextInline","moveStartToEndOfNextText","_len31","_key31","moveStartToEndOfPreviousBlock","moveStartToEndOfPreviousInline","moveStartToEndOfPreviousText","moveStartToEndOfText","moveStartToStartOfBlock","moveStartToStartOfDocument","moveStartToStartOfNode","moveStartToStartOfInline","moveStartToStartOfNextBlock","moveStartToStartOfNextInline","moveStartToStartOfNextText","_len32","_key32","moveStartToStartOfPreviousBlock","moveStartToStartOfPreviousInline","moveStartToStartOfPreviousText","moveStartToStartOfText","_len33","_key33","moveToEndOfBlock","moveToEndOfDocument","moveToEndOfInline","moveToEndOfNextBlock","moveToEndOfNextInline","moveToEndOfNextText","_len34","_key34","moveToEndOfPreviousBlock","moveToEndOfPreviousInline","moveToEndOfPreviousText","moveToEndOfText","moveToRangeOfDocument","_len35","_key35","moveToStartOfBlock","moveToStartOfDocument","moveToStartOfInline","moveToStartOfNextBlock","moveToStartOfNextInline","moveToStartOfNextText","_len36","_key36","moveToStartOfPreviousBlock","moveToStartOfPreviousInline","moveToStartOfPreviousText","moveToStartOfText","_options$snapshot","snapshot","k","skip","setAnchor","_len37","_key37","setEnd","_len38","_key38","_len39","_key39","setStart","_len40","_key40","Commands$5","QueriesPlugin","queries","query","registerQuery","onQuery","ret","SlateError","_Error","_this","captureStackTrace","stack","SchemaPlugin","schema","rules","schemaRules","match","validateNode","matches","r","testRules","failure","validateRules","normalizeNode","error","rule","getTexts","defaultNormalize","find","_options$every","_options$match","fail","_error","validateObject","validateType","valid","validateData","getMarks","def","_ret","validateMarks","validateText","validateFirst","validateLast","defs","count","lastCount","nextDef","shift","rewind","validateParent","validatePrevious","validateNext","limit","lastMin","validateNodes","deleteExpanded","Commands$6","_marks","_sel","addMarks","deleteBackward","deleteCharBackward","deleteLineBackward","deleteWordBackward","deleteForward","deleteCharForward","deleteLineForward","deleteWordForward","insertBlock","insertFragment","_value","_value2","lastText","lastInline","isAppending","isInserting","newTexts","includes","newText","findLastIndex","remainingTextLength","acc","val","insertInline","getInsertMarksAtRange","_marks2","_sel2","replaceMark","oldMark","setBlocks","setInlines","splitBlock","depth","splitInline","toggleMark","activeMarks","has","unwrapBlock","unwrapInline","wrapBlock","wrapInline","wrapText","isForward","debug$2","_options$controller","controller","_options$construct","construct","_attrs$onChange","onChange","_attrs$plugins","plugins","_attrs$readOnly","readOnly","_attrs$value","middleware","dirty","flushing","registerPlugin","plugin","rest","commandsPlugin","queriesPlugin","schemaPlugin","_options$plugins","isEmpty","_next2","CorePlugin","run","setReadOnly","setValue","newDirtyPaths","table","getKeysToPathsTable","_ancestors","_ancestors2","nextPath","_ancestors3","previousPath","oldAncestors","newAncestors","_ancestors4","getDirtyPaths","memo","transformed","Promise","resolve","then","flush","normalizeDirtyPaths","__command","__query","_this2","_this3","fns","overrides","_options$normalize","_this4","normalizeNodeByPath","iterations","found","DEFAULTS$13","newMarks","collection","set$$1","isLeaf","invalid","result","cache","findLast","firstLeaf","unshift","left","right","of","take","mixin","Interface","Classes","Class","getOwnPropertyNames","name","desc","getOwnPropertyDescriptor","_name","entries","camel","TYPE","is$$1","ObjectInterface","bind","create$2","toLowerCase","ModelInterface","ENABLED","LEAF","STORE_KEY","UNDEFINED","NULL","UNSET","memoizeStore","WeakMap","memoize","property","noArgs","hasArgs","_memoizeStore$get","takesArguments","cachedValue","getIn","newChild","setIn","NodeInterface","descendant","nested","descendants","c","global$1","window","identity","ElementInterface","replaceNode","createIterable","direction","downward","includeTargetAncestors","includeRoot","onlyLeaves","onlyRoots","onlyTypes","_match","includeDocument","includeInlines","includeTexts","isLeafBlock","resolveDecoration","_options$direction","_options$downward","_options$upward","upward","_options$includeBlock","includeBlocks","_options$includeDocum","_options$includeInlin","_options$includeRoot","_options$includeTarge","includeTarget","_options$includeTarge2","_options$includeTexts","root","targetPath","targetRange","targetNode","NativeSet","Set","visited","startPath","endPath","includedTarget","includedStart","includingStart","nextIndex","_newPath","_newNode","resolvePoint","predicate","_ref4","_ref5","_start","getInsertMarksAtPoint","_texts","_texts2","_texts2$","_texts3","_texts4","_texts4$","startMarks","endMarks","intersect","_texts5","_texts6","_texts6$","_texts7","_texts8","_texts8$","iterable","_ref6","_ref8","_ref10","_ref12","_ref13","startAt","_ref14","targetPosition","results","_ref16","_ref17","_ref18","_ref20","_point","blockNode","blockPath","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","entry","_entry","relativePath","_blockNode$texts","_ref22","_ref24","Map","forEachDescendant","_ref26","_ref28","_ref30","_blocks","_siblings","_texts9","_blocks3","_siblings3","_texts11","_ref32","_ref34","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","_ref36","dir","_ref38","_ref40","getChild","_match2","isLeafInline","splice","toStart","toEnd","isInRange","_options$onlyTypes","_iterator$next","mergeText","deep","flatMap","x","deleteIn","_child$splitText","_child$splitText2","befores","afters","getLeafBlocksAtRangeAsArray","getLeafInlinesAtRangeAsArray","getNextTextEntry","getNextMatchingNodeAndPath","_match3","nextNode","childMatch","findFirstDescendantAndPath","_childMatch2","getNextDeepMatchingNodeAndPath","getPreviousTextEntry","pathToThisNode","findDescendantAndPath","previousNode","getPreviousMatchingNodeAndPath","_match4","findLastDescendantAndPath","_childMatch4","getPreviousDeepMatchingNodeAndPath","foundPath","forEachDescendantWithPath","isSelected","getFurthestAncestor","getTextsBetweenPathPositionsAsArray","getTextsAsArray","childStartPath","childEndPath","_range6","getLeafBlocksBetweenPathPositionsAsArray","getBlocksAsArray","_ref43","_ref45","_ref47","_ref49","getTextsAtRangeAsArray","getMarksByType","getMarksByTypeAsArray","_ref53","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_step8","_iterator8","_ref51","_this5","getFurthestInline","_ref54","_ref56","currentMarks","closestBlock","_texts13","_previous2","previousText","_ref58","getText","_loop$1","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_step9","_iterator9","RangeInterface","setPoints","_values","updater","validate","check","isRequired","propName","componentName","location","propType","slate_prop_types_es","lib_slate_es","isBlockList","isData","isInlineList","isLeafList","isMarkSet","isNodeList","ranges","isRangeList","isTextList","slate_dev_environment_es_browser","dist_module","slate_dev_environment_es_iteratorNormalCompletion","slate_dev_environment_es_didIteratorError","slate_dev_environment_es_iteratorError","slate_dev_environment_es_step","slate_dev_environment_es_iterator","slate_dev_environment_es_ref","slate_dev_environment_es_ref2","slate_dev_environment_es_name","navigator","userAgent","os","slate_dev_environment_es_iteratorNormalCompletion2","slate_dev_environment_es_didIteratorError2","slate_dev_environment_es_iteratorError2","slate_dev_environment_es_step2","slate_dev_environment_es_iterator2","slate_dev_environment_es_ref3","slate_dev_environment_es_ref4","features","slate_dev_environment_es_iteratorNormalCompletion3","slate_dev_environment_es_didIteratorError3","slate_dev_environment_es_iteratorError3","slate_dev_environment_es_step3","slate_dev_environment_es_iterator3","InputEvent","element","createElement","contentEditable","slate_dev_environment_es_ref6","_name2","ANDROID_API_VERSIONS","IS_FIREFOX","IS_SAFARI","IS_IE","IS_EDGE","IS_ANDROID","IS_IOS","IS_MAC","ANDROID_API_VERSION","matchData","versionString","_ref7","regex","version","getAndroidApiVersion","HAS_INPUT_EVENTS_LEVEL_2","encode","isomorphic_base64_browser","encodeURIComponent","decode","decoded","decodeURIComponent","parse","slate_base64_serializer_es","deserialize","raw","deserializeNode","serialize","serializeNode","slate_plain_serializer_es_serializeNode","_options$delimiter2","delimiter","join","slate_plain_serializer_es","_options$defaultBlock","defaultBlock","_options$defaultMarks","defaultMarks","_options$delimiter","_options$toJSON","immutable","line","HOTKEYS","bold","compose","extendBackward","extendForward","italic","APPLE_HOTKEYS","moveLineBackward","moveLineForward","extendLineBackward","extendLineForward","transposeCharacter","WINDOWS_HOTKEYS","Hotkeys","IS_APPLE","slate_hotkeys_es_IS_WINDOWS","generic","apple","windows","isGeneric","lib","isApple","isWindows","event","slate_hotkeys_es","slate_react_placeholder_es_index","condition","message","slate_react_placeholder_es_extends","slate_react_placeholder_es_slicedToArray","instanceCounter","slate_react_placeholder_es","instanceId","placeholder","when","_options$style","style","decorateNode","others","_node$texts","_node$texts3","_first","firstPath","_last","lastNode","renderMark","placeHolderStyle","pointerEvents","display","width","maxWidth","whiteSpace","opacity","node_modules_react_default","EVENT_HANDLERS","DATA_ATTRS","EDITOR","FRAGMENT","KEY","LENGTH","OBJECT","OFFSET_KEY","SPACER","STRING","TEXT","VOID","ZERO_WIDTH","SELECTORS","BLOCK","INLINE","ANNOTATION","slate_react_es_classCallCheck","slate_react_es_createClass","slate_react_es_extends","slate_react_es_inherits","slate_react_es_possibleConstructorReturn","slate_react_es_slicedToArray","slate_react_es_toConsumableArray","PARSER","OffsetKey","exec","_matches","parseInt","slate_react_es_TextString","_ref$text","_ref$isTrailing","isTrailing","slate_react_es_ZeroWidthString","_ref3$length","_ref3$isLineBreak","isLineBreak","slate_react_es_Leaf","_attrs","offsetKey","lastChar","isLastText","isLastLeaf","renderProps","attributes","propTypes","ImmutablePropTypes_default","prop_types_default","number","MemoizedLeaf","forwardRef","ref","getLeaves","MemoizedText","browser_default","slate_react_es_Void","_React$Component","Void","_temp","slate_react_es_initialiseProps","Tag","spacerAttrs","spacer","color","outline","renderText","content","Component","bool","id","_props","textRef","Node$1","Node$$1","_initialiseProps$1","nextProps","shouldUpdate","tiny_warning_esm","_attributes","newDecorations","getDecorations","getRelativeRange","decs","nodeRefs","getTextDirection","render","createRef","_child$texts","_child$texts3","OVERFLOWS","IS_IOS_11","scrollToSelection","anchorNode","get_window_default","scroller","parentNode","overflowY","getComputedStyle","body","findScrollContainer","isWindow","documentElement","backward","selection_is_backward_default","getRangeAt","cloneRange","collapse","cursorRect","getBoundingClientRect","collapsed","top","endContainer","startContainer","getClientRects","yOffset","xOffset","scrollerTop","scrollerLeft","scrollerBordersY","scrollerBordersX","scrollerPaddingTop","scrollerPaddingBottom","scrollerPaddingLeft","scrollerPaddingRight","innerWidth","innerHeight","pageYOffset","pageXOffset","offsetWidth","offsetHeight","scrollTop","scrollLeft","_window$getComputedSt","borderTopWidth","borderBottomWidth","borderLeftWidth","borderRightWidth","paddingTop","paddingBottom","paddingLeft","paddingRight","scrollerRect","cursorTop","cursorLeft","y","scrollTo","removeAllRanges","domSelection","createTextRange","FIREFOX_NODE_TYPE_ACCESS_ERROR","update","slate_react_es_Content","Content","isUpdatingSelection","nodeRef","handlers","handler","onEvent","updateSelection","isBackward$$1","current","_native2","getSelection","activeElement","enabled","rangeCount","updated","isBlurred","isInEditor","preventScroll","findDOMRange","setBaseAndExtent","addRange","setTimeout","native","nodeType","isContentEditable","closest","onNativeSelectionChange","throttle_default","info","setState","addEventListener","onBeforeInput","removeEventListener","findRange","toRange","_data","className","tabIndex","role","tagName","spellCheck","Container","wordWrap","WebkitUserModify","contentKey","suppressContentEditableWarning","autoCorrect","data-gramm","defaultProps","PROPS","findDOMNode","contentRef","search","findDOMPoint","querySelectorAll","childNodes","domLength","textContent","slateLength","hasAttribute","getAttribute","domAnchor","domFocus","createRange","findEventRange","nativeEvent","_event","clientX","clientY","findPath","rect","isPrevious","move","_native3","caretRangeFromPoint","caretPositionFromPoint","offsetNode","moveToPoint","findNode","findPoint","nativeNode","nativeOffset","_normalizeNodeAndOffs","getEditableChild","normalizeNodeAndOffset","nearestNode","nearestOffset","leafNode","textNode","contents","cloneContents","utilityNodes","removeChild","voidNode","querySelector","createPoint","domRange","StaticRange","anchorOffset","focusNode","focusOffset","_domRange","findSelection","anchorText","focusText","anchorInline","focusInline","focusBlock","anchorBlock","_block$texts","_block$texts3","_nextPath","setIsFocused","triedForward","triedBackward","slate_react_es_findPoint","tiny_invariant_esm","getEditableChild$1","normalizeNodeAndOffset$1","rangeNode","slate_react_es_findRange","_native4","_native","getSelectionFromDOM","setTextFromDomNode","domNode","lastLeaf","entire","isTextNode","TEXT_NODE","getSnapshot","lastElement","getElementSnapshot","childNode","parentElement","nextElementSibling","applySnapshot","applyElementSnapshot","childSnapshot","appendChild","snapLength","dataset","dups","dup","insertBefore","prevElement","slate_react_es_ElementSnapshot","ElementSnapshot","slate_react_es_closest","selector","win","DomSnapshot","_ref$before","subrootEl","previousElementSibling","noop","Executor","__call__","preventFurtherCalls","resume","ms","cancel","mode","timeoutId","callbackId","requestAnimationFrame","clearTimeout","cancelAnimationFrame","onCancel","__setTimeout__","timeout","debug$3","reconcile","NONE","COMPOSING","AndroidPlugin","status","compositionEndSnapshot","reconciler","keyDownSnapshot","deleter","preventNextBeforeInput","compositionEndAction","isNative","e","pick_default","preventDefault","inputType","chars","isInputDataLastChar","onCompositionEnd","onCompositionStart","onCompositionUpdate","onInput","_window","_anchorNode","_anchorNode2","onKeyDown","onSelect","slateZeroWidth","fixSelectionInZeroWidthBlock","TRANSFER_TYPES","HTML","NODE","RICH","slate_react_es_findDOMNode","cloneFragment","callback","_native5","encoded","attach","trim","setEndAfter","zw","isNewline","span","setAttribute","valFromSelection","plainText","div","clipboardData","innerHTML","editorEl","selectAllChildren","FRAGMENT$1","HTML$1","TEXT$1","FRAGMENT_MATCHER","getEventTransfer","transfer","dataTransfer","getType","html","rich","files","embeddedTypes","substring","getEmbeddedTypes","items","getAsFile","getTransferType","types","getData","TEXT$2","setEventTransfer","mime","debug$4","debug$5","DOMPlugin","beforePlugin","compositionCount","isComposing","isCopying","isDragging","isSynthetic","onBlur","relatedTarget","contains","onClick","onCopy","onCut","onDragEnd","onDragEnter","onDragExit","onDragLeave","onDragOver","dropEffect","onDragStart","onDrop","onFocus","isCompose","isBold","isDeleteBackward","isDeleteForward","isDeleteLineBackward","isDeleteLineForward","isDeleteWordBackward","isDeleteWordForward","isItalic","isRedo","isSplitBlock","isTransposeCharacter","isUndo","onPaste","BeforePlugin","afterPlugin","isDraggingInternally","isMouseDown","_event$getTargetRange","getTargetRanges","voidPath","selectionIncludesNode","_document$texts","nxt","_nxt","dispatchEvent","MouseEvent","view","bubbles","cancelable","isMoveLineBackward","isMoveLineForward","isExtendLineBackward","isExtendLineForward","isMoveBackward","isMoveForward","isMoveWordBackward","isMoveWordForward","isExtendBackward","_document$texts3","prevEntry","isPrevInVoid","prevPath","isExtendForward","_startText","_document$texts5","nextEntry","onMouseDown","onMouseUp","frag","AfterPlugin","beforeBeforePlugins","ReactPlugin","_options$placeholder","renderingPlugin","renderAnnotation","renderBlock","renderDecoration","renderDocument","renderEditor","renderInline","prop","EditorPropsPlugin","restoreDOM","debug$6","Editor$1","Editor$$1","defaultValue","mounted","resolves","updates","resolveController","memoize_one_esm","react","handleChange","autoFocus","_props2","valueFromProps","valueFromState","_props3","_controller","_controller2","_controller3","hasCommand","_controller4","hasQuery","_controller5","_controller6","_controller7","_controller8","_controller9","_controller10","_controller11","_controller12","_controller13","_controller14","applyOperations","_controller15","setOperationFlag","_controller16","getFlag","_controller17","unsetOperationFlag","_controller18","withoutNormalization","ANNOTATION_TYPES","cursor","_data$toJS","react_default","backgroundColor","bottom","fontSize","Client","onChangeServer","applyServerChange","_ref$operations","_ref$annotations","documentKey","syncEditor","socket","objectSpread","editorRef","syncing","emitChange","io","console","log","on","emit","React","ReactDOM","src_Client","getElementById"],"mappings":"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","file":"static/js/main.dfe0ead1.chunk.js","sourcesContent":["import { List, Record, Map, Set, is, OrderedSet } from 'immutable';\nimport isPlainObject from 'is-plain-object';\nimport warning from 'tiny-warning';\nimport invariant from 'tiny-invariant';\nimport Debug from 'debug';\nimport { reverse } from 'esrever';\nimport pick from 'lodash/pick';\nimport omit from 'lodash/omit';\nimport getDirection from 'direction';\n/**\n * An auto-incrementing index for generating keys.\n *\n * @type {Number}\n */\n\nvar n = void 0;\n/**\n * The global key generating function.\n *\n * @type {Function}\n */\n\nvar generate = void 0;\n/**\n * Create a key, using a provided key if available.\n *\n * @param {String|Void} key\n * @return {String}\n */\n\nfunction create(key) {\n  if (key == null) {\n    return generate();\n  }\n\n  if (typeof key === 'string') {\n    return key;\n  }\n\n  throw new Error('Keys must be strings, but you passed: ' + key);\n}\n/**\n * Set a different unique ID generating `function`.\n *\n * @param {Function} func\n */\n\n\nfunction setGenerator(func) {\n  generate = func;\n}\n/**\n * Reset the key generating function to its initial state.\n */\n\n\nfunction resetGenerator() {\n  n = 0;\n\n  generate = function generate() {\n    return '' + n++;\n  };\n}\n/**\n * Set the initial state.\n */\n\n\nresetGenerator();\n/**\n * Export.\n *\n * @type {Object}\n */\n\nvar KeyUtils = {\n  create: create,\n  setGenerator: setGenerator,\n  resetGenerator: resetGenerator\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar defineProperty = function defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar objectWithoutProperties = function objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar toConsumableArray = function toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n/**\n * Compare paths `path` and `target` to see which is before or after.\n *\n * @param {List} path\n * @param {List} target\n * @return {Number|Null}\n */\n\n\nfunction compare(path, target) {\n  var m = min(path, target);\n\n  for (var i = 0; i < m; i++) {\n    var pv = path.get(i);\n    var tv = target.get(i); // If the path's value is ever less than the target's, it's before.\n\n    if (pv < tv) return -1; // If the target's value is ever less than the path's, it's after.\n\n    if (pv > tv) return 1;\n  } // Paths should now be equal, otherwise something is wrong\n\n\n  return path.size === target.size ? 0 : null;\n}\n/**\n * Create a path from `attrs`.\n *\n * @param {Array|List} attrs\n * @return {List}\n */\n\n\nfunction create$1(attrs) {\n  if (attrs == null) {\n    return null;\n  }\n\n  if (List.isList(attrs)) {\n    return attrs;\n  }\n\n  if (Array.isArray(attrs)) {\n    return List(attrs);\n  }\n\n  throw new Error('Paths can only be created from arrays or lists, but you passed: ' + attrs);\n}\n/**\n * Crop paths `a` and `b` to an equal size, defaulting to the shortest.\n *\n * @param {List} a\n * @param {List} b\n */\n\n\nfunction crop(a, b) {\n  var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : min(a, b);\n  var ca = a.slice(0, size);\n  var cb = b.slice(0, size);\n  return [ca, cb];\n}\n/**\n * Decrement a `path` by `n` at `index`, defaulting to the last index.\n *\n * @param {List} path\n * @param {Number} n\n * @param {Number} index\n */\n\n\nfunction decrement(path) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path.size - 1;\n  return increment(path, 0 - n, index);\n}\n/**\n * Get all ancestor paths of th given path.\n *\n * @param {List} path\n * @returns {List}\n */\n\n\nfunction getAncestors(path) {\n  var ancestors = List().withMutations(function (list) {\n    for (var i = 0; i < path.size; i++) {\n      list.push(path.slice(0, i));\n    }\n  });\n  return ancestors;\n}\n/**\n * Increment a `path` by `n` at `index`, defaulting to the last index.\n *\n * @param {List} path\n * @param {Number} n\n * @param {Number} index\n */\n\n\nfunction increment(path) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path.size - 1;\n  var value = path.get(index);\n  var newValue = value + n;\n  var newPath = path.set(index, newValue);\n  return newPath;\n}\n/**\n * Is a `path` above another `target` path?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\n\nfunction isAbove(path, target) {\n  var _crop = crop(path, target),\n      _crop2 = slicedToArray(_crop, 2),\n      p = _crop2[0],\n      t = _crop2[1];\n\n  return path.size < target.size && compare(p, t) === 0;\n}\n/**\n * Is a `path` after another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\n\nfunction isAfter(path, target) {\n  var _crop3 = crop(path, target),\n      _crop4 = slicedToArray(_crop3, 2),\n      p = _crop4[0],\n      t = _crop4[1];\n\n  return compare(p, t) === 1;\n}\n/**\n * Is a `path` before another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\n\nfunction isBefore(path, target) {\n  var _crop5 = crop(path, target),\n      _crop6 = slicedToArray(_crop5, 2),\n      p = _crop6[0],\n      t = _crop6[1];\n\n  return compare(p, t) === -1;\n}\n/**\n * Is a `path` equal to another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\n\nfunction isEqual(path, target) {\n  return path.equals(target);\n}\n/**\n * Is a `path` older than a `target` path? Meaning that it ends as an older\n * sibling of one of the indexes in the target.\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\n\nfunction isOlder(path, target) {\n  var index = path.size - 1;\n\n  var _crop7 = crop(path, target, index),\n      _crop8 = slicedToArray(_crop7, 2),\n      p = _crop8[0],\n      t = _crop8[1];\n\n  var pl = path.get(index);\n  var tl = target.get(index);\n  return isEqual(p, t) && pl > tl;\n}\n/**\n * Is an `any` object a path?\n *\n * @param {Mixed} any\n * @return {Boolean}\n */\n\n\nfunction isPath(any) {\n  return (List.isList(any) || Array.isArray(any)) && any.every(function (n) {\n    return typeof n === 'number';\n  });\n}\n/**\n * Is a `path` a sibling of a `target` path?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\n\nfunction isSibling(path, target) {\n  if (path.size !== target.size) return false;\n  var p = path.butLast();\n  var t = target.butLast();\n  return p.equals(t);\n}\n/**\n * Is a `path` younger than a `target` path? Meaning that it ends as a younger\n * sibling of one of the indexes in the target.\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\n\nfunction isYounger(path, target) {\n  var index = path.size - 1;\n\n  var _crop9 = crop(path, target, index),\n      _crop10 = slicedToArray(_crop9, 2),\n      p = _crop10[0],\n      t = _crop10[1];\n\n  var pl = path.get(index);\n  var tl = target.get(index);\n  return isEqual(p, t) && pl < tl;\n}\n/**\n * Lift a `path` to refer to its `n`th ancestor.\n *\n * @param {List} path\n * @return {List}\n */\n\n\nfunction lift(path) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var ancestor = path.slice(0, -1 * n);\n  return ancestor;\n}\n/**\n * Drop a `path`, returning a relative path from a depth of `n`.\n *\n * @param {List} path\n * @param {Number} n\n * @return {List}\n */\n\n\nfunction drop(path) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var relative = path.slice(n);\n  return relative;\n}\n/**\n * Get the maximum length of paths `a` and `b`.\n *\n * @param {List} path\n * @param {List} path\n * @return {Number}\n */\n\n\nfunction max(a, b) {\n  var n = Math.max(a.size, b.size);\n  return n;\n}\n/**\n * Get the minimum length of paths `a` and `b`.\n *\n * @param {List} path\n * @param {List} path\n * @return {Number}\n */\n\n\nfunction min(a, b) {\n  var n = Math.min(a.size, b.size);\n  return n;\n}\n/**\n * Get the common ancestor path of path `a` and path `b`.\n *\n * @param {List} a\n * @param {List} b\n * @return {List}\n */\n\n\nfunction relate(a, b) {\n  var array = [];\n\n  for (var i = 0; i < a.size && i < b.size; i++) {\n    var av = a.get(i);\n    var bv = b.get(i); // If the values aren't equal, they've diverged and don't share an ancestor.\n\n    if (av !== bv) break; // Otherwise, the current value is still a common ancestor.\n\n    array.push(av);\n  }\n\n  var path = create$1(array);\n  return path;\n}\n/**\n * Transform a `path` by an `operation`, adjusting it to stay current.\n *\n * @param {List} path\n * @param {Operation} operation\n * @return {List<List>}\n */\n\n\nfunction transform(path, operation) {\n  var type = operation.type,\n      position = operation.position,\n      p = operation.path;\n\n  if (type === 'add_mark' || type === 'insert_text' || type === 'remove_mark' || type === 'remove_text' || type === 'set_mark' || type === 'set_node' || type === 'set_selection' || type === 'set_value' || path.size === 0) {\n    return List([path]);\n  }\n\n  var pIndex = p.size - 1;\n  var pEqual = isEqual(p, path);\n  var pYounger = isYounger(p, path);\n  var pAbove = isAbove(p, path);\n\n  if (type === 'insert_node') {\n    if (pEqual || pYounger || pAbove) {\n      path = increment(path, 1, pIndex);\n    }\n  }\n\n  if (type === 'remove_node') {\n    if (pYounger) {\n      path = decrement(path, 1, pIndex);\n    } else if (pEqual || pAbove) {\n      path = [];\n    }\n  }\n\n  if (type === 'merge_node') {\n    if (pEqual || pYounger) {\n      path = decrement(path, 1, pIndex);\n    } else if (pAbove) {\n      path = decrement(path, 1, pIndex);\n      path = increment(path, position, pIndex + 1);\n    }\n  }\n\n  if (type === 'split_node') {\n    if (pEqual) {\n      path = [path, increment(path)];\n    } else if (pYounger) {\n      path = increment(path, 1, pIndex);\n    } else if (pAbove) {\n      if (path.get(pIndex + 1) >= position) {\n        path = increment(path, 1, pIndex);\n        path = decrement(path, position, pIndex + 1);\n      }\n    }\n  }\n\n  if (type === 'move_node') {\n    var np = operation.newPath;\n\n    if (isEqual(p, np)) {\n      return List([path]);\n    }\n\n    if (pAbove || pEqual) {\n      // We are comparing something that was moved\n      // The new path is unaffected unless the old path was the left-sibling of an ancestor\n      if (isYounger(p, np) && p.size < np.size) {\n        path = decrement(np, 1, min(np, p) - 1).concat(path.slice(p.size));\n      } else {\n        path = np.concat(path.slice(p.size));\n      }\n    } else {\n      // This is equivalent logic to remove_node for path\n      if (pYounger) {\n        path = decrement(path, 1, pIndex);\n      } // This is the equivalent logic to insert_node for newPath\n\n\n      if (isYounger(np, path) || isEqual(np, path) || isAbove(np, path)) {\n        path = increment(path, 1, np.size - 1);\n      }\n    }\n  }\n\n  var paths = Array.isArray(path) ? path : [path];\n  return List(paths);\n}\n/**\n * Export.\n *\n * @type {Object}\n */\n\n\nvar PathUtils = {\n  compare: compare,\n  create: create$1,\n  crop: crop,\n  decrement: decrement,\n  getAncestors: getAncestors,\n  increment: increment,\n  isAbove: isAbove,\n  isAfter: isAfter,\n  isBefore: isBefore,\n  isEqual: isEqual,\n  isOlder: isOlder,\n  isPath: isPath,\n  isSibling: isSibling,\n  isYounger: isYounger,\n  lift: lift,\n  drop: drop,\n  max: max,\n  min: min,\n  relate: relate,\n  transform: transform\n};\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  key: undefined,\n  offset: undefined,\n  path: undefined\n  /**\n   * Point.\n   *\n   * @type {Point}\n   */\n\n};\n\nvar Point = function (_Record) {\n  inherits(Point, _Record);\n\n  function Point() {\n    classCallCheck(this, Point);\n    return possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).apply(this, arguments));\n  }\n\n  createClass(Point, [{\n    key: 'isAfterPoint',\n\n    /**\n     * Check whether the point is after another `point`.\n     *\n     * @return {Boolean}\n     */\n    value: function isAfterPoint(point) {\n      if (this.isUnset) return false;\n      var is$$1 = this.key === point.key && this.offset > point.offset || PathUtils.compare(this.path, point.path) === 1;\n      return is$$1;\n    }\n    /**\n     * Check whether the point is after a `range`.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAfterRange',\n    value: function isAfterRange(range) {\n      if (this.isUnset) return false;\n      var is$$1 = this.isAfterPoint(range.end);\n      return is$$1;\n    }\n    /**\n     * Check whether the point is at the end of a `range`.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAtEndOfRange',\n    value: function isAtEndOfRange(range) {\n      if (this.isUnset) return false;\n      var is$$1 = this.equals(range.end);\n      return is$$1;\n    }\n    /**\n     * Check whether the point is at the start of a `range`.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAtStartOfRange',\n    value: function isAtStartOfRange(range) {\n      if (this.isUnset) return false;\n      var is$$1 = this.equals(range.start);\n      return is$$1;\n    }\n    /**\n     * Check whether the point is before another `point`.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBeforePoint',\n    value: function isBeforePoint(point) {\n      if (this.isUnset) return false;\n      var is$$1 = this.key === point.key && this.offset < point.offset || PathUtils.compare(this.path, point.path) === -1;\n      return is$$1;\n    }\n    /**\n     * Check whether the point is before a `range`.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBeforeRange',\n    value: function isBeforeRange(range) {\n      if (this.isUnset) return false;\n      var is$$1 = this.isBeforePoint(range.start);\n      return is$$1;\n    }\n    /**\n     * Check whether the point is inside a `range`.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isInRange',\n    value: function isInRange(range) {\n      if (this.isUnset) return false;\n      var is$$1 = this.equals(range.start) || this.equals(range.end) || this.isAfterPoint(range.start) && this.isBeforePoint(range.end);\n      return is$$1;\n    }\n    /**\n     * Check whether the point is at the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAtEndOfNode',\n    value: function isAtEndOfNode(node) {\n      if (this.isUnset) return false;\n      var last = node.getLastText();\n      var is$$1 = this.key === last.key && this.offset === last.text.length;\n      return is$$1;\n    }\n    /**\n     * Check whether the point is at the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAtStartOfNode',\n    value: function isAtStartOfNode(node) {\n      if (this.isUnset) return false; // PERF: Do a check for a `0` offset first since it's quickest.\n\n      if (this.offset !== 0) return false;\n      var first = node.getFirstText();\n      var is$$1 = this.key === first.key;\n      return is$$1;\n    }\n    /**\n     * Check whether the point is in a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isInNode',\n    value: function isInNode(node) {\n      if (this.isUnset) return false;\n      if (node.object === 'text' && node.key === this.key) return true;\n      if (node.hasNode(this.key)) return true;\n      return false;\n    }\n    /**\n     * Move the point's offset backward `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Point}\n     */\n\n  }, {\n    key: 'moveBackward',\n    value: function moveBackward() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      if (n === 0) return this;\n      if (n < 0) return this.moveForward(-n);\n      var point = this.setOffset(this.offset - n);\n      return point;\n    }\n    /**\n     * Move the point's offset forward `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Point}\n     */\n\n  }, {\n    key: 'moveForward',\n    value: function moveForward() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      if (n === 0) return this;\n      if (n < 0) return this.moveBackward(-n);\n      var point = this.setOffset(this.offset + n);\n      return point;\n    }\n    /**\n     * Move the point's anchor point to a new `path` and `offset`.\n     *\n     * Optionally, the `path` can be a key string, or omitted entirely in which\n     * case it would be the offset number.\n     *\n     * @param {List|String|Number} path\n     * @param {Number} offset\n     * @return {Point}\n     */\n\n  }, {\n    key: 'moveTo',\n    value: function moveTo(path) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var key = this.key;\n\n      if (typeof path === 'number') {\n        offset = path;\n        path = this.path;\n      } else if (typeof path === 'string') {\n        key = path;\n        path = key === this.key ? this.path : null;\n      } else {\n        key = path.equals(this.path) ? this.key : null;\n      }\n\n      var point = this.merge({\n        key: key,\n        path: path,\n        offset: offset\n      });\n      return point;\n    }\n    /**\n     * Move the point's anchor point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Point}\n     */\n\n  }, {\n    key: 'moveToStartOfNode',\n    value: function moveToStartOfNode(node) {\n      var first = node.getFirstText();\n      var point = this.moveTo(first.key, 0);\n      return point;\n    }\n    /**\n     * Move the point's anchor point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Point}\n     */\n\n  }, {\n    key: 'moveToEndOfNode',\n    value: function moveToEndOfNode(node) {\n      var last = node.getLastText();\n      var point = this.moveTo(last.key, last.text.length);\n      return point;\n    }\n    /**\n     * Normalize the point relative to a `node`, ensuring that its key and path\n     * reference a text node, or that it gets unset.\n     *\n     * @param {Node} node\n     * @return {Point}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(node) {\n      // If both the key and path are null, there's no reference to a node, so\n      // make sure it is entirely unset.\n      if (this.key == null && this.path == null) {\n        return this.setOffset(null);\n      }\n\n      var key = this.key,\n          offset = this.offset,\n          path = this.path; // PERF: this function gets called a lot.\n      // to avoid creating the key -> path lookup table, we attempt to look up by path first.\n\n      var target = path && node.getNode(path);\n\n      if (!target) {\n        target = node.getNode(key);\n\n        if (target) {\n          // There is a misalignment of path and key\n          var _point = this.merge({\n            path: node.getPath(key)\n          });\n\n          return _point;\n        }\n      }\n\n      if (!target) {\n        warning(false, \"A point's `path` or `key` invalid and was reset!\");\n        var text = node.getFirstText();\n        if (!text) return Point.create();\n\n        var _point2 = this.merge({\n          key: text.key,\n          offset: 0,\n          path: node.getPath(text.key)\n        });\n\n        return _point2;\n      }\n\n      if (target.object !== 'text') {\n        warning(false, 'A point should not reference a non-text node!');\n\n        var _text = target.getTextAtOffset(offset);\n\n        var before = target.getOffset(_text.key);\n\n        var _point3 = this.merge({\n          offset: offset - before,\n          key: _text.key,\n          path: node.getPath(_text.key)\n        });\n\n        return _point3;\n      }\n\n      if (target && path && key && key !== target.key) {\n        warning(false, \"A point's `key` did not match its `path`!\"); // TODO: if we look up by path above and it differs by key, do we want to reset it to looking up by key?\n      }\n\n      var point = this.merge({\n        key: target.key,\n        path: path == null ? node.getPath(target.key) : path,\n        offset: offset == null ? 0 : Math.min(offset, target.text.length)\n      }); // COMPAT: There is an ambiguity, since a point can exist at the end of a\n      // text node, or at the start of the following one. To eliminate it we\n      // enforce that if there is a following text node, we always move it there.\n\n      if (point.offset === target.text.length) {\n        var block = node.getClosestBlock(point.path); // TODO: this next line is broken because `getNextText` takes a path\n\n        var next = block.getNextText();\n\n        if (next) {\n          point = point.merge({\n            key: next.key,\n            path: node.getPath(next.key),\n            offset: 0\n          });\n        }\n      }\n\n      return point;\n    }\n    /**\n     * Set the point's key to a new `key`.\n     *\n     * @param {String} key\n     * @return {Point}\n     */\n\n  }, {\n    key: 'setKey',\n    value: function setKey(key) {\n      if (key != null) {\n        key = KeyUtils.create(key);\n      }\n\n      var point = this.set('key', key);\n      return point;\n    }\n    /**\n     * Set the point's offset to a new `offset`.\n     *\n     * @param {Number} offset\n     * @return {Point}\n     */\n\n  }, {\n    key: 'setOffset',\n    value: function setOffset(offset) {\n      var point = this.set('offset', offset);\n      return point;\n    }\n    /**\n     * Set the point's path to a new `path`.\n     *\n     * @param {List|Array} path\n     * @return {Point}\n     */\n\n  }, {\n    key: 'setPath',\n    value: function setPath(path) {\n      if (path != null) {\n        path = PathUtils.create(path);\n      }\n\n      var point = this.set('path', path);\n      return point;\n    }\n    /**\n     * Return a JSON representation of the point.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        key: this.key,\n        offset: this.offset,\n        path: this.path && this.path.toArray()\n      };\n\n      if (!options.preserveKeys) {\n        delete object.key;\n      }\n\n      return object;\n    }\n    /**\n     * Unset the point.\n     *\n     * @return {Point}\n     */\n\n  }, {\n    key: 'unset',\n    value: function unset() {\n      return this.merge({\n        key: null,\n        offset: null,\n        path: null\n      });\n    }\n  }, {\n    key: 'isSet',\n\n    /**\n     * Check whether all properties of the point are set.\n     *\n     * @return {Boolean}\n     */\n    get: function get$$1() {\n      return this.key != null && this.offset != null && this.path != null;\n    }\n    /**\n     * Check whether any property of the point is not set.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isUnset',\n    get: function get$$1() {\n      return !this.isSet;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Point` with `attrs`.\n     *\n     * @param {Object|Point} attrs\n     * @return {Point}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Point.isPoint(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Point.fromJSON(attrs);\n      }\n\n      throw new Error('`Point.create` only accepts objects or points, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a dictionary of settable point properties from `attrs`.\n     *\n     * @param {Object|Point} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Point.isPoint(a)) {\n        return {\n          key: a.key,\n          offset: a.offset,\n          path: a.path\n        };\n      }\n\n      if (isPlainObject(a)) {\n        var p = {};\n        if ('key' in a) p.key = a.key;\n        if ('offset' in a) p.offset = a.offset;\n        if ('path' in a) p.path = PathUtils.create(a.path); // If only a path is set, or only a key is set, ensure that the other is\n        // set to null so that it can be normalized back to the right value.\n        // Otherwise we won't realize that the path and key don't match anymore.\n\n        if ('path' in a && !('key' in a)) p.key = null;\n        if ('key' in a && !('path' in a)) p.path = null;\n        return p;\n      }\n\n      throw new Error('`Point.createProperties` only accepts objects or points, but you passed it: ' + a);\n    }\n    /**\n     * Create a `Point` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Point}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var _object$key = object.key,\n          key = _object$key === undefined ? null : _object$key,\n          _object$offset = object.offset,\n          offset = _object$offset === undefined ? null : _object$offset,\n          _object$path = object.path,\n          path = _object$path === undefined ? null : _object$path;\n      var point = new Point({\n        key: key,\n        offset: offset,\n        path: PathUtils.create(path)\n      });\n      return point;\n    }\n  }]);\n  return Point;\n}(Record(DEFAULTS));\n/**\n * Data.\n *\n * This isn't an immutable record, it's just a thin wrapper around `Map` so that\n * we can allow for more convenient creation.\n *\n * @type {Object}\n */\n\n\nvar Data = function () {\n  function Data() {\n    classCallCheck(this, Data);\n  }\n\n  createClass(Data, null, [{\n    key: 'create',\n\n    /**\n     * Create a new `Data` with `attrs`.\n     *\n     * @param {Object|Data|Map} attrs\n     * @return {Data} data\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Map.isMap(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Data.fromJSON(attrs);\n      }\n\n      throw new Error('`Data.create` only accepts objects or maps, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a `Data` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Data}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      return new Map(object);\n    }\n    /**\n     * Alias `fromJS`.\n     */\n\n  }]);\n  return Data;\n}();\n/**\n * Export.\n *\n * @type {Object}\n */\n\n\nData.fromJS = Data.fromJSON;\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$1 = {\n  data: undefined,\n  type: undefined\n  /**\n   * Mark.\n   *\n   * @type {Mark}\n   */\n\n};\n\nvar Mark = function (_Record) {\n  inherits(Mark, _Record);\n\n  function Mark() {\n    classCallCheck(this, Mark);\n    return possibleConstructorReturn(this, (Mark.__proto__ || Object.getPrototypeOf(Mark)).apply(this, arguments));\n  }\n\n  createClass(Mark, [{\n    key: 'toJSON',\n\n    /**\n     * Return a JSON representation of the mark.\n     *\n     * @return {Object}\n     */\n    value: function toJSON() {\n      var object = {\n        object: this.object,\n        type: this.type,\n        data: this.data.toJSON()\n      };\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Mark` with `attrs`.\n     *\n     * @param {Object|Mark} attrs\n     * @return {Mark}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Mark.isMark(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs === 'string') {\n        attrs = {\n          type: attrs\n        };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Mark.fromJSON(attrs);\n      }\n\n      throw new Error('`Mark.create` only accepts objects, strings or marks, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a set of marks.\n     *\n     * @param {Array<Object|Mark>} elements\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'createSet',\n    value: function createSet(elements) {\n      if (Set.isSet(elements) || Array.isArray(elements)) {\n        var marks = new Set(elements.map(Mark.create));\n        return marks;\n      }\n\n      if (elements == null) {\n        return Set();\n      }\n\n      throw new Error('`Mark.createSet` only accepts sets, arrays or null, but you passed it: ' + elements);\n    }\n    /**\n     * Create a dictionary of settable mark properties from `attrs`.\n     *\n     * @param {Object|String|Mark} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Mark.isMark(attrs)) {\n        return {\n          data: attrs.data,\n          type: attrs.type\n        };\n      }\n\n      if (typeof attrs === 'string') {\n        return {\n          type: attrs\n        };\n      }\n\n      if (isPlainObject(attrs)) {\n        var props = {};\n        if ('type' in attrs) props.type = attrs.type;\n        if ('data' in attrs) props.data = Data.create(attrs.data);\n        return props;\n      }\n\n      throw new Error('`Mark.createProperties` only accepts objects, strings or marks, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a `Mark` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Mark}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          type = object.type;\n\n      if (typeof type !== 'string') {\n        throw new Error('`Mark.fromJS` requires a `type` string.');\n      }\n\n      var mark = new Mark({\n        type: type,\n        data: new Map(data)\n      });\n      return mark;\n    }\n    /**\n     * Check if `any` is a set of marks.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isMarkSet',\n    value: function isMarkSet(any) {\n      return Set.isSet(any) && any.every(function (item) {\n        return Mark.isMark(item);\n      });\n    }\n  }]);\n  return Mark;\n}(Record(DEFAULTS$1));\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$2 = {\n  type: undefined,\n  data: undefined,\n  anchor: undefined,\n  focus: undefined\n  /**\n   * Decoration.\n   *\n   * @type {Decoration}\n   */\n\n};\n\nvar Decoration = function (_Record) {\n  inherits(Decoration, _Record);\n\n  function Decoration() {\n    classCallCheck(this, Decoration);\n    return possibleConstructorReturn(this, (Decoration.__proto__ || Object.getPrototypeOf(Decoration)).apply(this, arguments));\n  }\n\n  createClass(Decoration, [{\n    key: 'setProperties',\n\n    /**\n     * Set new `properties` on the decoration.\n     *\n     * @param {Object|Range|Selection} properties\n     * @return {Range}\n     */\n    value: function setProperties(properties) {\n      properties = Decoration.createProperties(properties);\n      var decoration = this.merge(properties);\n      return decoration;\n    }\n    /**\n     * Return a JSON representation of the decoration.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        type: this.type,\n        data: this.data.toJSON(),\n        anchor: this.anchor.toJSON(options),\n        focus: this.focus.toJSON(options)\n      };\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Decoration` with `attrs`.\n     *\n     * @param {Object|Decoration} attrs\n     * @return {Decoration}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Decoration.isDecoration(attrs)) {\n        return attrs;\n      }\n\n      if (Range.isRange(attrs)) {\n        return Decoration.fromJSON(Range.createProperties(attrs));\n      }\n\n      if (isPlainObject(attrs)) {\n        return Decoration.fromJSON(attrs);\n      }\n\n      throw new Error('`Decoration.create` only accepts objects or decorations, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a list of `Ranges` from `elements`.\n     *\n     * @param {Array<Decoration|Object>|List<Decoration|Object>} elements\n     * @return {List<Decoration>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (List.isList(elements) || Array.isArray(elements)) {\n        var list = new List(elements.map(Decoration.create));\n        return list;\n      }\n\n      throw new Error('`Decoration.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n    /**\n     * Create a dictionary of settable decoration properties from `attrs`.\n     *\n     * @param {Object|String|Decoration} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Decoration.isDecoration(a)) {\n        return {\n          type: a.type,\n          data: a.data,\n          anchor: Point.createProperties(a.anchor),\n          focus: Point.createProperties(a.focus),\n          mark: Mark.create(a.mark)\n        };\n      }\n\n      if (isPlainObject(a)) {\n        var p = {};\n        if ('type' in a) p.type = a.type;\n        if ('data' in a) p.data = Data.create(a.data);\n        if ('anchor' in a) p.anchor = Point.create(a.anchor);\n        if ('focus' in a) p.focus = Point.create(a.focus);\n        return p;\n      }\n\n      throw new Error('`Decoration.createProperties` only accepts objects or decorations, but you passed it: ' + a);\n    }\n    /**\n     * Create a `Decoration` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Decoration}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var anchor = object.anchor,\n          focus = object.focus;\n      var type = object.type,\n          data = object.data;\n\n      if (object.mark && !type) {\n        warning(false, 'As of slate@0.47 the `decoration.mark` property has been changed to `decoration.type` and `decoration.data` directly.');\n        type = object.mark.type;\n        data = object.mark.data;\n      }\n\n      if (!type) {\n        throw new Error('Decorations must be created with a `type`, but you passed: ' + JSON.stringify(object));\n      }\n\n      var decoration = new Decoration({\n        type: type,\n        data: Data.create(data || {}),\n        anchor: Point.fromJSON(anchor || {}),\n        focus: Point.fromJSON(focus || {})\n      });\n      return decoration;\n    }\n  }]);\n  return Decoration;\n}(Record(DEFAULTS$2));\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$3 = {\n  anchor: undefined,\n  focus: undefined,\n  isFocused: undefined,\n  marks: undefined\n  /**\n   * Selection.\n   *\n   * @type {Selection}\n   */\n\n};\n\nvar Selection = function (_Record) {\n  inherits(Selection, _Record);\n\n  function Selection() {\n    classCallCheck(this, Selection);\n    return possibleConstructorReturn(this, (Selection.__proto__ || Object.getPrototypeOf(Selection)).apply(this, arguments));\n  }\n\n  createClass(Selection, [{\n    key: 'setIsFocused',\n\n    /**\n     * Set the `isFocused` property to a new `value`.\n     *\n     * @param {Boolean} value\n     * @return {Selection}\n     */\n    value: function setIsFocused(value) {\n      var selection = this.set('isFocused', value);\n      return selection;\n    }\n    /**\n     * Set the `marks` property to a new set of `marks`.\n     *\n     * @param {Set} marks\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'setMarks',\n    value: function setMarks(marks) {\n      var selection = this.set('marks', marks);\n      return selection;\n    }\n    /**\n     * Set new `properties` on the selection.\n     *\n     * @param {Object|Range|Selection} properties\n     * @return {Range}\n     */\n\n  }, {\n    key: 'setProperties',\n    value: function setProperties(properties) {\n      properties = Selection.createProperties(properties);\n      var _properties = properties,\n          anchor = _properties.anchor,\n          focus = _properties.focus,\n          props = objectWithoutProperties(_properties, ['anchor', 'focus']);\n\n      if (anchor) {\n        props.anchor = Point.create(anchor);\n      }\n\n      if (focus) {\n        props.focus = Point.create(focus);\n      }\n\n      var selection = this.merge(props);\n      return selection;\n    }\n    /**\n     * Return a JSON representation of the selection.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        anchor: this.anchor.toJSON(options),\n        focus: this.focus.toJSON(options),\n        isFocused: this.isFocused,\n        marks: this.marks == null ? null : this.marks.toArray().map(function (m) {\n          return m.toJSON();\n        })\n      };\n      return object;\n    }\n  }, {\n    key: 'isBlurred',\n\n    /**\n     * Check whether the selection is blurred.\n     *\n     * @return {Boolean}\n     */\n    get: function get$$1() {\n      return !this.isFocused;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Selection` with `attrs`.\n     *\n     * @param {Object|Selection} attrs\n     * @return {Selection}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Selection.isSelection(attrs)) {\n        return attrs;\n      }\n\n      if (Range.isRange(attrs)) {\n        return Selection.fromJSON(Range.createProperties(attrs));\n      }\n\n      if (isPlainObject(attrs)) {\n        return Selection.fromJSON(attrs);\n      }\n\n      throw new Error('`Selection.create` only accepts objects, ranges or selections, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a dictionary of settable selection properties from `attrs`.\n     *\n     * @param {Object|String|Selection} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Selection.isSelection(a)) {\n        return {\n          anchor: Point.createProperties(a.anchor),\n          focus: Point.createProperties(a.focus),\n          isFocused: a.isFocused,\n          marks: a.marks\n        };\n      }\n\n      if (Range.isRange(a)) {\n        return {\n          anchor: Point.createProperties(a.anchor),\n          focus: Point.createProperties(a.focus)\n        };\n      }\n\n      if (isPlainObject(a)) {\n        var p = {};\n        if ('anchor' in a) p.anchor = Point.create(a.anchor);\n        if ('focus' in a) p.focus = Point.create(a.focus);\n        if ('isFocused' in a) p.isFocused = a.isFocused;\n        if ('marks' in a) p.marks = a.marks == null ? null : Mark.createSet(a.marks);\n        return p;\n      }\n\n      throw new Error('`Selection.createProperties` only accepts objects, ranges or selections, but you passed it: ' + a);\n    }\n    /**\n     * Create a `Selection` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var anchor = object.anchor,\n          focus = object.focus,\n          _object$isFocused = object.isFocused,\n          isFocused = _object$isFocused === undefined ? false : _object$isFocused,\n          _object$marks = object.marks,\n          marks = _object$marks === undefined ? null : _object$marks;\n      var selection = new Selection({\n        anchor: Point.fromJSON(anchor || {}),\n        focus: Point.fromJSON(focus || {}),\n        isFocused: isFocused,\n        marks: marks == null ? null : new Set(marks.map(Mark.fromJSON))\n      });\n      return selection;\n    }\n  }]);\n  return Selection;\n}(Record(DEFAULTS$3));\n/**\n * Slate-specific object types.\n *\n * @type {Object}\n */\n\n\nvar TYPES = {\n  annotation: '@@__SLATE_ANNOTATION__@@',\n  block: '@@__SLATE_BLOCK__@@',\n  change: '@@__SLATE_CHANGE__@@',\n  decoration: '@@__SLATE_DECORATION__@@',\n  document: '@@__SLATE_DOCUMENT__@@',\n  editor: '@@__SLATE_EDITOR__@@',\n  inline: '@@__SLATE_INLINE__@@',\n  leaf: '@@__SLATE_LEAF__@@',\n  mark: '@@__SLATE_MARK__@@',\n  operation: '@@__SLATE_OPERATION__@@',\n  point: '@@__SLATE_POINT__@@',\n  range: '@@__SLATE_RANGE__@@',\n  selection: '@@__SLATE_SELECTION__@@',\n  text: '@@__SLATE_TEXT__@@',\n  value: '@@__SLATE_VALUE__@@'\n  /**\n   * Determine whether a `value` is of `type`.\n   *\n   * @param {string} type\n   * @param {any} value\n   * @return {boolean}\n   */\n\n};\n\nfunction isObject(type, value) {\n  return !!(value && value[TYPES[type]]);\n}\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$4 = {\n  anchor: undefined,\n  focus: undefined\n  /**\n   * Range.\n   *\n   * @type {Range}\n   */\n\n};\n\nvar Range = function (_Record) {\n  inherits(Range, _Record);\n\n  function Range() {\n    classCallCheck(this, Range);\n    return possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).apply(this, arguments));\n  }\n\n  createClass(Range, [{\n    key: 'toJSON',\n\n    /**\n     * Return a JSON representation of the range.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        anchor: this.anchor.toJSON(options),\n        focus: this.focus.toJSON(options)\n      };\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Range` with `attrs`.\n     *\n     * @param {Object|Range} attrs\n     * @return {Range}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Range.isRange(attrs)) {\n        if (attrs.object === 'range') {\n          return attrs;\n        } else {\n          return Range.fromJSON(Range.createProperties(attrs));\n        }\n      }\n\n      if (isPlainObject(attrs)) {\n        return Range.fromJSON(attrs);\n      }\n\n      throw new Error('`Range.create` only accepts objects or ranges, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a list of `Ranges` from `elements`.\n     *\n     * @param {Array<Range|Object>|List<Range|Object>} elements\n     * @return {List<Range>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (List.isList(elements) || Array.isArray(elements)) {\n        var list = new List(elements.map(Range.create));\n        return list;\n      }\n\n      throw new Error('`Range.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n    /**\n     * Create a dictionary of settable range properties from `attrs`.\n     *\n     * @param {Object|String|Range} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Range.isRange(a)) {\n        return {\n          anchor: Point.createProperties(a.anchor),\n          focus: Point.createProperties(a.focus)\n        };\n      }\n\n      if (isPlainObject(a)) {\n        var p = {};\n        if ('anchor' in a) p.anchor = Point.create(a.anchor);\n        if ('focus' in a) p.focus = Point.create(a.focus);\n        return p;\n      }\n\n      throw new Error('`Range.createProperties` only accepts objects, annotations, decorations, ranges or selections, but you passed it: ' + a);\n    }\n    /**\n     * Create a `Range` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Range}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var anchor = object.anchor,\n          focus = object.focus;\n      var range = new Range({\n        anchor: Point.fromJSON(anchor || {}),\n        focus: Point.fromJSON(focus || {})\n      });\n      return range;\n    }\n    /**\n     * Check if a `value` is a `Range`, or is range-like.\n     *\n     * @param {Any} value\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isRange',\n    value: function isRange(value) {\n      return isObject('range', value) || Decoration.isDecoration(value) || Selection.isSelection(value);\n    }\n  }]);\n  return Range;\n}(Record(DEFAULTS$4));\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$5 = {\n  key: undefined,\n  type: undefined,\n  data: undefined,\n  anchor: undefined,\n  focus: undefined\n  /**\n   * Annotation.\n   *\n   * @type {Annotation}\n   */\n\n};\n\nvar Annotation = function (_Record) {\n  inherits(Annotation, _Record);\n\n  function Annotation() {\n    classCallCheck(this, Annotation);\n    return possibleConstructorReturn(this, (Annotation.__proto__ || Object.getPrototypeOf(Annotation)).apply(this, arguments));\n  }\n\n  createClass(Annotation, [{\n    key: 'setProperties',\n\n    /**\n     * Set new `properties` on the annotation.\n     *\n     * @param {Object|Range|Selection} properties\n     * @return {Range}\n     */\n    value: function setProperties(properties) {\n      properties = Annotation.createProperties(properties);\n      var annotation = this.merge(properties);\n      return annotation;\n    }\n    /**\n     * Return a JSON representation of the annotation.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        key: this.key,\n        type: this.type,\n        data: this.data.toJSON(),\n        anchor: this.anchor.toJSON(options),\n        focus: this.focus.toJSON(options)\n      };\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Annotation` with `attrs`.\n     *\n     * @param {Object|Annotation} attrs\n     * @return {Annotation}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Annotation.isAnnotation(attrs)) {\n        return attrs;\n      }\n\n      if (Range.isRange(attrs)) {\n        return Annotation.fromJSON(Range.createProperties(attrs));\n      }\n\n      if (isPlainObject(attrs)) {\n        return Annotation.fromJSON(attrs);\n      }\n\n      throw new Error('`Annotation.create` only accepts objects or annotations, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a map of annotations from `elements`.\n     *\n     * @param {Object<String,Annotation>|Map<String,Annotation>} elements\n     * @return {Map<String,Annotation>}\n     */\n\n  }, {\n    key: 'createMap',\n    value: function createMap() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (Map.isMap(elements)) {\n        return elements;\n      }\n\n      if (isPlainObject(elements)) {\n        var obj = {};\n\n        for (var key in elements) {\n          var value = elements[key];\n          var annotation = Annotation.create(value);\n          obj[key] = annotation;\n        }\n\n        return Map(obj);\n      }\n\n      throw new Error('`Annotation.createMap` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n    /**\n     * Create a dictionary of settable annotation properties from `attrs`.\n     *\n     * @param {Object|String|Annotation} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Annotation.isAnnotation(a)) {\n        return {\n          key: a.key,\n          type: a.type,\n          data: a.data,\n          anchor: Point.createProperties(a.anchor),\n          focus: Point.createProperties(a.focus)\n        };\n      }\n\n      if (isPlainObject(a)) {\n        var p = {};\n        if ('key' in a) p.key = a.key;\n        if ('type' in a) p.type = a.type;\n        if ('data' in a) p.data = Data.create(a.data);\n        if ('anchor' in a) p.anchor = Point.create(a.anchor);\n        if ('focus' in a) p.focus = Point.create(a.focus);\n        return p;\n      }\n\n      throw new Error('`Annotation.createProperties` only accepts objects or annotations, but you passed it: ' + a);\n    }\n    /**\n     * Create a `Annotation` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Annotation}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var key = object.key,\n          type = object.type,\n          data = object.data,\n          anchor = object.anchor,\n          focus = object.focus;\n\n      if (!key) {\n        throw new Error('Annotations must be created with a `key`, but you passed: ' + JSON.stringify(object));\n      }\n\n      if (!type) {\n        throw new Error('Annotations must be created with a `type`, but you passed: ' + JSON.stringify(object));\n      }\n\n      var annotation = new Annotation({\n        key: key,\n        type: type,\n        data: Data.create(data || {}),\n        anchor: Point.fromJSON(anchor || {}),\n        focus: Point.fromJSON(focus || {})\n      });\n      return annotation;\n    }\n  }]);\n  return Annotation;\n}(Record(DEFAULTS$5));\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$6 = {\n  data: undefined,\n  key: undefined,\n  nodes: undefined\n  /**\n   * Document.\n   *\n   * @type {Document}\n   */\n\n};\n\nvar Document = function (_Record) {\n  inherits(Document, _Record);\n\n  function Document() {\n    classCallCheck(this, Document);\n    return possibleConstructorReturn(this, (Document.__proto__ || Object.getPrototypeOf(Document)).apply(this, arguments));\n  }\n\n  createClass(Document, [{\n    key: 'toJSON',\n\n    /**\n     * Return a JSON representation of the document.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        data: this.data.toJSON(),\n        nodes: this.nodes.toArray().map(function (n) {\n          return n.toJSON(options);\n        })\n      };\n\n      if (options.preserveKeys) {\n        object.key = this.key;\n      }\n\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Document` with `attrs`.\n     *\n     * @param {Object|Array|List|Text} attrs\n     * @return {Document}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Document.isDocument(attrs)) {\n        return attrs;\n      }\n\n      if (List.isList(attrs) || Array.isArray(attrs)) {\n        attrs = {\n          nodes: attrs\n        };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Document.fromJSON(attrs);\n      }\n\n      throw new Error('`Document.create` only accepts objects, arrays, lists or documents, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a `Document` from a JSON `object`.\n     *\n     * @param {Object|Document} object\n     * @return {Document}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Document.isDocument(object)) {\n        return object;\n      }\n\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          _object$key = object.key,\n          key = _object$key === undefined ? KeyUtils.create() : _object$key,\n          _object$nodes = object.nodes,\n          nodes = _object$nodes === undefined ? [] : _object$nodes;\n      var document = new Document({\n        key: key,\n        data: new Map(data),\n        nodes: Node.createList(nodes)\n      });\n      return document;\n    }\n  }]);\n  return Document;\n}(Record(DEFAULTS$6));\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$7 = {\n  data: undefined,\n  key: undefined,\n  nodes: undefined,\n  type: undefined\n  /**\n   * Inline.\n   *\n   * @type {Inline}\n   */\n\n};\n\nvar Inline = function (_Record) {\n  inherits(Inline, _Record);\n\n  function Inline() {\n    classCallCheck(this, Inline);\n    return possibleConstructorReturn(this, (Inline.__proto__ || Object.getPrototypeOf(Inline)).apply(this, arguments));\n  }\n\n  createClass(Inline, [{\n    key: 'toJSON',\n\n    /**\n     * Return a JSON representation of the inline.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        type: this.type,\n        data: this.data.toJSON(),\n        nodes: this.nodes.toArray().map(function (n) {\n          return n.toJSON(options);\n        })\n      };\n\n      if (options.preserveKeys) {\n        object.key = this.key;\n      }\n\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Inline` with `attrs`.\n     *\n     * @param {Object|String|Inline} attrs\n     * @return {Inline}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Inline.isInline(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs === 'string') {\n        attrs = {\n          type: attrs\n        };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Inline.fromJSON(attrs);\n      }\n\n      throw new Error('`Inline.create` only accepts objects, strings or inlines, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a list of `Inlines` from an array.\n     *\n     * @param {Array<Inline|Object>|List<Inline|Object>} elements\n     * @return {List<Inline>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (List.isList(elements) || Array.isArray(elements)) {\n        var list = new List(elements.map(Inline.create));\n        return list;\n      }\n\n      throw new Error('`Inline.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n    /**\n     * Create a `Inline` from a JSON `object`.\n     *\n     * @param {Object|Inline} object\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Inline.isInline(object)) {\n        return object;\n      }\n\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          _object$key = object.key,\n          key = _object$key === undefined ? KeyUtils.create() : _object$key,\n          _object$nodes = object.nodes,\n          nodes = _object$nodes === undefined ? [] : _object$nodes,\n          type = object.type;\n\n      if (typeof type !== 'string') {\n        throw new Error('`Inline.fromJS` requires a `type` string.');\n      }\n\n      var inline = new Inline({\n        key: key,\n        type: type,\n        data: new Map(data),\n        nodes: Node.createList(nodes)\n      });\n      return inline;\n    }\n    /**\n     * Check if `any` is a list of inlines.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isInlineList',\n    value: function isInlineList(any) {\n      return List.isList(any) && any.every(function (item) {\n        return Inline.isInline(item);\n      });\n    }\n  }]);\n  return Inline;\n}(Record(DEFAULTS$7));\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$8 = {\n  key: undefined,\n  marks: undefined,\n  text: undefined\n};\nvar Leaf = Record({\n  text: undefined,\n  marks: undefined,\n  annotations: undefined,\n  decorations: undefined\n});\n/**\n * Text.\n *\n * @type {Text}\n */\n\nvar Text = function (_Record) {\n  inherits(Text, _Record);\n\n  function Text() {\n    classCallCheck(this, Text);\n    return possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).apply(this, arguments));\n  }\n\n  createClass(Text, [{\n    key: 'addMark',\n\n    /**\n     * Add a `mark`.\n     *\n     * @param {Mark} mark\n     * @return {Text}\n     */\n    value: function addMark(mark) {\n      mark = Mark.create(mark);\n      var marks = this.marks;\n      var next = marks.add(mark);\n      var node = this.set('marks', next);\n      return node;\n    }\n    /**\n     * Add a set of `marks`.\n     *\n     * @param {Set<Mark>} marks\n     * @return {Text}\n     */\n\n  }, {\n    key: 'addMarks',\n    value: function addMarks(marks) {\n      marks = Mark.createSet(marks);\n      var node = this.set('marks', this.marks.union(marks));\n      return node;\n    }\n    /**\n     * Get a list of uniquely-formatted leaves for the text node, given its\n     * existing marks, and its current `annotations` and `decorations`.\n     *\n     * @param {Map<String,Annotation>} annotations\n     * @param {List<Decoration>} decorations\n     * @return {List<Leaf>}\n     */\n\n  }, {\n    key: 'getLeaves',\n    value: function getLeaves(annotations, decorations) {\n      var text = this.text,\n          marks = this.marks;\n      var leaves = [{\n        text: text,\n        marks: marks,\n        annotations: [],\n        decorations: []\n      }]; // Helper to split a leaf into two `at` an offset.\n\n      var split = function split(leaf, at) {\n        return [{\n          text: leaf.text.slice(0, at),\n          marks: leaf.marks,\n          annotations: [].concat(toConsumableArray(leaf.annotations)),\n          decorations: [].concat(toConsumableArray(leaf.decorations))\n        }, {\n          text: leaf.text.slice(at),\n          marks: leaf.marks,\n          annotations: [].concat(toConsumableArray(leaf.annotations)),\n          decorations: [].concat(toConsumableArray(leaf.decorations))\n        }];\n      }; // Helper to compile the leaves for a `kind` of format.\n\n\n      var compile = function compile(kind) {\n        var formats = kind === 'annotations' ? annotations.values() : decorations;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = formats[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var format = _step.value;\n            var start = format.start,\n                end = format.end;\n            var next = [];\n            var o = 0;\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = leaves[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var leaf = _step2.value;\n                var length = leaf.text.length;\n                var offset = o;\n                o += length; // If the range starts after the leaf, or ends before it, continue.\n\n                if (start.offset > offset + length || end.offset <= offset) {\n                  next.push(leaf);\n                  continue;\n                } // If the range encompases the entire leaf, add the format.\n\n\n                if (start.offset <= offset && end.offset >= offset + length) {\n                  leaf[kind].push(format);\n                  next.push(leaf);\n                  continue;\n                } // Otherwise we need to split the leaf, at the start, end, or both,\n                // and add the format to the middle intersecting section. Do the end\n                // split first since we don't need to update the offset that way.\n\n\n                var middle = leaf;\n                var before = void 0;\n                var after = void 0;\n\n                if (end.offset < offset + length) {\n                  var _split = split(middle, end.offset - offset);\n\n                  var _split2 = slicedToArray(_split, 2);\n\n                  middle = _split2[0];\n                  after = _split2[1];\n                }\n\n                if (start.offset > offset) {\n                  var _split3 = split(middle, start.offset - offset);\n\n                  var _split4 = slicedToArray(_split3, 2);\n\n                  before = _split4[0];\n                  middle = _split4[1];\n                }\n\n                middle[kind].push(format);\n\n                if (before) {\n                  next.push(before);\n                }\n\n                next.push(middle);\n\n                if (after) {\n                  next.push(after);\n                }\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n\n            leaves = next;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      };\n\n      compile('annotations');\n      compile('decorations');\n      leaves = leaves.map(function (leaf) {\n        return new Leaf(_extends({}, leaf, {\n          annotations: List(leaf.annotations),\n          decorations: List(leaf.decorations)\n        }));\n      });\n      var list = List(leaves);\n      return list;\n    }\n    /**\n     * Insert `text` at `index`.\n     *\n     * @param {Number} index\n     * @param {String} string\n     * @return {Text}\n     */\n\n  }, {\n    key: 'insertText',\n    value: function insertText(index, string) {\n      var text = this.text;\n      var next = text.slice(0, index) + string + text.slice(index);\n      var node = this.set('text', next);\n      return node;\n    }\n    /**\n     * Remove a `mark`.\n     *\n     * @param {Mark} mark\n     * @return {Text}\n     */\n\n  }, {\n    key: 'removeMark',\n    value: function removeMark(mark) {\n      mark = Mark.create(mark);\n      var marks = this.marks;\n      var next = marks.remove(mark);\n      var node = this.set('marks', next);\n      return node;\n    }\n    /**\n     * Remove text from the text node at `index` for `length`.\n     *\n     * @param {Number} index\n     * @param {Number} length\n     * @return {Text}\n     */\n\n  }, {\n    key: 'removeText',\n    value: function removeText(index, length) {\n      var text = this.text;\n      var next = text.slice(0, index) + text.slice(index + length);\n      var node = this.set('text', next);\n      return node;\n    }\n    /**\n     * Return a JSON representation of the text.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        text: this.text,\n        marks: this.marks.toArray().map(function (m) {\n          return m.toJSON();\n        })\n      };\n\n      if (options.preserveKeys) {\n        object.key = this.key;\n      }\n\n      return object;\n    }\n    /**\n     * Set a `newProperties` on an existing `mark`.\n     *\n     * @param {Object} mark\n     * @param {Object} newProperties\n     * @return {Text}\n     */\n\n  }, {\n    key: 'setMark',\n    value: function setMark(properties, newProperties) {\n      var marks = this.marks;\n      var mark = Mark.create(properties);\n      var newMark = mark.merge(newProperties);\n      var next = marks.remove(mark).add(newMark);\n      var node = this.set('marks', next);\n      return node;\n    }\n    /**\n     * Split the node into two at `index`.\n     *\n     * @param {Number} index\n     * @returns {Array<Text>}\n     */\n\n  }, {\n    key: 'splitText',\n    value: function splitText(index) {\n      var text = this.text;\n      var one = this.set('text', text.slice(0, index));\n      var two = this.set('text', text.slice(index)).regenerateKey();\n      return [one, two];\n    }\n    /**\n     * Merge the node with an `other` text node.\n     *\n     * @param {Text} other\n     * @returns {Text}\n     */\n\n  }, {\n    key: 'mergeText',\n    value: function mergeText(other) {\n      var next = this.text + other.text;\n      var node = this.set('text', next);\n      return node;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Text` with `attrs`.\n     *\n     * @param {Object|Array|List|String|Text} attrs\n     * @return {Text}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n      if (Text.isText(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs === 'string') {\n        attrs = {\n          text: attrs\n        };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Text.fromJSON(attrs);\n      }\n\n      throw new Error('`Text.create` only accepts objects, arrays, strings or texts, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a list of `Texts` from `elements`.\n     *\n     * @param {Array<Text|Object>|List<Text|Object>} elements\n     * @return {List<Text>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (List.isList(elements) || Array.isArray(elements)) {\n        var list = new List(elements.map(Text.create));\n        return list;\n      }\n\n      throw new Error('`Text.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n    /**\n     * Create a `Text` from a JSON `object`.\n     *\n     * @param {Object|Text} object\n     * @return {Text}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Text.isText(object)) {\n        return object;\n      }\n\n      invariant(object.leaves == null, 'As of slate@0.46, the `leaves` property of text nodes has been removed! Each individual leaf should be created as a text node instead.');\n      var _object$text = object.text,\n          text = _object$text === undefined ? '' : _object$text,\n          _object$marks = object.marks,\n          marks = _object$marks === undefined ? [] : _object$marks,\n          _object$key = object.key,\n          key = _object$key === undefined ? KeyUtils.create() : _object$key;\n      var node = new Text({\n        key: key,\n        text: text,\n        marks: Mark.createSet(marks)\n      });\n      return node;\n    }\n    /**\n     * Check if `any` is a listof texts.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isTextList',\n    value: function isTextList(any) {\n      return List.isList(any) && any.every(function (item) {\n        return Text.isText(item);\n      });\n    }\n  }]);\n  return Text;\n}(Record(DEFAULTS$8));\n/**\n * A pseudo-model that is used for its static methods only.\n *\n * @type {Node}\n */\n\n\nvar Node = function () {\n  function Node() {\n    classCallCheck(this, Node);\n  }\n\n  createClass(Node, null, [{\n    key: 'create',\n\n    /**\n     * Create a new `Node` with `attrs`.\n     *\n     * @param {Object|Node} attrs\n     * @return {Node}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Node.isNode(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        var object = attrs.object;\n\n        if (!object && attrs.kind) {\n          warning(false, 'As of slate@0.32.0, the `kind` property of Slate objects has been renamed to `object`.');\n          object = attrs.kind;\n        }\n\n        switch (object) {\n          case 'block':\n            return Block.create(attrs);\n\n          case 'document':\n            return Document.create(attrs);\n\n          case 'inline':\n            return Inline.create(attrs);\n\n          case 'text':\n            return Text.create(attrs);\n\n          default:\n            {\n              throw new Error('`Node.create` requires a `object` string.');\n            }\n        }\n      }\n\n      throw new Error('`Node.create` only accepts objects or nodes but you passed it: ' + attrs);\n    }\n    /**\n     * Create a list of `Nodes` from an array.\n     *\n     * @param {Array<Object|Node>} elements\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (List.isList(elements) || Array.isArray(elements)) {\n        var array = [];\n        elements.forEach(function (el) {\n          if (el && el.object === 'text' && el.leaves && Array.isArray(el.leaves)) {\n            warning(false, 'As of slate@0.46, the `leaves` property of Text nodes has been removed. Instead, each text node contains a string of text and a unique set of marks and leaves are unnecessary.');\n            var texts = Text.createList(el.leaves).toArray();\n            array = array.concat(texts);\n            return;\n          }\n\n          var node = Node.create(el);\n          array.push(node);\n        });\n        var list = List(array);\n        return list;\n      }\n\n      throw new Error('`Node.createList` only accepts lists or arrays, but you passed it: ' + elements);\n    }\n    /**\n     * Create a dictionary of settable node properties from `attrs`.\n     *\n     * @param {Object|String|Node} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Block.isBlock(attrs) || Inline.isInline(attrs)) {\n        return {\n          data: attrs.data,\n          type: attrs.type\n        };\n      }\n\n      if (typeof attrs === 'string') {\n        return {\n          type: attrs\n        };\n      }\n\n      if (isPlainObject(attrs)) {\n        var props = {};\n        if ('type' in attrs) props.type = attrs.type;\n        if ('data' in attrs) props.data = Data.create(attrs.data);\n        return props;\n      }\n\n      throw new Error('`Node.createProperties` only accepts objects, strings, blocks or inlines, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a `Node` from a JSON `value`.\n     *\n     * @param {Object} value\n     * @return {Node}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(value) {\n      var object = value.object;\n\n      if (!object && value.kind) {\n        warning(false, 'As of slate@0.32.0, the `kind` property of Slate objects has been renamed to `object`.');\n        object = value.kind;\n      }\n\n      switch (object) {\n        case 'block':\n          return Block.fromJSON(value);\n\n        case 'document':\n          return Document.fromJSON(value);\n\n        case 'inline':\n          return Inline.fromJSON(value);\n\n        case 'text':\n          return Text.fromJSON(value);\n\n        default:\n          {\n            throw new Error('`Node.fromJSON` requires an `object` of either \\'block\\', \\'document\\', \\'inline\\' or \\'text\\', but you passed: ' + value);\n          }\n      }\n    }\n    /**\n     * Check if `any` is a `Node`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isNode',\n    value: function isNode(any) {\n      return Block.isBlock(any) || Document.isDocument(any) || Inline.isInline(any) || Text.isText(any);\n    }\n    /**\n     * Check if `any` is a list of nodes.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isNodeList',\n    value: function isNodeList(any) {\n      return List.isList(any) && any.every(function (item) {\n        return Node.isNode(item);\n      });\n    }\n  }]);\n  return Node;\n}();\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$9 = {\n  data: undefined,\n  key: undefined,\n  nodes: undefined,\n  type: undefined\n  /**\n   * Block.\n   *\n   * @type {Block}\n   */\n\n};\n\nvar Block = function (_Record) {\n  inherits(Block, _Record);\n\n  function Block() {\n    classCallCheck(this, Block);\n    return possibleConstructorReturn(this, (Block.__proto__ || Object.getPrototypeOf(Block)).apply(this, arguments));\n  }\n\n  createClass(Block, [{\n    key: 'toJSON',\n\n    /**\n     * Return a JSON representation of the block.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        type: this.type,\n        data: this.data.toJSON(),\n        nodes: this.nodes.toArray().map(function (n) {\n          return n.toJSON(options);\n        })\n      };\n\n      if (options.preserveKeys) {\n        object.key = this.key;\n      }\n\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Block` from `attrs`.\n     *\n     * @param {Object|String|Block} attrs\n     * @return {Block}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Block.isBlock(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs === 'string') {\n        attrs = {\n          type: attrs\n        };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Block.fromJSON(attrs);\n      }\n\n      throw new Error('`Block.create` only accepts objects, strings or blocks, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a list of `Blocks` from `attrs`.\n     *\n     * @param {Array<Block|Object>|List<Block|Object>} attrs\n     * @return {List<Block>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (List.isList(attrs) || Array.isArray(attrs)) {\n        var list = new List(attrs.map(Block.create));\n        return list;\n      }\n\n      throw new Error('`Block.createList` only accepts arrays or lists, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a `Block` from a JSON `object`.\n     *\n     * @param {Object|Block} object\n     * @return {Block}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Block.isBlock(object)) {\n        return object;\n      }\n\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          _object$key = object.key,\n          key = _object$key === undefined ? KeyUtils.create() : _object$key,\n          _object$nodes = object.nodes,\n          nodes = _object$nodes === undefined ? [] : _object$nodes,\n          type = object.type;\n\n      if (typeof type !== 'string') {\n        throw new Error('`Block.fromJSON` requires a `type` string.');\n      }\n\n      var block = new Block({\n        key: key,\n        type: type,\n        data: Map(data),\n        nodes: Node.createList(nodes)\n      });\n      return block;\n    }\n    /**\n     * Check if `any` is a block list.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBlockList',\n    value: function isBlockList(any) {\n      return List.isList(any) && any.every(function (item) {\n        return Block.isBlock(item);\n      });\n    }\n  }]);\n  return Block;\n}(Record(DEFAULTS$9));\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$10 = {\n  annotations: undefined,\n  data: undefined,\n  document: undefined,\n  selection: undefined\n  /**\n   * Value.\n   *\n   * @type {Value}\n   */\n\n};\n\nvar Value = function (_Record) {\n  inherits(Value, _Record);\n\n  function Value() {\n    classCallCheck(this, Value);\n    return possibleConstructorReturn(this, (Value.__proto__ || Object.getPrototypeOf(Value)).apply(this, arguments));\n  }\n\n  createClass(Value, [{\n    key: 'addAnnotation',\n\n    /**\n     * Add an `annotation` to the value.\n     *\n     * @param {Annotation} annotation\n     * @param {Mark} mark\n     * @return {Value}\n     */\n    value: function addAnnotation(annotation) {\n      annotation = Annotation.create(annotation);\n      var value = this;\n      var _value = value,\n          annotations = _value.annotations;\n      var _annotation = annotation,\n          key = _annotation.key;\n      annotations = annotations.set(key, annotation);\n      value = value.set('annotations', annotations);\n      return value;\n    }\n    /**\n     * Add `mark` to text at `path`.\n     *\n     * @param {List|String} path\n     * @param {Mark} mark\n     * @return {Value}\n     */\n\n  }, {\n    key: 'addMark',\n    value: function addMark(path, mark) {\n      mark = Mark.create(mark);\n      var value = this;\n      var _value2 = value,\n          document = _value2.document;\n      document = document.addMark(path, mark);\n      value = value.set('document', document);\n      return value;\n    }\n    /**\n     * Insert a `node`.\n     *\n     * @param {List|String} path\n     * @param {Node} node\n     * @return {Value}\n     */\n\n  }, {\n    key: 'insertNode',\n    value: function insertNode(path, node) {\n      var value = this;\n      var _value3 = value,\n          document = _value3.document;\n      document = document.insertNode(path, node);\n      value = value.set('document', document);\n      value = value.mapRanges(function (range) {\n        return range.updatePoints(function (point) {\n          return point.setPath(null);\n        });\n      });\n      return value;\n    }\n    /**\n     * Insert `text` at `offset` in node by `path`.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @param {String} text\n     * @return {Value}\n     */\n\n  }, {\n    key: 'insertText',\n    value: function insertText(path, offset, text) {\n      var value = this;\n      var _value4 = value,\n          document = _value4.document;\n      var node = document.assertNode(path);\n      document = document.insertText(path, offset, text);\n      node = document.assertNode(path);\n      value = value.set('document', document);\n      value = value.mapPoints(function (point) {\n        if (point.key === node.key && point.offset >= offset) {\n          return point.setOffset(point.offset + text.length);\n        } else {\n          return point;\n        }\n      });\n      return value;\n    }\n    /**\n     * Merge a node backwards its previous sibling.\n     *\n     * @param {List|Key} path\n     * @return {Value}\n     */\n\n  }, {\n    key: 'mergeNode',\n    value: function mergeNode(path) {\n      var value = this;\n      var _value5 = value,\n          document = _value5.document;\n      var newDocument = document.mergeNode(path);\n      path = document.resolvePath(path);\n      var withPath = PathUtils.decrement(path);\n      var one = document.getNode(withPath);\n      var two = document.getNode(path);\n      value = value.set('document', newDocument);\n      value = value.mapRanges(function (range) {\n        if (two.object === 'text') {\n          var max = one.text.length;\n\n          if (range.anchor.key === two.key) {\n            range = range.moveAnchorTo(one.key, max + range.anchor.offset);\n          }\n\n          if (range.focus.key === two.key) {\n            range = range.moveFocusTo(one.key, max + range.focus.offset);\n          }\n        }\n\n        range = range.updatePoints(function (point) {\n          return point.setPath(null);\n        });\n        return range;\n      });\n      return value;\n    }\n    /**\n     * Move a node by `path` to `newPath`.\n     *\n     * A `newIndex` can be provided when move nodes by `key`, to account for not\n     * being able to have a key for a location in the tree that doesn't exist yet.\n     *\n     * @param {List|Key} path\n     * @param {List|Key} newPath\n     * @param {Number} newIndex\n     * @return {Value}\n     */\n\n  }, {\n    key: 'moveNode',\n    value: function moveNode(path, newPath) {\n      var newIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var value = this;\n      var _value6 = value,\n          document = _value6.document;\n\n      if (PathUtils.isEqual(path, newPath)) {\n        return value;\n      }\n\n      document = document.moveNode(path, newPath, newIndex);\n      value = value.set('document', document);\n      value = value.mapPoints(function (point) {\n        return point.setPath(null);\n      });\n      return value;\n    }\n    /**\n     * Remove an `annotation` from the value.\n     *\n     * @param {Annotation} annotation\n     * @param {Mark} mark\n     * @return {Value}\n     */\n\n  }, {\n    key: 'removeAnnotation',\n    value: function removeAnnotation(annotation) {\n      annotation = Annotation.create(annotation);\n      var value = this;\n      var _value7 = value,\n          annotations = _value7.annotations;\n      var _annotation2 = annotation,\n          key = _annotation2.key;\n      annotations = annotations.delete(key);\n      value = value.set('annotations', annotations);\n      return value;\n    }\n    /**\n     * Remove `mark` at `path`.\n     *\n     * @param {List|String} path\n     * @param {Mark} mark\n     * @return {Value}\n     */\n\n  }, {\n    key: 'removeMark',\n    value: function removeMark(path, mark) {\n      mark = Mark.create(mark);\n      var value = this;\n      var _value8 = value,\n          document = _value8.document;\n      document = document.removeMark(path, mark);\n      value = value.set('document', document);\n      return value;\n    }\n    /**\n     * Remove a node by `path`.\n     *\n     * @param {List|String} path\n     * @return {Value}\n     */\n\n  }, {\n    key: 'removeNode',\n    value: function removeNode(path) {\n      var value = this;\n      var _value9 = value,\n          document = _value9.document;\n      var node = document.assertNode(path);\n      var first = node.object === 'text' ? node : node.getFirstText() || node;\n      var last = node.object === 'text' ? node : node.getLastText() || node;\n      var prev = document.getPreviousText(first.key);\n      var next = document.getNextText(last.key);\n      document = document.removeNode(path);\n      value = value.set('document', document);\n      value = value.mapRanges(function (range) {\n        var _range = range,\n            start = _range.start,\n            end = _range.end;\n\n        if (node.hasNode(start.key)) {\n          range = prev ? range.moveStartTo(prev.key, prev.text.length) : next ? range.moveStartTo(next.key, 0) : range.unset();\n        }\n\n        if (node.hasNode(end.key)) {\n          range = prev ? range.moveEndTo(prev.key, prev.text.length) : next ? range.moveEndTo(next.key, 0) : range.unset();\n        }\n\n        range = range.updatePoints(function (point) {\n          return point.setPath(null);\n        });\n        return range;\n      });\n      return value;\n    }\n    /**\n     * Remove `text` at `offset` in node by `path`.\n     *\n     * @param {List|Key} path\n     * @param {Number} offset\n     * @param {String} text\n     * @return {Value}\n     */\n\n  }, {\n    key: 'removeText',\n    value: function removeText(path, offset, text) {\n      var value = this;\n      var _value10 = value,\n          document = _value10.document;\n      var node = document.assertNode(path);\n      document = document.removeText(path, offset, text);\n      value = value.set('document', document);\n      var length = text.length;\n      var start = offset;\n      var end = offset + length;\n      value = value.mapPoints(function (point) {\n        if (point.key !== node.key) {\n          return point;\n        }\n\n        if (point.offset >= end) {\n          return point.setOffset(point.offset - length);\n        }\n\n        if (point.offset > start) {\n          return point.setOffset(start);\n        }\n\n        return point;\n      });\n      return value;\n    }\n    /**\n     * Add an `annotation` to the value.\n     *\n     * @param {Annotation} annotation\n     * @param {Mark} mark\n     * @return {Value}\n     */\n\n  }, {\n    key: 'setAnnotation',\n    value: function setAnnotation(properties, newProperties) {\n      newProperties = Annotation.createProperties(newProperties);\n      var annotation = Annotation.create(properties);\n      var next = annotation.merge(newProperties);\n      var value = this;\n      var _value11 = value,\n          annotations = _value11.annotations;\n      var key = annotation.key;\n      annotations = annotations.set(key, next);\n      value = value.set('annotations', annotations);\n      return value;\n    }\n    /**\n     * Set `properties` on a node.\n     *\n     * @param {List|String} path\n     * @param {Object} properties\n     * @return {Value}\n     */\n\n  }, {\n    key: 'setNode',\n    value: function setNode(path, properties) {\n      var value = this;\n      var _value12 = value,\n          document = _value12.document;\n      document = document.setNode(path, properties);\n      value = value.set('document', document);\n      return value;\n    }\n    /**\n     * Set `properties` on `mark` on text at `offset` and `length` in node.\n     *\n     * @param {List|String} path\n     * @param {Mark} mark\n     * @param {Object} properties\n     * @return {Value}\n     */\n\n  }, {\n    key: 'setMark',\n    value: function setMark(path, mark, properties) {\n      var value = this;\n      var _value13 = value,\n          document = _value13.document;\n      document = document.setMark(path, mark, properties);\n      value = value.set('document', document);\n      return value;\n    }\n    /**\n     * Set `properties` on the value.\n     *\n     * @param {Object} properties\n     * @return {Value}\n     */\n\n  }, {\n    key: 'setProperties',\n    value: function setProperties(properties) {\n      var value = this;\n      var _value14 = value,\n          document = _value14.document;\n      var data = properties.data,\n          annotations = properties.annotations;\n      var props = {};\n\n      if (data) {\n        props.data = data;\n      }\n\n      if (annotations) {\n        props.annotations = annotations.map(function (a) {\n          return a.isSet ? a : document.resolveAnnotation(a);\n        });\n      }\n\n      value = value.merge(props);\n      return value;\n    }\n    /**\n     * Set `properties` on the selection.\n     *\n     * @param {Value} value\n     * @param {Operation} operation\n     * @return {Value}\n     */\n\n  }, {\n    key: 'setSelection',\n    value: function setSelection(properties) {\n      var value = this;\n      var _value15 = value,\n          document = _value15.document,\n          selection = _value15.selection;\n      var next = selection.setProperties(properties);\n      selection = document.resolveSelection(next);\n      value = value.set('selection', selection);\n      return value;\n    }\n    /**\n     * Split a node by `path` at `position` with optional `properties` to apply\n     * to the newly split node.\n     *\n     * @param {List|String} path\n     * @param {Number} position\n     * @param {Object} properties\n     * @return {Value}\n     */\n\n  }, {\n    key: 'splitNode',\n    value: function splitNode(path, position, properties) {\n      var value = this;\n      var _value16 = value,\n          document = _value16.document;\n      var newDocument = document.splitNode(path, position, properties);\n      var node = document.assertNode(path);\n      value = value.set('document', newDocument);\n      value = value.mapRanges(function (range) {\n        var next = newDocument.getNextText(node.key);\n        var _range2 = range,\n            start = _range2.start,\n            end = _range2.end; // If the start was after the split, move it to the next node.\n\n        if (node.key === start.key && position <= start.offset) {\n          range = range.moveStartTo(next.key, start.offset - position);\n        } // If the end was after the split, move it to the next node.\n\n\n        if (node.key === end.key && position <= end.offset) {\n          range = range.moveEndTo(next.key, end.offset - position);\n        }\n\n        range = range.updatePoints(function (point) {\n          return point.setPath(null);\n        });\n        return range;\n      });\n      return value;\n    }\n    /**\n     * Map all range objects to apply adjustments with an `iterator`.\n     *\n     * @param {Function} iterator\n     * @return {Value}\n     */\n\n  }, {\n    key: 'mapRanges',\n    value: function mapRanges(iterator) {\n      var value = this;\n      var _value17 = value,\n          document = _value17.document,\n          selection = _value17.selection,\n          annotations = _value17.annotations;\n      var sel = selection.isSet ? iterator(selection) : selection;\n      if (!sel) sel = selection.unset();\n      if (sel !== selection) sel = document.createSelection(sel);\n      value = value.set('selection', sel);\n      var anns = annotations.map(function (annotation) {\n        var n = annotation.isSet ? iterator(annotation) : annotation;\n        if (n && n !== annotation) n = document.createAnnotation(n);\n        return n;\n      });\n      anns = anns.filter(function (annotation) {\n        return !!annotation;\n      });\n      value = value.set('annotations', anns);\n      return value;\n    }\n  }, {\n    key: 'mapPoints',\n    value: function mapPoints(iterator) {\n      return this.mapRanges(function (range) {\n        return range.updatePoints(iterator);\n      });\n    }\n    /**\n     * Return a JSON representation of the value.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        document: this.document.toJSON(options)\n      };\n\n      if (options.preserveData) {\n        object.data = this.data.toJSON(options);\n      }\n\n      if (options.preserveAnnotations) {\n        object.annotations = this.annotations.map(function (a) {\n          return a.toJSON(options);\n        }).toObject();\n      }\n\n      if (options.preserveSelection) {\n        object.selection = this.selection.toJSON(options);\n      }\n\n      return object;\n    }\n    /**\n     * Deprecated.\n     */\n\n  }, {\n    key: 'change',\n    value: function change() {\n      invariant(false, 'As of Slate 0.42.0, value object are no longer schema-aware, and the `value.change()` method is no longer available. Use the `editor.change()` method on the new `Editor` controller instead.');\n    }\n  }, {\n    key: 'startBlock',\n\n    /**\n     * Get the current start text node's closest block parent.\n     *\n     * @return {Block}\n     */\n    get: function get$$1() {\n      return this.selection.start.key && this.document.getClosestBlock(this.selection.start.key);\n    }\n    /**\n     * Get the current end text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'endBlock',\n    get: function get$$1() {\n      return this.selection.end.key && this.document.getClosestBlock(this.selection.end.key);\n    }\n    /**\n     * Get the current anchor text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'anchorBlock',\n    get: function get$$1() {\n      return this.selection.anchor.key && this.document.getClosestBlock(this.selection.anchor.key);\n    }\n    /**\n     * Get the current focus text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'focusBlock',\n    get: function get$$1() {\n      return this.selection.focus.key && this.document.getClosestBlock(this.selection.focus.key);\n    }\n    /**\n     * Get the current start text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'startInline',\n    get: function get$$1() {\n      return this.selection.start.key && this.document.getClosestInline(this.selection.start.key);\n    }\n    /**\n     * Get the current end text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'endInline',\n    get: function get$$1() {\n      return this.selection.end.key && this.document.getClosestInline(this.selection.end.key);\n    }\n    /**\n     * Get the current anchor text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'anchorInline',\n    get: function get$$1() {\n      return this.selection.anchor.key && this.document.getClosestInline(this.selection.anchor.key);\n    }\n    /**\n     * Get the current focus text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'focusInline',\n    get: function get$$1() {\n      return this.selection.focus.key && this.document.getClosestInline(this.selection.focus.key);\n    }\n    /**\n     * Get the current start text node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'startText',\n    get: function get$$1() {\n      return this.selection.start.key && this.document.getDescendant(this.selection.start.key);\n    }\n    /**\n     * Get the current end node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'endText',\n    get: function get$$1() {\n      return this.selection.end.key && this.document.getDescendant(this.selection.end.key);\n    }\n    /**\n     * Get the current anchor node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'anchorText',\n    get: function get$$1() {\n      return this.selection.anchor.key && this.document.getDescendant(this.selection.anchor.key);\n    }\n    /**\n     * Get the current focus node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'focusText',\n    get: function get$$1() {\n      return this.selection.focus.key && this.document.getDescendant(this.selection.focus.key);\n    }\n    /**\n     * Get the next block node.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'nextBlock',\n    get: function get$$1() {\n      return this.selection.end.key && this.document.getNextBlock(this.selection.end.key);\n    }\n    /**\n     * Get the previous block node.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'previousBlock',\n    get: function get$$1() {\n      return this.selection.start.key && this.document.getPreviousBlock(this.selection.start.key);\n    }\n    /**\n     * Get the next inline node.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'nextInline',\n    get: function get$$1() {\n      return this.selection.end.key && this.document.getNextInline(this.selection.end.key);\n    }\n    /**\n     * Get the previous inline node.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'previousInline',\n    get: function get$$1() {\n      return this.selection.start.key && this.document.getPreviousInline(this.selection.start.key);\n    }\n    /**\n     * Get the next text node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'nextText',\n    get: function get$$1() {\n      return this.selection.end.key && this.document.getNextText(this.selection.end.key);\n    }\n    /**\n     * Get the previous text node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'previousText',\n    get: function get$$1() {\n      return this.selection.start.key && this.document.getPreviousText(this.selection.start.key);\n    }\n    /**\n     * Get the marks of the current selection.\n     *\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'marks',\n    get: function get$$1() {\n      return this.selection.isUnset ? new Set() : this.selection.marks || this.document.getMarksAtRange(this.selection);\n    }\n    /**\n     * Get the active marks of the current selection.\n     *\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'activeMarks',\n    get: function get$$1() {\n      return this.selection.isUnset ? new Set() : this.selection.marks || this.document.getActiveMarksAtRange(this.selection);\n    }\n    /**\n     * Get the block nodes in the current selection.\n     *\n     * @return {List<Block>}\n     */\n\n  }, {\n    key: 'blocks',\n    get: function get$$1() {\n      return this.selection.isUnset ? new List() : this.document.getLeafBlocksAtRange(this.selection);\n    }\n    /**\n     * Get the fragment of the current selection.\n     *\n     * @return {Document}\n     */\n\n  }, {\n    key: 'fragment',\n    get: function get$$1() {\n      return this.selection.isUnset ? Document.create() : this.document.getFragmentAtRange(this.selection);\n    }\n    /**\n     * Get the bottom-most inline nodes in the current selection.\n     *\n     * @return {List<Inline>}\n     */\n\n  }, {\n    key: 'inlines',\n    get: function get$$1() {\n      return this.selection.isUnset ? new List() : this.document.getLeafInlinesAtRange(this.selection);\n    }\n    /**\n     * Get the text nodes in the current selection.\n     *\n     * @return {List<Text>}\n     */\n\n  }, {\n    key: 'texts',\n    get: function get$$1() {\n      return this.selection.isUnset ? new List() : this.document.getTextsAtRange(this.selection);\n    }\n  }, {\n    key: 'history',\n    get: function get$$1() {\n      invariant(false, 'As of Slate 0.42.0, the `value.history` model no longer exists, and the history is stored in `value.data` instead using plugins.');\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Value` with `attrs`.\n     *\n     * @param {Object|Value} attrs\n     * @param {Object} options\n     * @return {Value}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (Value.isValue(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Value.fromJSON(attrs, options);\n      }\n\n      throw new Error('`Value.create` only accepts objects or values, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a dictionary of settable value properties from `attrs`.\n     *\n     * @param {Object|Value} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Value.isValue(a)) {\n        return {\n          annotations: a.annotations,\n          data: a.data\n        };\n      }\n\n      if (isPlainObject(a)) {\n        var p = {};\n        if ('annotations' in a) p.annotations = Annotation.createList(a.annotations);\n        if ('data' in a) p.data = Data.create(a.data);\n        return p;\n      }\n\n      throw new Error('`Value.createProperties` only accepts objects or values, but you passed it: ' + a);\n    }\n    /**\n     * Create a `Value` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @param {Object} options\n     *   @property {Boolean} normalize\n     *   @property {Array} plugins\n     * @return {Value}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          _object$annotations = object.annotations,\n          annotations = _object$annotations === undefined ? {} : _object$annotations,\n          _object$document = object.document,\n          document = _object$document === undefined ? {} : _object$document,\n          _object$selection = object.selection,\n          selection = _object$selection === undefined ? {} : _object$selection;\n      data = Data.fromJSON(data);\n      document = Document.fromJSON(document);\n      selection = document.createSelection(selection);\n      annotations = Annotation.createMap(annotations);\n\n      if (selection.isUnset) {\n        var text = document.getFirstText();\n        if (text) selection = selection.moveToStartOfNode(text);\n        selection = document.createSelection(selection);\n      }\n\n      var value = new Value({\n        annotations: annotations,\n        data: data,\n        document: document,\n        selection: selection\n      });\n      return value;\n    }\n  }]);\n  return Value;\n}(Record(DEFAULTS$10));\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug = Debug('slate:operation:apply');\n/**\n * Apply an `op` to a `value`.\n *\n * @param {Value} value\n * @param {Object|Operation} op\n * @return {Value} value\n */\n\nfunction applyOperation(value, op) {\n  op = Operation.create(op);\n  var _op = op,\n      type = _op.type;\n  debug(type, op);\n\n  switch (type) {\n    case 'add_annotation':\n      {\n        var _op2 = op,\n            annotation = _op2.annotation;\n        var next = value.addAnnotation(annotation);\n        return next;\n      }\n\n    case 'add_mark':\n      {\n        var _op3 = op,\n            path = _op3.path,\n            mark = _op3.mark;\n\n        var _next = value.addMark(path, mark);\n\n        return _next;\n      }\n\n    case 'insert_node':\n      {\n        var _op4 = op,\n            _path = _op4.path,\n            node = _op4.node;\n\n        var _next2 = value.insertNode(_path, node);\n\n        return _next2;\n      }\n\n    case 'insert_text':\n      {\n        var _op5 = op,\n            _path2 = _op5.path,\n            offset = _op5.offset,\n            text = _op5.text,\n            marks = _op5.marks;\n\n        var _next3 = value.insertText(_path2, offset, text, marks);\n\n        return _next3;\n      }\n\n    case 'merge_node':\n      {\n        var _op6 = op,\n            _path3 = _op6.path;\n\n        var _next4 = value.mergeNode(_path3);\n\n        return _next4;\n      }\n\n    case 'move_node':\n      {\n        var _op7 = op,\n            _path4 = _op7.path,\n            newPath = _op7.newPath;\n\n        var _next5 = value.moveNode(_path4, newPath);\n\n        return _next5;\n      }\n\n    case 'remove_annotation':\n      {\n        var _op8 = op,\n            _annotation = _op8.annotation;\n\n        var _next6 = value.removeAnnotation(_annotation);\n\n        return _next6;\n      }\n\n    case 'remove_mark':\n      {\n        var _op9 = op,\n            _path5 = _op9.path,\n            _mark = _op9.mark;\n\n        var _next7 = value.removeMark(_path5, _mark);\n\n        return _next7;\n      }\n\n    case 'remove_node':\n      {\n        var _op10 = op,\n            _path6 = _op10.path;\n\n        var _next8 = value.removeNode(_path6);\n\n        return _next8;\n      }\n\n    case 'remove_text':\n      {\n        var _op11 = op,\n            _path7 = _op11.path,\n            _offset = _op11.offset,\n            _text = _op11.text;\n\n        var _next9 = value.removeText(_path7, _offset, _text);\n\n        return _next9;\n      }\n\n    case 'set_annotation':\n      {\n        var _op12 = op,\n            properties = _op12.properties,\n            newProperties = _op12.newProperties;\n\n        var _next10 = value.setAnnotation(properties, newProperties);\n\n        return _next10;\n      }\n\n    case 'set_mark':\n      {\n        var _op13 = op,\n            _path8 = _op13.path,\n            _properties = _op13.properties,\n            _newProperties = _op13.newProperties;\n\n        var _next11 = value.setMark(_path8, _properties, _newProperties);\n\n        return _next11;\n      }\n\n    case 'set_node':\n      {\n        var _op14 = op,\n            _path9 = _op14.path,\n            _newProperties2 = _op14.newProperties;\n\n        var _next12 = value.setNode(_path9, _newProperties2);\n\n        return _next12;\n      }\n\n    case 'set_selection':\n      {\n        var _op15 = op,\n            _newProperties3 = _op15.newProperties;\n\n        var _next13 = value.setSelection(_newProperties3);\n\n        return _next13;\n      }\n\n    case 'set_value':\n      {\n        var _op16 = op,\n            _newProperties4 = _op16.newProperties;\n\n        var _next14 = value.setProperties(_newProperties4);\n\n        return _next14;\n      }\n\n    case 'split_node':\n      {\n        var _op17 = op,\n            _path10 = _op17.path,\n            position = _op17.position,\n            _properties2 = _op17.properties;\n\n        var _next15 = value.splitNode(_path10, position, _properties2);\n\n        return _next15;\n      }\n\n    default:\n      {\n        throw new Error('Unknown operation type: \"' + type + '\".');\n      }\n  }\n}\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$1 = Debug('slate:operation:invert');\n/**\n * Invert an `op`.\n *\n * @param {Object} op\n * @return {Object}\n */\n\nfunction invertOperation(op) {\n  op = Operation.create(op);\n  var _op = op,\n      type = _op.type;\n  debug$1(type, op);\n\n  switch (type) {\n    case 'move_node':\n      {\n        var _op2 = op,\n            newPath = _op2.newPath,\n            path = _op2.path; // PERF: this case can exit early.\n\n        if (PathUtils.isEqual(newPath, path)) {\n          return op;\n        }\n\n        var inversePath = PathUtils.transform(path, op).first(); // Get the true path we are trying to move back to\n        // We transform the right-sibling of the path\n        // This will end up at the operation.path most of the time\n        // But if the newPath is a left-sibling or left-ancestor-sibling, this will account for it\n\n        var inverseNewPath = PathUtils.transform(PathUtils.increment(path), op).first();\n        var inverse = op.set('path', inversePath).set('newPath', inverseNewPath);\n        return inverse;\n      }\n\n    case 'merge_node':\n      {\n        var _op3 = op,\n            _path = _op3.path;\n\n        var _inversePath = PathUtils.decrement(_path);\n\n        var _inverse = op.set('type', 'split_node').set('path', _inversePath);\n\n        return _inverse;\n      }\n\n    case 'split_node':\n      {\n        var _op4 = op,\n            _path2 = _op4.path;\n\n        var _inversePath2 = PathUtils.increment(_path2);\n\n        var _inverse2 = op.set('type', 'merge_node').set('path', _inversePath2);\n\n        return _inverse2;\n      }\n\n    case 'set_annotation':\n    case 'set_node':\n    case 'set_value':\n    case 'set_selection':\n    case 'set_mark':\n      {\n        var _op5 = op,\n            properties = _op5.properties,\n            newProperties = _op5.newProperties;\n\n        var _inverse3 = op.set('properties', newProperties).set('newProperties', properties);\n\n        return _inverse3;\n      }\n\n    case 'insert_node':\n    case 'insert_text':\n      {\n        var _inverse4 = op.set('type', type.replace('insert_', 'remove_'));\n\n        return _inverse4;\n      }\n\n    case 'remove_node':\n    case 'remove_text':\n      {\n        var _inverse5 = op.set('type', type.replace('remove_', 'insert_'));\n\n        return _inverse5;\n      }\n\n    case 'add_annotation':\n    case 'add_mark':\n      {\n        var _inverse6 = op.set('type', type.replace('add_', 'remove_'));\n\n        return _inverse6;\n      }\n\n    case 'remove_annotation':\n    case 'remove_mark':\n      {\n        var _inverse7 = op.set('type', type.replace('remove_', 'add_'));\n\n        return _inverse7;\n      }\n\n    default:\n      {\n        throw new Error('Unknown operation type: \"' + type + '\".');\n      }\n  }\n}\n/**\n * Operation attributes.\n *\n * @type {Array}\n */\n\n\nvar OPERATION_ATTRIBUTES = {\n  add_mark: ['path', 'mark', 'data'],\n  add_annotation: ['annotation', 'data'],\n  insert_node: ['path', 'node', 'data'],\n  insert_text: ['path', 'offset', 'text', 'data'],\n  merge_node: ['path', 'position', 'properties', 'target', 'data'],\n  move_node: ['path', 'newPath', 'data'],\n  remove_annotation: ['annotation', 'data'],\n  remove_mark: ['path', 'mark', 'data'],\n  remove_node: ['path', 'node', 'data'],\n  remove_text: ['path', 'offset', 'text', 'data'],\n  set_annotation: ['properties', 'newProperties', 'data'],\n  set_mark: ['path', 'properties', 'newProperties', 'data'],\n  set_node: ['path', 'properties', 'newProperties', 'data'],\n  set_selection: ['properties', 'newProperties', 'data'],\n  set_value: ['properties', 'newProperties', 'data'],\n  split_node: ['path', 'position', 'properties', 'target', 'data']\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n};\nvar DEFAULTS$11 = {\n  annotation: undefined,\n  data: undefined,\n  length: undefined,\n  mark: undefined,\n  marks: undefined,\n  newPath: undefined,\n  newProperties: undefined,\n  node: undefined,\n  offset: undefined,\n  path: undefined,\n  position: undefined,\n  properties: undefined,\n  target: undefined,\n  text: undefined,\n  type: undefined\n  /**\n   * Operation.\n   *\n   * @type {Operation}\n   */\n\n};\n\nvar Operation = function (_Record) {\n  inherits(Operation, _Record);\n\n  function Operation() {\n    classCallCheck(this, Operation);\n    return possibleConstructorReturn(this, (Operation.__proto__ || Object.getPrototypeOf(Operation)).apply(this, arguments));\n  }\n\n  createClass(Operation, [{\n    key: 'apply',\n\n    /**\n     * Apply the operation to a `value`.\n     *\n     * @param {Value} value\n     * @return {Value}\n     */\n    value: function apply(value) {\n      var next = applyOperation(value, this);\n      return next;\n    }\n    /**\n     * Invert the operation.\n     *\n     * @return {Operation}\n     */\n\n  }, {\n    key: 'invert',\n    value: function invert() {\n      var inverted = invertOperation(this);\n      return inverted;\n    }\n    /**\n     * Return a JSON representation of the operation.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var object = this.object,\n          type = this.type;\n      var json = {\n        object: object,\n        type: type\n      };\n      var ATTRIBUTES = OPERATION_ATTRIBUTES[type];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = ATTRIBUTES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var key = _step.value;\n          var value = this[key];\n\n          if (key === 'annotation' || key === 'mark' || key === 'marks' || key === 'node' || key === 'path' || key === 'newPath') {\n            value = value.toJSON();\n          }\n\n          if (key === 'properties' && type === 'merge_node') {\n            var v = {};\n            if ('data' in value) v.data = value.data.toJS();\n            if ('type' in value) v.type = value.type;\n            value = v;\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_annotation') {\n            var _v = {};\n            if ('anchor' in value) _v.anchor = value.anchor.toJS();\n            if ('focus' in value) _v.focus = value.focus.toJS();\n            if ('key' in value) _v.key = value.key;\n            if ('mark' in value) _v.mark = value.mark.toJS();\n            value = _v;\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_mark') {\n            var _v2 = {};\n            if ('data' in value) _v2.data = value.data.toJS();\n            if ('type' in value) _v2.type = value.type;\n            value = _v2;\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_node') {\n            var _v3 = {};\n            if ('data' in value) _v3.data = value.data.toJS();\n            if ('type' in value) _v3.type = value.type;\n            value = _v3;\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_selection') {\n            var _v4 = {};\n            if ('anchor' in value) _v4.anchor = value.anchor.toJSON();\n            if ('focus' in value) _v4.focus = value.focus.toJSON();\n            if ('isFocused' in value) _v4.isFocused = value.isFocused;\n            if ('marks' in value) _v4.marks = value.marks && value.marks.toJSON();\n            value = _v4;\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_value') {\n            var _v5 = {};\n            if ('data' in value) _v5.data = value.data.toJS();\n            value = _v5;\n          }\n\n          if (key === 'properties' && type === 'split_node') {\n            var _v6 = {};\n            if ('data' in value) _v6.data = value.data.toJS();\n            if ('type' in value) _v6.type = value.type;\n            value = _v6;\n          }\n\n          if (key === 'data') {\n            value = value.toJSON();\n          }\n\n          json[key] = value;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return json;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Operation` with `attrs`.\n     *\n     * @param {Object|Array|List|String|Operation} attrs\n     * @return {Operation}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Operation.isOperation(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Operation.fromJSON(attrs);\n      }\n\n      throw new Error('`Operation.create` only accepts objects or operations, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a list of `Operations` from `elements`.\n     *\n     * @param {Array<Operation|Object>|List<Operation|Object>} elements\n     * @return {List<Operation>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (List.isList(elements) || Array.isArray(elements)) {\n        var list = new List(elements.map(Operation.create));\n        return list;\n      }\n\n      throw new Error('`Operation.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n    /**\n     * Create a `Operation` from a JSON `object`.\n     *\n     * @param {Object|Operation} object\n     * @return {Operation}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Operation.isOperation(object)) {\n        return object;\n      }\n\n      var type = object.type;\n      var ATTRIBUTES = OPERATION_ATTRIBUTES[type];\n      var attrs = {\n        type: type\n      };\n\n      if (!ATTRIBUTES) {\n        throw new Error('`Operation.fromJSON` was passed an unrecognized operation type: \"' + type + '\"');\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = ATTRIBUTES[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var key = _step2.value;\n          var v = object[key]; // Default `data` to an empty object.\n\n          if (key === 'data' && v === undefined) {\n            v = {};\n          }\n\n          if (v === undefined) {\n            throw new Error('`Operation.fromJSON` was passed a \"' + type + '\" operation without the required \"' + key + '\" attribute.');\n          }\n\n          if (key === 'annotation') {\n            v = Annotation.create(v);\n          }\n\n          if (key === 'path' || key === 'newPath') {\n            v = PathUtils.create(v);\n          }\n\n          if (key === 'mark') {\n            v = Mark.create(v);\n          }\n\n          if (key === 'node') {\n            v = Node.create(v);\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_annotation') {\n            v = Annotation.createProperties(v);\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_mark') {\n            v = Mark.createProperties(v);\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && (type === 'set_node' || type === 'merge_node' || type === 'split_node')) {\n            v = Node.createProperties(v);\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_selection') {\n            v = Selection.createProperties(v);\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_value') {\n            v = Value.createProperties(v);\n          }\n\n          if (key === 'data') {\n            v = Map(v);\n          }\n\n          attrs[key] = v;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      var op = new Operation(attrs);\n      return op;\n    }\n    /**\n     * Check if `any` is a listof operations.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isOperationList',\n    value: function isOperationList(any) {\n      return List.isList(any) && any.every(function (item) {\n        return Operation.isOperation(item);\n      });\n    }\n  }]);\n  return Operation;\n}(Record(DEFAULTS$11));\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$12 = {\n  operations: undefined,\n  value: undefined\n  /**\n   * Change.\n   *\n   * @type {Change}\n   */\n\n};\n\nvar Change = function (_Record) {\n  inherits(Change, _Record);\n\n  function Change() {\n    classCallCheck(this, Change);\n    return possibleConstructorReturn(this, (Change.__proto__ || Object.getPrototypeOf(Change)).apply(this, arguments));\n  }\n\n  createClass(Change, [{\n    key: 'toJSON',\n\n    /**\n     * Return a JSON representation of the change.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        value: this.value.toJSON(options),\n        operations: this.operations.toArray().map(function (o) {\n          return o.toJSON(options);\n        })\n      };\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Change` with `attrs`.\n     *\n     * @param {Object|Change} attrs\n     * @return {Change}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Change.isChange(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Change.fromJSON(attrs);\n      }\n\n      throw new Error('`Change.create` only accepts objects or changes, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a `Change` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Change}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var value = object.value,\n          _object$operations = object.operations,\n          operations = _object$operations === undefined ? [] : _object$operations;\n      var change = new Change({\n        value: Value.create(value),\n        operations: Operation.createList(operations)\n      });\n      return change;\n    }\n  }]);\n  return Change;\n}(Record(DEFAULTS$12));\n/**\n * A plugin that adds a set of commands to the editor.\n *\n * @param {Object} commands\n * @return {Object}\n */\n\n\nfunction CommandsPlugin() {\n  var commands = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  /**\n   * On command, if it exists in our list of commands, call it.\n   *\n   * @param {Object} command\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCommand(command, editor, next) {\n    var type = command.type,\n        args = command.args;\n    var fn = commands[type];\n    if (!fn) return next();\n    editor.command.apply(editor, [fn].concat(toConsumableArray(args)));\n  }\n  /**\n   * On construct, register all the commands.\n   *\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onConstruct(editor, next) {\n    for (var command in commands) {\n      editor.registerCommand(command);\n    }\n\n    return next();\n  }\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n\n  return {\n    onCommand: onCommand,\n    onConstruct: onConstruct\n  };\n}\n/**\n * Surrogate pair start and end points.\n *\n * @type {Number}\n */\n\n\nvar SURROGATE_START = 0xd800;\nvar SURROGATE_END = 0xdfff;\n/**\n * A regex to match space characters.\n *\n * @type {RegExp}\n */\n\nvar SPACE = /\\s/;\n/**\n * A regex to match chameleon characters, that count as word characters as long\n * as they are inside of a word.\n *\n * @type {RegExp}\n */\n\nvar CHAMELEON = /['\\u2018\\u2019]/;\n/**\n * A regex that matches punctuation.\n *\n * @type {RegExp}\n */\n\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\n/**\n * Is a character `code` in a surrogate character.\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isSurrogate(code) {\n  return SURROGATE_START <= code && code <= SURROGATE_END;\n}\n/**\n * Is a character a word character? Needs the `remaining` characters too.\n *\n * @param {String} char\n * @param {String|Void} remaining\n * @return {Boolean}\n */\n\n\nfunction isWord(_char, remaining) {\n  if (SPACE.test(_char)) return false; // If it's a chameleon character, recurse to see if the next one is or not.\n\n  if (CHAMELEON.test(_char)) {\n    var next = remaining.charAt(0);\n    var length = getCharLength(next);\n    next = remaining.slice(0, length);\n    var rest = remaining.slice(length);\n    if (isWord(next, rest)) return true;\n  }\n\n  if (PUNCTUATION.test(_char)) return false;\n  return true;\n}\n/**\n * Get the length of a `character`.\n *\n * @param {String} char\n * @return {Number}\n */\n\n\nfunction getCharLength(_char2) {\n  return isSurrogate(_char2.charCodeAt(0)) ? 2 : 1;\n}\n/**\n * Get the offset to the end of the first character in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\n\nfunction getCharOffset(text) {\n  var _char3 = text.charAt(0);\n\n  return getCharLength(_char3);\n}\n/**\n * Get the offset to the end of the character before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\n\nfunction getCharOffsetBackward(text, offset) {\n  text = text.slice(0, offset);\n  text = reverse(text);\n  return getCharOffset(text);\n}\n/**\n * Get the offset to the end of the character after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\n\nfunction getCharOffsetForward(text, offset) {\n  text = text.slice(offset);\n  return getCharOffset(text);\n}\n/**\n * Get the offset to the end of the first word in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\n\nfunction getWordOffset(text) {\n  var length = 0;\n  var i = 0;\n  var started = false;\n\n  var _char4 = void 0;\n\n  while (_char4 = text.charAt(i)) {\n    var l = getCharLength(_char4);\n    _char4 = text.slice(i, i + l);\n    var rest = text.slice(i + l);\n\n    if (isWord(_char4, rest)) {\n      started = true;\n      length += l;\n    } else if (!started) {\n      length += l;\n    } else {\n      break;\n    }\n\n    i += l;\n  }\n\n  return length;\n}\n/**\n * Get the offset to the end of the word before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\n\nfunction getWordOffsetBackward(text, offset) {\n  text = text.slice(0, offset);\n  text = reverse(text);\n  var o = getWordOffset(text);\n  return o;\n}\n/**\n * Get the offset to the end of the word after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\n\nfunction getWordOffsetForward(text, offset) {\n  text = text.slice(offset);\n  var o = getWordOffset(text);\n  return o;\n}\n/**\n * Export.\n *\n * @type {Object}\n */\n\n\nvar TextUtils = {\n  getCharLength: getCharLength,\n  getCharOffset: getCharOffset,\n  getCharOffsetBackward: getCharOffsetBackward,\n  getCharOffsetForward: getCharOffsetForward,\n  getWordOffset: getWordOffset,\n  getWordOffsetBackward: getWordOffsetBackward,\n  getWordOffsetForward: getWordOffsetForward,\n  isSurrogate: isSurrogate,\n  isWord: isWord\n};\n/**\n * Ensure that an expanded selection is deleted first, and return the updated\n * range to account for the deleted part.\n *\n * @param {Editor}\n */\n\nfunction deleteExpandedAtRange(editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var _range = range,\n      start = _range.start,\n      end = _range.end;\n\n  if (document.hasDescendant(start.path)) {\n    range = range.moveToStart();\n  } else {\n    range = range.moveTo(end.path, 0).normalize(document);\n  }\n\n  return range;\n}\n/**\n * Commands.\n *\n * @type {Object}\n */\n\n\nvar Commands$1 = {};\n/**\n * Add a new `mark` to the characters at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Mixed} mark\n */\n\nCommands$1.addMarkAtRange = function (editor, range, mark) {\n  if (range.isCollapsed) return;\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start,\n      end = range.end;\n  var texts = document.getTextsAtRange(range);\n  editor.withoutNormalizing(function () {\n    texts.forEach(function (node) {\n      var key = node.key;\n      var index = 0;\n      var length = node.text.length;\n      if (key === start.key) index = start.offset;\n      if (key === end.key) length = end.offset;\n      if (key === start.key && key === end.key) length = end.offset - start.offset;\n      editor.addMarkByKey(key, index, length, mark);\n    });\n  });\n};\n/**\n * Add a list of `marks` to the characters at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Array<Mixed>} mark\n */\n\n\nCommands$1.addMarksAtRange = function (editor, range, marks) {\n  marks.forEach(function (mark) {\n    return editor.addMarkAtRange(range, mark);\n  });\n};\n/**\n * Delete everything in a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\n\nCommands$1.deleteAtRange = function (editor, range) {\n  // Snapshot the selection, which creates an extra undo save point, so that\n  // when you undo a delete, the expanded selection will be retained.\n  editor.snapshotSelection();\n  var value = editor.value;\n  var start = range.start,\n      end = range.end;\n  var startKey = start.key;\n  var startOffset = start.offset;\n  var endKey = end.key;\n  var endOffset = end.offset;\n  var document = value.document;\n  var isStartVoid = document.hasVoidParent(startKey, editor);\n  var isEndVoid = document.hasVoidParent(endKey, editor);\n  var startBlock = document.getClosestBlock(startKey);\n  var endBlock = document.getClosestBlock(endKey); // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n\n  var isHanging = startOffset === 0 && endOffset === 0 && isStartVoid === false && startKey === startBlock.getFirstText().key && endKey === endBlock.getFirstText().key; // If it's a hanging selection, nudge it back to end in the previous text.\n\n  if (isHanging && isEndVoid) {\n    var prevText = document.getPreviousText(endKey);\n    endKey = prevText.key;\n    endOffset = prevText.text.length;\n    isEndVoid = document.hasVoidParent(endKey, editor);\n  }\n\n  editor.withoutNormalizing(function () {\n    // If the start node is inside a void node, remove the void node and update\n    // the starting point to be right after it, continuously until the start point\n    // is not a void, or until the entire range is handled.\n    while (isStartVoid) {\n      var startVoid = document.getClosestVoid(startKey, editor);\n      var nextText = document.getNextText(startKey);\n      editor.removeNodeByKey(startVoid.key); // If the start and end keys are the same, we're done.\n\n      if (startKey === endKey) return; // If there is no next text node, we're done.\n\n      if (!nextText) return; // Continue...\n\n      document = editor.value.document;\n      startKey = nextText.key;\n      startOffset = 0;\n      isStartVoid = document.hasVoidParent(startKey, editor);\n    } // If the end node is inside a void node, do the same thing but backwards. But\n    // we don't need any aborting checks because if we've gotten this far there\n    // must be a non-void node that will exit the loop.\n\n\n    while (isEndVoid) {\n      var endVoid = document.getClosestVoid(endKey, editor);\n\n      var _prevText = document.getPreviousText(endKey);\n\n      editor.removeNodeByKey(endVoid.key); // Continue...\n\n      document = editor.value.document;\n      endKey = _prevText.key;\n      endOffset = _prevText.text.length;\n      isEndVoid = document.hasVoidParent(endKey, editor);\n    } // If the start and end key are the same, and it was a hanging selection, we\n    // can just remove the entire block.\n\n\n    if (startKey === endKey && isHanging) {\n      editor.removeNodeByKey(startBlock.key);\n      return;\n    } else if (startKey === endKey) {\n      // Otherwise, if it wasn't hanging, we're inside a single text node, so we can\n      // simply remove the text in the range.\n      var index = startOffset;\n      var length = endOffset - startOffset;\n      editor.removeTextByKey(startKey, index, length);\n      return;\n    } else {\n      // Otherwise, we need to recursively remove text and nodes inside the start\n      // block after the start offset and inside the end block before the end\n      // offset. Then remove any blocks that are in between the start and end\n      // blocks. Then finally merge the start and end nodes.\n      startBlock = document.getClosestBlock(startKey);\n      endBlock = document.getClosestBlock(endKey);\n      var startText = document.getNode(startKey);\n      var endText = document.getNode(endKey);\n      var startLength = startText.text.length - startOffset;\n      var endLength = endOffset;\n      var ancestor = document.getCommonAncestor(startKey, endKey);\n      var startChild = ancestor.getFurthestChild(startKey);\n      var endChild = ancestor.getFurthestChild(endKey);\n      var startParent = document.getParent(startBlock.key);\n      var startParentIndex = startParent.nodes.indexOf(startBlock);\n      var endParentIndex = startParent.nodes.indexOf(endBlock);\n      var child = void 0; // Iterate through all of the nodes in the tree after the start text node\n      // but inside the end child, and remove them.\n\n      child = startText;\n\n      while (child.key !== startChild.key) {\n        var parent = document.getParent(child.key);\n\n        var _index = parent.nodes.indexOf(child);\n\n        var afters = parent.nodes.slice(_index + 1);\n        afters.reverse().forEach(function (node) {\n          editor.removeNodeByKey(node.key);\n        });\n        child = parent;\n      } // Remove all of the middle children.\n\n\n      var startChildIndex = ancestor.nodes.indexOf(startChild);\n      var endChildIndex = ancestor.nodes.indexOf(endChild);\n      var middles = ancestor.nodes.slice(startChildIndex + 1, endChildIndex);\n      middles.reverse().forEach(function (node) {\n        editor.removeNodeByKey(node.key);\n      }); // Remove the nodes before the end text node in the tree.\n\n      child = endText;\n\n      while (child.key !== endChild.key) {\n        var _parent = document.getParent(child.key);\n\n        var _index2 = _parent.nodes.indexOf(child);\n\n        var befores = _parent.nodes.slice(0, _index2);\n\n        befores.reverse().forEach(function (node) {\n          editor.removeNodeByKey(node.key);\n        });\n        child = _parent;\n      } // Remove any overlapping text content from the leaf text nodes.\n\n\n      if (startLength !== 0) {\n        editor.removeTextByKey(startKey, startOffset, startLength);\n      }\n\n      if (endLength !== 0) {\n        editor.removeTextByKey(endKey, 0, endOffset);\n      } // If the start and end blocks aren't the same, move and merge the end block\n      // into the start block.\n\n\n      if (startBlock.key !== endBlock.key) {\n        document = editor.value.document;\n        var onlyChildAncestor = void 0;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = document.ancestors(endBlock.key)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref = _step.value;\n\n            var _ref2 = slicedToArray(_ref, 1);\n\n            var node = _ref2[0];\n\n            if (node.nodes.size > 1) {\n              break;\n            } else {\n              onlyChildAncestor = node;\n            }\n          } // Move the end block to be right after the start block.\n\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        if (endParentIndex !== startParentIndex + 1) {\n          editor.moveNodeByKey(endBlock.key, startParent.key, startParentIndex + 1);\n        } // If the selection is hanging, just remove the start block, otherwise\n        // merge the end block into it.\n\n\n        if (isHanging) {\n          editor.removeNodeByKey(startBlock.key);\n        } else {\n          editor.mergeNodeByKey(endBlock.key);\n        } // If nested empty blocks are left over above the end block, remove them.\n\n\n        if (onlyChildAncestor) {\n          editor.removeNodeByKey(onlyChildAncestor.key);\n        }\n      }\n    }\n  });\n};\n/**\n * Delete backward `n` characters at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} n (optional)\n */\n\n\nCommands$1.deleteBackwardAtRange = function (editor, range) {\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  if (n === 0) return;\n  var value = editor.value;\n  var document = value.document;\n  var _range2 = range,\n      start = _range2.start,\n      focus = _range2.focus; // If the range is expanded, perform a regular delete instead.\n\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var voidParent = document.getClosestVoid(start.path, editor); // If there is a void parent, delete it.\n\n  if (voidParent) {\n    editor.removeNodeByKey(voidParent.key);\n    return;\n  } // If the range is at the start of the document, abort.\n\n\n  if (start.isAtStartOfNode(document)) {\n    return;\n  }\n\n  var block = document.getClosestBlock(start.path); // PERF: If the closest block is empty, remove it. This is just a shortcut,\n  // since merging it would result in the same outcome.\n\n  if (document.nodes.size !== 1 && block && block.text === '' && block.nodes.size === 1) {\n    editor.removeNodeByKey(block.key);\n    return;\n  } // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n\n\n  var text = document.getDescendant(start.path);\n\n  if (start.isAtStartOfNode(text)) {\n    var prev = document.getPreviousText(text.key);\n    var inline = document.getClosestInline(text.key); // If the range is at the start of the inline node, and previous text node\n    // is empty, take the text node before that, or \"prevBlock\" would be the\n    // same node as \"block\"\n\n    if (inline && prev.text === '') {\n      prev = document.getPreviousText(prev.key);\n    }\n\n    var prevBlock = document.getClosestBlock(prev.key);\n    var prevVoid = document.getClosestVoid(prev.key, editor); // If the previous text node has a void parent, remove it.\n\n    if (prevVoid) {\n      editor.removeNodeByKey(prevVoid.key);\n      return;\n    } // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n\n\n    if (n === 1 && prevBlock !== block) {\n      range = range.moveAnchorTo(prev.key, prev.text.length);\n      editor.deleteAtRange(range);\n      return;\n    }\n  } // If the focus offset is farther than the number of characters to delete,\n  // just remove the characters backwards inside the current node.\n\n\n  if (n < focus.offset) {\n    range = range.moveFocusBackward(n);\n    editor.deleteAtRange(range);\n    return;\n  } // Otherwise, we need to see how many nodes backwards to go.\n\n\n  var node = text;\n  var offset = 0;\n  var traversed = focus.offset;\n\n  while (n > traversed) {\n    node = document.getPreviousText(node.key);\n    var next = traversed + node.text.length;\n\n    if (n <= next) {\n      offset = next - n;\n      break;\n    } else {\n      traversed = next;\n    }\n  }\n\n  range = range.moveAnchorTo(node.key, offset);\n  editor.deleteAtRange(range);\n};\n/**\n * Delete backward until the character boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\n\nCommands$1.deleteCharBackwardAtRange = function (editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start;\n  var startBlock = document.getClosestBlock(start.path);\n  var offset = startBlock.getOffset(start.key);\n  var o = offset + start.offset;\n  var text = startBlock.text;\n  var n = TextUtils.getCharOffsetBackward(text, o);\n  editor.deleteBackwardAtRange(range, n);\n};\n/**\n * Delete forward until the character boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\n\nCommands$1.deleteCharForwardAtRange = function (editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start;\n  var startBlock = document.getClosestBlock(start.path);\n  var offset = startBlock.getOffset(start.key);\n  var o = offset + start.offset;\n  var text = startBlock.text;\n  var n = TextUtils.getCharOffsetForward(text, o);\n  editor.deleteForwardAtRange(range, n);\n};\n/**\n * Delete forward `n` characters at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} n (optional)\n */\n\n\nCommands$1.deleteForwardAtRange = function (editor, range) {\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  if (n === 0) return;\n  var value = editor.value;\n  var document = value.document;\n  var _range3 = range,\n      start = _range3.start,\n      focus = _range3.focus; // If the range is expanded, perform a regular delete instead.\n\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var voidParent = document.getClosestVoid(start.path, editor); // If the node has a void parent, delete it.\n\n  if (voidParent) {\n    editor.removeNodeByKey(voidParent.key);\n    return;\n  }\n\n  var block = document.getClosestBlock(start.path); // If the closest is not void, but empty, remove it\n\n  if (block && !editor.isVoid(block) && block.text === '' && document.nodes.size !== 1) {\n    var nextBlock = document.getNextBlock(block.key);\n    editor.removeNodeByKey(block.key);\n\n    if (nextBlock && nextBlock.key) {\n      editor.moveToStartOfNode(nextBlock);\n    }\n\n    return;\n  } // If the range is at the start of the document, abort.\n\n\n  if (start.isAtEndOfNode(document)) {\n    return;\n  } // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n\n\n  var text = document.getDescendant(start.path);\n\n  if (start.isAtEndOfNode(text)) {\n    var next = document.getNextText(text.key);\n\n    var _nextBlock = document.getClosestBlock(next.key);\n\n    var nextVoid = document.getClosestVoid(next.key, editor); // If the next text node has a void parent, remove it.\n\n    if (nextVoid) {\n      editor.removeNodeByKey(nextVoid.key);\n      return;\n    } // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n\n\n    if (n === 1 && _nextBlock !== block) {\n      range = range.moveFocusTo(next.key, 0);\n      editor.deleteAtRange(range);\n      return;\n    }\n  } // If the remaining characters to the end of the node is greater than or equal\n  // to the number of characters to delete, just remove the characters forwards\n  // inside the current node.\n\n\n  if (n <= text.text.length - focus.offset) {\n    range = range.moveFocusForward(n);\n    editor.deleteAtRange(range);\n    return;\n  } // Otherwise, we need to see how many nodes forwards to go.\n\n\n  var node = text;\n  var offset = focus.offset;\n  var traversed = text.text.length - focus.offset;\n\n  while (n > traversed) {\n    node = document.getNextText(node.key);\n\n    var _next = traversed + node.text.length;\n\n    if (n <= _next) {\n      offset = n - traversed;\n      break;\n    } else {\n      traversed = _next;\n    }\n  }\n\n  range = range.moveFocusTo(node.key, offset);\n  editor.deleteAtRange(range);\n};\n/**\n * Delete backward until the line boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\n\nCommands$1.deleteLineBackwardAtRange = function (editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start;\n  var startBlock = document.getClosestBlock(start.path);\n  var offset = startBlock.getOffset(start.key);\n  var o = offset + start.offset;\n  editor.deleteBackwardAtRange(range, o);\n};\n/**\n * Delete forward until the line boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\n\nCommands$1.deleteLineForwardAtRange = function (editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start;\n  var startBlock = document.getClosestBlock(start.path);\n  var offset = startBlock.getOffset(start.key);\n  var o = offset + start.offset;\n  editor.deleteForwardAtRange(range, startBlock.text.length - o);\n};\n/**\n * Delete backward until the word boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\n\nCommands$1.deleteWordBackwardAtRange = function (editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start;\n  var startBlock = document.getClosestBlock(start.path);\n  var offset = startBlock.getOffset(start.key);\n  var o = offset + start.offset;\n  var text = startBlock.text;\n  var n = o === 0 ? 1 : TextUtils.getWordOffsetBackward(text, o);\n  editor.deleteBackwardAtRange(range, n);\n};\n/**\n * Delete forward until the word boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\n\nCommands$1.deleteWordForwardAtRange = function (editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start;\n  var startBlock = document.getClosestBlock(start.path);\n  var offset = startBlock.getOffset(start.key);\n  var o = offset + start.offset;\n  var text = startBlock.text;\n  var wordOffset = TextUtils.getWordOffsetForward(text, o);\n  var n = wordOffset === 0 ? 1 : wordOffset;\n  editor.deleteForwardAtRange(range, n);\n};\n/**\n * Insert a `block` node at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Block|String|Object} block\n */\n\n\nCommands$1.insertBlockAtRange = function (editor, range, block) {\n  range = deleteExpandedAtRange(editor, range);\n  block = Block.create(block);\n  var value = editor.value;\n  var document = value.document;\n  var _range4 = range,\n      start = _range4.start;\n  var startKey = start.key;\n  var startOffset = start.offset;\n  var startBlock = document.getClosestBlock(startKey);\n  var startInline = document.getClosestInline(startKey);\n  var parent = document.getParent(startBlock.key);\n  var index = parent.nodes.indexOf(startBlock);\n\n  if (editor.isVoid(startBlock)) {\n    var extra = start.isAtEndOfNode(startBlock) ? 1 : 0;\n    editor.insertNodeByKey(parent.key, index + extra, block);\n  } else if (!startInline && startBlock.text === '') {\n    editor.insertNodeByKey(parent.key, index + 1, block);\n  } else if (start.isAtStartOfNode(startBlock)) {\n    editor.insertNodeByKey(parent.key, index, block);\n  } else if (start.isAtEndOfNode(startBlock)) {\n    editor.insertNodeByKey(parent.key, index + 1, block);\n  } else {\n    if (startInline && editor.isVoid(startInline)) {\n      var atEnd = start.isAtEndOfNode(startInline);\n      var siblingText = atEnd ? document.getNextText(startKey) : document.getPreviousText(startKey);\n      var splitRange = atEnd ? range.moveToStartOfNode(siblingText) : range.moveToEndOfNode(siblingText);\n      startKey = splitRange.start.key;\n      startOffset = splitRange.start.offset;\n    }\n\n    editor.withoutNormalizing(function () {\n      editor.splitDescendantsByKey(startBlock.key, startKey, startOffset);\n      editor.insertNodeByKey(parent.key, index + 1, block);\n    });\n  }\n};\n/**\n * Insert a `fragment` at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Document} fragment\n */\n\n\nCommands$1.insertFragmentAtRange = function (editor, range, fragment) {\n  editor.withoutNormalizing(function () {\n    range = deleteExpandedAtRange(editor, range); // If the fragment is empty, there's nothing to do after deleting.\n\n    if (!fragment.nodes.size) return; // Regenerate the keys for all of the fragments nodes, so that they're\n    // guaranteed not to collide with the existing keys in the document. Otherwise\n    // they will be rengerated automatically and we won't have an easy way to\n    // reference them.\n\n    fragment = fragment.mapDescendants(function (child) {\n      return child.regenerateKey();\n    }); // Calculate a few things...\n\n    var _range5 = range,\n        start = _range5.start;\n    var value = editor.value;\n    var document = value.document;\n    var startText = document.getDescendant(start.path);\n    var startBlock = document.getClosestBlock(startText.key);\n    var startChild = startBlock.getFurthestChild(startText.key);\n    var isAtStart = start.isAtStartOfNode(startBlock);\n    var parent = document.getParent(startBlock.key);\n    var index = parent.nodes.indexOf(startBlock);\n    var blocks = fragment.getBlocks();\n    var firstChild = fragment.nodes.first();\n    var lastChild = fragment.nodes.last();\n    var firstBlock = blocks.first();\n    var lastBlock = blocks.last();\n    var insertionNode = findInsertionNode(fragment, document, startBlock.key); // If the fragment only contains a void block, use `insertBlock` instead.\n\n    if (firstBlock === lastBlock && editor.isVoid(firstBlock)) {\n      editor.insertBlockAtRange(range, firstBlock);\n      return;\n    } // If inserting the entire fragment and it starts or ends with a single\n    // nested block, e.g. a table, we do not merge it with existing blocks.\n\n\n    if (insertionNode === fragment && (firstChild.hasBlockChildren() || lastChild.hasBlockChildren())) {\n      fragment.nodes.reverse().forEach(function (node) {\n        editor.insertBlockAtRange(range, node);\n      });\n      return;\n    } // If the first and last block aren't the same, we need to insert all of the\n    // nodes after the insertion node's first block at the index.\n\n\n    if (firstBlock !== lastBlock) {\n      var lonelyParent = insertionNode.getFurthest(firstBlock.key, function (p) {\n        return p.nodes.size === 1;\n      });\n      var lonelyChild = lonelyParent || firstBlock;\n      var startIndex = parent.nodes.indexOf(startBlock);\n      var excludingLonelyChild = insertionNode.removeNode(lonelyChild.key);\n      excludingLonelyChild.nodes.forEach(function (node, i) {\n        var newIndex = startIndex + i + 1;\n        editor.insertNodeByKey(parent.key, newIndex, node);\n      });\n    } // Check if we need to split the node.\n\n\n    if (start.offset !== 0) {\n      editor.splitDescendantsByKey(startChild.key, start.key, start.offset);\n    } // Update our variables with the new value.\n\n\n    document = editor.value.document;\n    startText = document.getDescendant(start.key);\n    startBlock = document.getClosestBlock(start.key);\n    startChild = startBlock.getFurthestChild(startText.key); // If the first and last block aren't the same, we need to move any of the\n    // starting block's children after the split into the last block of the\n    // fragment, which has already been inserted.\n\n    if (firstBlock !== lastBlock) {\n      var nextChild = isAtStart ? startChild : startBlock.getNextSibling(startChild.key);\n      var nextNodes = nextChild ? startBlock.nodes.skipUntil(function (n) {\n        return n.key === nextChild.key;\n      }) : List();\n      var lastIndex = lastBlock.nodes.size;\n      nextNodes.forEach(function (node, i) {\n        var newIndex = lastIndex + i;\n        editor.moveNodeByKey(node.key, lastBlock.key, newIndex);\n      });\n    } // If the starting block is empty, we replace it entirely with the first block\n    // of the fragment, since this leads to a more expected behavior for the user.\n\n\n    if (!editor.isVoid(startBlock) && startBlock.text === '' && !startBlock.findDescendant(function (n) {\n      return editor.isVoid(n);\n    })) {\n      editor.removeNodeByKey(startBlock.key);\n      editor.insertNodeByKey(parent.key, index, firstBlock);\n    } else {\n      // Otherwise, we maintain the starting block, and insert all of the first\n      // block's inline nodes into it at the split point.\n      var inlineChild = startBlock.getFurthestChild(startText.key);\n      var inlineIndex = startBlock.nodes.indexOf(inlineChild);\n      firstBlock.nodes.forEach(function (inline, i) {\n        var o = start.offset === 0 ? 0 : 1;\n        var newIndex = inlineIndex + i + o;\n        editor.insertNodeByKey(startBlock.key, newIndex, inline);\n      });\n    }\n  });\n};\n\nvar findInsertionNode = function findInsertionNode(fragment, document, startKey) {\n  var hasSingleNode = function hasSingleNode(object) {\n    if (!object || object.object === 'text') return;\n    return object.nodes.size === 1;\n  };\n\n  var firstNode = function firstNode(object) {\n    return object && object.nodes.first();\n  };\n\n  var node = fragment;\n\n  if (hasSingleNode(fragment)) {\n    var fragmentInner = firstNode(fragment);\n\n    var matches = function matches(documentNode) {\n      return documentNode.type === fragmentInner.type;\n    };\n\n    var documentInner = document.getFurthest(startKey, matches);\n    if (documentInner === document.getParent(startKey)) node = fragmentInner;\n\n    while (hasSingleNode(fragmentInner) && hasSingleNode(documentInner)) {\n      fragmentInner = firstNode(fragmentInner);\n      documentInner = firstNode(documentInner);\n\n      if (fragmentInner.type === documentInner.type) {\n        node = fragmentInner;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return node;\n};\n/**\n * Insert an `inline` node at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Inline|String|Object} inline\n */\n\n\nCommands$1.insertInlineAtRange = function (editor, range, inline) {\n  inline = Inline.create(inline);\n  editor.withoutNormalizing(function () {\n    range = deleteExpandedAtRange(editor, range);\n    var value = editor.value;\n    var document = value.document;\n    var _range6 = range,\n        start = _range6.start;\n    var parent = document.getParent(start.path);\n    var startText = document.assertDescendant(start.path);\n    var index = parent.nodes.indexOf(startText);\n\n    if (editor.isVoid(parent)) {\n      return;\n    }\n\n    editor.splitNodeByPath(start.path, start.offset);\n    editor.insertNodeByKey(parent.key, index + 1, inline);\n  });\n};\n/**\n * Insert `text` at a `range`, with optional `marks`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\n\nCommands$1.insertTextAtRange = function (editor, range, text, marks) {\n  editor.withoutNormalizing(function () {\n    range = deleteExpandedAtRange(editor, range);\n    var value = editor.value;\n    var document = value.document;\n    var _range7 = range,\n        start = _range7.start;\n    var offset = start.offset;\n    var parent = document.getParent(start.path);\n\n    if (editor.isVoid(parent)) {\n      return;\n    }\n\n    editor.insertTextByPath(start.path, offset, text, marks);\n  });\n};\n/**\n * Remove an existing `mark` to the characters at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Mark|String} mark (optional)\n */\n\n\nCommands$1.removeMarkAtRange = function (editor, range, mark) {\n  if (range.isCollapsed) return;\n  var value = editor.value;\n  var document = value.document;\n  var texts = document.getTextsAtRange(range);\n  var start = range.start,\n      end = range.end;\n  editor.withoutNormalizing(function () {\n    texts.forEach(function (node) {\n      var key = node.key;\n      var index = 0;\n      var length = node.text.length;\n      if (key === start.key) index = start.offset;\n      if (key === end.key) length = end.offset;\n      if (key === start.key && key === end.key) length = end.offset - start.offset;\n      editor.removeMarkByKey(key, index, length, mark);\n    });\n  });\n};\n/**\n * Set the `properties` of block nodes in a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Object|String} properties\n */\n\n\nCommands$1.setBlocksAtRange = function (editor, range, properties) {\n  var value = editor.value;\n  var document = value.document;\n  var blocks = document.getLeafBlocksAtRange(range);\n  var start = range.start,\n      end = range.end,\n      isCollapsed = range.isCollapsed;\n  var isStartVoid = document.hasVoidParent(start.path, editor);\n  var startBlock = document.getClosestBlock(start.path);\n  var endBlock = document.getClosestBlock(end.key); // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n\n  var isHanging = isCollapsed === false && start.offset === 0 && end.offset === 0 && isStartVoid === false && start.key === startBlock.getFirstText().key && end.key === endBlock.getFirstText().key; // If it's a hanging selection, ignore the last block.\n\n  var sets = isHanging ? blocks.slice(0, -1) : blocks;\n  editor.withoutNormalizing(function () {\n    sets.forEach(function (block) {\n      editor.setNodeByKey(block.key, properties);\n    });\n  });\n};\n/**\n * Set the `properties` of inline nodes in a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Object|String} properties\n */\n\n\nCommands$1.setInlinesAtRange = function (editor, range, properties) {\n  var value = editor.value;\n  var document = value.document;\n  var inlines = document.getLeafInlinesAtRange(range);\n  editor.withoutNormalizing(function () {\n    inlines.forEach(function (inline) {\n      editor.setNodeByKey(inline.key, properties);\n    });\n  });\n};\n/**\n * Split the block nodes at a `range`, to optional `height`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} height (optional)\n */\n\n\nCommands$1.splitBlockAtRange = function (editor, range) {\n  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  range = deleteExpandedAtRange(editor, range);\n  var _range8 = range,\n      start = _range8.start,\n      end = _range8.end;\n  var value = editor.value;\n  var _value = value,\n      document = _value.document;\n  var node = document.assertDescendant(start.path);\n  var parent = document.getClosestBlock(node.key);\n  var h = 0;\n\n  while (parent && parent.object === 'block' && h < height) {\n    node = parent;\n    parent = document.getClosestBlock(parent.key);\n    h++;\n  }\n\n  editor.withoutNormalizing(function () {\n    editor.splitDescendantsByKey(node.key, start.path, start.offset);\n    value = editor.value;\n    document = value.document;\n\n    if (range.isExpanded) {\n      if (range.isBackward) range = range.flip();\n      var nextBlock = document.getNextBlock(node.key);\n      range = range.moveAnchorToStartOfNode(nextBlock);\n      range = range.setFocus(range.focus.setPath(null));\n\n      if (start.path.equals(end.path)) {\n        range = range.moveFocusTo(range.anchor.key, end.offset - start.offset);\n      }\n\n      range = document.resolveRange(range);\n      editor.deleteAtRange(range);\n    }\n  });\n};\n/**\n * Split the inline nodes at a `range`, to optional `height`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} height (optional)\n */\n\n\nCommands$1.splitInlineAtRange = function (editor, range) {\n  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n  range = deleteExpandedAtRange(editor, range);\n  var _range9 = range,\n      start = _range9.start;\n  var value = editor.value;\n  var document = value.document;\n  var node = document.assertDescendant(start.path);\n  var parent = document.getClosestInline(node.key);\n  var h = 0;\n\n  while (parent && parent.object === 'inline' && h < height) {\n    node = parent;\n    parent = document.getClosestInline(parent.key);\n    h++;\n  }\n\n  editor.splitDescendantsByKey(node.key, start.path, start.offset);\n};\n/**\n * Add or remove a `mark` from the characters at `range`, depending on whether\n * it's already there.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Mixed} mark\n */\n\n\nCommands$1.toggleMarkAtRange = function (editor, range, mark) {\n  if (range.isCollapsed) return;\n  mark = Mark.create(mark);\n  var value = editor.value;\n  var document = value.document;\n  var marks = document.getActiveMarksAtRange(range);\n  var exists = marks.some(function (m) {\n    return m.equals(mark);\n  });\n\n  if (exists) {\n    editor.removeMarkAtRange(range, mark);\n  } else {\n    editor.addMarkAtRange(range, mark);\n  }\n};\n/**\n * Unwrap all of the block nodes in a `range` from a block with `properties`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String|Object} properties\n */\n\n\nCommands$1.unwrapBlockAtRange = function (editor, range, properties) {\n  properties = Node.createProperties(properties);\n  var value = editor.value;\n  var document = value.document;\n  var blocks = document.getLeafBlocksAtRange(range);\n  var wrappers = blocks.map(function (block) {\n    return document.getClosest(block.key, function (parent) {\n      if (parent.object !== 'block') return false;\n      if (properties.type != null && parent.type !== properties.type) return false;\n      if (properties.data != null && !parent.data.isSuperset(properties.data)) return false;\n      return true;\n    });\n  }).filter(function (exists) {\n    return exists;\n  }).toOrderedSet().toList();\n  editor.withoutNormalizing(function () {\n    wrappers.forEach(function (block) {\n      var first = block.nodes.first();\n      var last = block.nodes.last();\n      var parent = editor.value.document.getParent(block.key);\n      var index = parent.nodes.indexOf(block);\n      var children = block.nodes.filter(function (child) {\n        return blocks.some(function (b) {\n          return child === b || child.hasDescendant(b.key);\n        });\n      });\n      var firstMatch = children.first();\n      var lastMatch = children.last();\n\n      if (first === firstMatch && last === lastMatch) {\n        block.nodes.forEach(function (child, i) {\n          editor.moveNodeByKey(child.key, parent.key, index + i);\n        });\n        editor.removeNodeByKey(block.key);\n      } else if (last === lastMatch) {\n        block.nodes.skipUntil(function (n) {\n          return n === firstMatch;\n        }).forEach(function (child, i) {\n          editor.moveNodeByKey(child.key, parent.key, index + 1 + i);\n        });\n      } else if (first === firstMatch) {\n        block.nodes.takeUntil(function (n) {\n          return n === lastMatch;\n        }).push(lastMatch).forEach(function (child, i) {\n          editor.moveNodeByKey(child.key, parent.key, index + i);\n        });\n      } else {\n        var firstText = firstMatch.getFirstText();\n        editor.splitDescendantsByKey(block.key, firstText.key, 0);\n        document = editor.value.document;\n        children.forEach(function (child, i) {\n          if (i === 0) {\n            var extra = child;\n            child = document.getNextBlock(child.key);\n            editor.removeNodeByKey(extra.key);\n          }\n\n          editor.moveNodeByKey(child.key, parent.key, index + 1 + i);\n        });\n      }\n    });\n  });\n};\n/**\n * Unwrap the inline nodes in a `range` from an inline with `properties`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String|Object} properties\n */\n\n\nCommands$1.unwrapInlineAtRange = function (editor, range, properties) {\n  properties = Node.createProperties(properties);\n  var value = editor.value;\n  var document = value.document;\n  var texts = document.getTextsAtRange(range);\n  var inlines = texts.map(function (text) {\n    return document.getClosest(text.key, function (parent) {\n      if (parent.object !== 'inline') return false;\n      if (properties.type != null && parent.type !== properties.type) return false;\n      if (properties.data != null && !parent.data.isSuperset(properties.data)) return false;\n      return true;\n    });\n  }).filter(function (exists) {\n    return exists;\n  }).toOrderedSet().toList();\n  editor.withoutNormalizing(function () {\n    inlines.forEach(function (inline) {\n      var parent = editor.value.document.getParent(inline.key);\n      var index = parent.nodes.indexOf(inline);\n      inline.nodes.forEach(function (child, i) {\n        editor.moveNodeByKey(child.key, parent.key, index + i);\n      });\n      editor.removeNodeByKey(inline.key);\n    });\n  });\n};\n/**\n * Wrap all of the blocks in a `range` in a new `block`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Block|Object|String} block\n */\n\n\nCommands$1.wrapBlockAtRange = function (editor, range, block) {\n  block = Block.create(block);\n  block = block.set('nodes', block.nodes.clear());\n  var value = editor.value;\n  var document = value.document;\n  var blocks = document.getLeafBlocksAtRange(range);\n  var firstblock = blocks.first();\n  var lastblock = blocks.last();\n  var parent = void 0,\n      siblings = void 0,\n      index = void 0; // If there is only one block in the selection then we know the parent and\n  // siblings.\n\n  if (blocks.length === 1) {\n    parent = document.getParent(firstblock.key);\n    siblings = blocks;\n  } else {\n    // Determine closest shared parent to all blocks in selection.\n    parent = document.getClosest(firstblock.key, function (p1) {\n      return !!document.getClosest(lastblock.key, function (p2) {\n        return p1 === p2;\n      });\n    });\n  } // If no shared parent could be found then the parent is the document.\n\n\n  if (parent == null) parent = document; // Create a list of direct children siblings of parent that fall in the\n  // selection.\n\n  if (siblings == null) {\n    var indexes = parent.nodes.reduce(function (ind, node, i) {\n      if (node === firstblock || node.hasDescendant(firstblock.key)) ind[0] = i;\n      if (node === lastblock || node.hasDescendant(lastblock.key)) ind[1] = i;\n      return ind;\n    }, []);\n    index = indexes[0];\n    siblings = parent.nodes.slice(indexes[0], indexes[1] + 1);\n  } // Get the index to place the new wrapped node at.\n\n\n  if (index == null) {\n    index = parent.nodes.indexOf(siblings.first());\n  }\n\n  editor.withoutNormalizing(function () {\n    // Inject the new block node into the parent.\n    editor.insertNodeByKey(parent.key, index, block); // Move the sibling nodes into the new block node.\n\n    siblings.forEach(function (node, i) {\n      editor.moveNodeByKey(node.key, block.key, i);\n    });\n  });\n};\n/**\n * Wrap the text and inlines in a `range` in a new `inline`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Inline|Object|String} inline\n */\n\n\nCommands$1.wrapInlineAtRange = function (editor, range, inline) {\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start,\n      end = range.end;\n\n  if (range.isCollapsed) {\n    // Wrapping an inline void\n    var inlineParent = document.getClosestInline(start.path);\n\n    if (!inlineParent) {\n      return;\n    }\n\n    if (!editor.isVoid(inlineParent)) {\n      return;\n    }\n\n    return editor.wrapInlineByKey(inlineParent.key, inline);\n  }\n\n  inline = Inline.create(inline);\n  inline = inline.set('nodes', inline.nodes.clear());\n  var blocks = document.getLeafBlocksAtRange(range);\n  var startBlock = document.getClosestBlock(start.path);\n  var endBlock = document.getClosestBlock(end.path);\n  var startInline = document.getClosestInline(start.path);\n  var endInline = document.getClosestInline(end.path);\n  var startChild = startBlock.getFurthestChild(start.key);\n  var endChild = endBlock.getFurthestChild(end.key);\n  editor.withoutNormalizing(function () {\n    if (!startInline || startInline !== endInline) {\n      editor.splitDescendantsByKey(endChild.key, end.key, end.offset);\n      editor.splitDescendantsByKey(startChild.key, start.key, start.offset);\n    }\n\n    document = editor.value.document;\n    startBlock = document.getDescendant(startBlock.key);\n    endBlock = document.getDescendant(endBlock.key);\n    startChild = startBlock.getFurthestChild(start.key);\n    endChild = endBlock.getFurthestChild(end.key);\n    var startIndex = startBlock.nodes.indexOf(startChild);\n    var endIndex = endBlock.nodes.indexOf(endChild);\n\n    if (startInline && startInline === endInline) {\n      var texts = startBlock.getTextsAtRange(range).map(function (text) {\n        if (start.key === text.key && end.key === text.key) {\n          return text.splitText(start.offset)[1].splitText(end.offset - start.offset)[0].regenerateKey();\n        } else if (start.key === text.key) {\n          return text.splitText(start.offset)[1].regenerateKey();\n        } else if (end.key === text.key) {\n          return text.splitText(end.offset)[0].regenerateKey();\n        } else {\n          return text.regenerateKey();\n        }\n      });\n      inline = inline.set('nodes', texts);\n      editor.insertInlineAtRange(range, inline);\n    } else if (startBlock === endBlock) {\n      document = editor.value.document;\n      startBlock = document.getClosestBlock(start.key);\n      startChild = startBlock.getFurthestChild(start.key);\n      var startInner = document.getNextSibling(startChild.key);\n      var startInnerIndex = startBlock.nodes.indexOf(startInner);\n      var endInner = start.key === end.key ? startInner : startBlock.getFurthestChild(end.key);\n      var inlines = startBlock.nodes.skipUntil(function (n) {\n        return n === startInner;\n      }).takeUntil(function (n) {\n        return n === endInner;\n      }).push(endInner);\n      var node = inline.regenerateKey();\n      editor.insertNodeByKey(startBlock.key, startInnerIndex, node);\n      inlines.forEach(function (child, i) {\n        editor.moveNodeByKey(child.key, node.key, i);\n      });\n    } else {\n      var startInlines = startBlock.nodes.slice(startIndex + 1);\n      var endInlines = endBlock.nodes.slice(0, endIndex + 1);\n      var startNode = inline.regenerateKey();\n      var endNode = inline.regenerateKey();\n      editor.insertNodeByKey(startBlock.key, startIndex + 1, startNode);\n      editor.insertNodeByKey(endBlock.key, endIndex, endNode);\n      startInlines.forEach(function (child, i) {\n        editor.moveNodeByKey(child.key, startNode.key, i);\n      });\n      endInlines.forEach(function (child, i) {\n        editor.moveNodeByKey(child.key, endNode.key, i);\n      });\n      blocks.slice(1, -1).forEach(function (block) {\n        var node = inline.regenerateKey();\n        editor.insertNodeByKey(block.key, 0, node);\n        block.nodes.forEach(function (child, i) {\n          editor.moveNodeByKey(child.key, node.key, i);\n        });\n      });\n    }\n  });\n};\n/**\n * Wrap the text in a `range` in a prefix/suffix.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String} prefix\n * @param {String} suffix (optional)\n */\n\n\nCommands$1.wrapTextAtRange = function (editor, range, prefix) {\n  var suffix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : prefix;\n  var start = range.start,\n      end = range.end;\n  var startRange = range.moveToStart();\n  var endRange = range.moveToEnd();\n\n  if (start.path.equals(end.path)) {\n    endRange = endRange.moveForward(prefix.length);\n  }\n\n  editor.withoutNormalizing(function () {\n    editor.insertTextAtRange(startRange, prefix);\n    editor.insertTextAtRange(endRange, suffix);\n  });\n};\n/**\n * Commands.\n *\n * @type {Object}\n */\n\n\nvar Commands$2 = {};\n/**\n * Add mark to text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mixed} mark\n */\n\nCommands$2.addMarkByPath = function (editor, path, offset, length, mark) {\n  mark = Mark.create(mark);\n  editor.addMarksByPath(path, offset, length, [mark]);\n};\n\nCommands$2.addMarksByPath = function (editor, path, offset, length, marks) {\n  marks = Mark.createSet(marks);\n\n  if (!marks.size) {\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var node = document.assertNode(path);\n  editor.withoutNormalizing(function () {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length);\n    } // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n\n\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset);\n      path = PathUtils.increment(path);\n      offset = 0;\n    }\n\n    marks.forEach(function (mark) {\n      editor.applyOperation({\n        type: 'add_mark',\n        path: path,\n        mark: Mark.create(mark)\n      });\n    });\n  });\n};\n/**\n * Insert a `fragment` at `index` in a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} index\n * @param {Fragment} fragment\n */\n\n\nCommands$2.insertFragmentByPath = function (editor, path, index, fragment) {\n  fragment.nodes.forEach(function (node, i) {\n    editor.insertNodeByPath(path, index + i, node);\n  });\n};\n/**\n * Insert a `node` at `index` in a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} index\n * @param {Node} node\n */\n\n\nCommands$2.insertNodeByPath = function (editor, path, index, node) {\n  editor.applyOperation({\n    type: 'insert_node',\n    path: path.concat(index),\n    node: node\n  });\n};\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\n\nCommands$2.insertTextByPath = function (editor, path, offset, text, marks) {\n  marks = Mark.createSet(marks);\n  var value = editor.value;\n  var annotations = value.annotations,\n      document = value.document;\n  document.assertNode(path);\n  editor.withoutNormalizing(function () {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = annotations.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var annotation = _step.value;\n        var start = annotation.start,\n            end = annotation.end;\n        var isAtomic = editor.isAtomic(annotation);\n\n        if (!isAtomic) {\n          continue;\n        }\n\n        if (!start.path.equals(path)) {\n          continue;\n        }\n\n        if (start.offset < offset && (!end.path.equals(path) || end.offset > offset)) {\n          editor.removeAnnotation(annotation);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    editor.applyOperation({\n      type: 'insert_text',\n      path: path,\n      offset: offset,\n      text: text\n    });\n\n    if (marks.size) {\n      editor.addMarksByPath(path, offset, text.length, marks);\n    }\n  });\n};\n/**\n * Merge a node by `path` with the previous node.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\n\nCommands$2.mergeNodeByPath = function (editor, path) {\n  var value = editor.value;\n  var document = value.document;\n  var original = document.getDescendant(path);\n  var previous = document.getPreviousSibling(path);\n\n  if (!previous) {\n    throw new Error('Unable to merge node with path \"' + path + '\", because it has no previous sibling.');\n  }\n\n  var position = previous.object === 'text' ? previous.text.length : previous.nodes.size;\n  editor.applyOperation({\n    type: 'merge_node',\n    path: path,\n    position: position,\n    // for undos to succeed we only need the type and data because\n    // these are the only properties that get changed in the merge operation\n    properties: {\n      type: original.type,\n      data: original.data\n    },\n    target: null\n  });\n};\n/**\n * Move a node by `path` to a new parent by `newParentPath` and `newIndex`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {String} newParentPath\n * @param {Number} newIndex\n */\n\n\nCommands$2.moveNodeByPath = function (editor, path, newParentPath, newIndex) {\n  // If the operation path and newParentPath are the same,\n  // this should be considered a NOOP\n  if (PathUtils.isEqual(path, newParentPath)) {\n    return editor;\n  }\n\n  var newPath = newParentPath.concat(newIndex);\n\n  if (PathUtils.isEqual(path, newPath)) {\n    return editor;\n  }\n\n  editor.applyOperation({\n    type: 'move_node',\n    path: path,\n    newPath: newPath\n  });\n};\n/**\n * Remove mark from text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n */\n\n\nCommands$2.removeMarkByPath = function (editor, path, offset, length, mark) {\n  mark = Mark.create(mark);\n  editor.removeMarksByPath(path, offset, length, [mark]);\n};\n\nCommands$2.removeMarksByPath = function (editor, path, offset, length, marks) {\n  marks = Mark.createSet(marks);\n\n  if (!marks.size) {\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var node = document.assertNode(path);\n  editor.withoutNormalizing(function () {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length);\n    } // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n\n\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset);\n      path = PathUtils.increment(path);\n      offset = 0;\n    }\n\n    marks.forEach(function (mark) {\n      editor.applyOperation({\n        type: 'remove_mark',\n        path: path,\n        offset: offset,\n        length: length,\n        mark: mark\n      });\n    });\n  });\n};\n/**\n * Remove all `marks` from node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\n\nCommands$2.removeAllMarksByPath = function (editor, path) {\n  var state = editor.state;\n  var document = state.document;\n  var node = document.assertNode(path);\n  editor.withoutNormalizing(function () {\n    if (node.object === 'text') {\n      editor.removeMarksByPath(path, 0, node.text.length, node.marks);\n      return;\n    }\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = node.texts()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _ref = _step2.value;\n\n        var _ref2 = slicedToArray(_ref, 2);\n\n        var n = _ref2[0];\n        var p = _ref2[1];\n        var pth = path.concat(p);\n        editor.removeMarksByPath(pth, 0, n.text.length, n.marks);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  });\n};\n/**\n * Remove a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\n\nCommands$2.removeNodeByPath = function (editor, path) {\n  var value = editor.value;\n  var document = value.document;\n  var node = document.assertNode(path);\n  editor.applyOperation({\n    type: 'remove_node',\n    path: path,\n    node: node\n  });\n};\n/**\n * Remove text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n */\n\n\nCommands$2.removeTextByPath = function (editor, path, offset, length) {\n  var value = editor.value;\n  var document = value.document,\n      annotations = value.annotations;\n  var node = document.assertNode(path);\n  var text = node.text.slice(offset, offset + length);\n  editor.withoutNormalizing(function () {\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = annotations.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var annotation = _step3.value;\n        var start = annotation.start,\n            end = annotation.end;\n        var isAtomic = editor.isAtomic(annotation);\n\n        if (!isAtomic) {\n          continue;\n        }\n\n        if (!start.path.equals(path)) {\n          continue;\n        }\n\n        if (start.offset < offset && (!end.path.equals(path) || end.offset > offset)) {\n          editor.removeAnnotation(annotation);\n        }\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    editor.applyOperation({\n      type: 'remove_text',\n      path: path,\n      offset: offset,\n      text: text\n    });\n  });\n};\n/**\n`* Replace a `node` with another `node`\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|Node} node\n */\n\n\nCommands$2.replaceNodeByPath = function (editor, path, newNode) {\n  newNode = Node.create(newNode);\n  var index = path.last();\n  var parentPath = PathUtils.lift(path);\n  editor.withoutNormalizing(function () {\n    editor.removeNodeByPath(path);\n    editor.insertNodeByPath(parentPath, index, newNode);\n  });\n};\n/**\n * Replace a `length` of text at `offset` with new `text` and optional `marks`.\n *\n * @param {Editor} editor\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {string} text\n * @param {Set<Mark>} marks (optional)\n */\n\n\nCommands$2.replaceTextByPath = function (editor, path, offset, length, text, marks) {\n  editor.withoutNormalizing(function () {\n    editor.removeTextByPath(path, offset, length);\n    editor.insertTextByPath(path, offset, text, marks);\n  });\n};\n/**\n * Set `newProperties` on mark on text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Object|Mark} properties\n * @param {Object} newProperties\n */\n\n\nCommands$2.setMarkByPath = function (editor, path, offset, length, properties, newProperties) {\n  properties = Mark.create(properties);\n  newProperties = Mark.createProperties(newProperties);\n  var value = editor.value;\n  var document = value.document;\n  var node = document.assertNode(path);\n  editor.withoutNormalizing(function () {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length);\n    } // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n\n\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset);\n      path = PathUtils.increment(path);\n      offset = 0;\n    }\n\n    editor.applyOperation({\n      type: 'set_mark',\n      path: path,\n      properties: properties,\n      newProperties: newProperties\n    });\n  });\n};\n/**\n * Set `properties` on a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|String} newProperties\n */\n\n\nCommands$2.setNodeByPath = function (editor, path, newProperties) {\n  var value = editor.value;\n  var document = value.document;\n  var node = document.assertNode(path);\n  newProperties = Node.createProperties(newProperties);\n  var prevProperties = pick(node, Object.keys(newProperties));\n  editor.applyOperation({\n    type: 'set_node',\n    path: path,\n    properties: prevProperties,\n    newProperties: newProperties\n  });\n};\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\n\nCommands$2.setTextByPath = function (editor, path, text, marks) {\n  var value = editor.value;\n  var document = value.document;\n  var node = document.assertNode(path);\n  var end = node.text.length;\n  editor.replaceTextByPath(path, 0, end, text, marks);\n};\n/**\n * Split a node by `path` at `position`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} position\n * @param {Object} options\n */\n\n\nCommands$2.splitNodeByPath = function (editor, path, position) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$target = options.target,\n      target = _options$target === undefined ? null : _options$target;\n  var value = editor.value;\n  var document = value.document;\n  var node = document.getDescendant(path);\n  editor.applyOperation({\n    type: 'split_node',\n    path: path,\n    position: position,\n    target: target,\n    properties: {\n      type: node.type,\n      data: node.data\n    }\n  });\n};\n/**\n * Split a node deeply down the tree by `path`, `textPath` and `textOffset`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Array} textPath\n * @param {Number} textOffset\n */\n\n\nCommands$2.splitDescendantsByPath = function (editor, path, textPath, textOffset) {\n  if (path.equals(textPath)) {\n    editor.splitNodeByPath(textPath, textOffset);\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var index = textOffset;\n  var lastPath = textPath;\n  editor.withoutNormalizing(function () {\n    editor.splitNodeByKey(textPath, textOffset);\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = document.ancestors(textPath)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var _ref3 = _step4.value;\n\n        var _ref4 = slicedToArray(_ref3, 2);\n\n        var ancestorPath = _ref4[1];\n        var target = index;\n        index = lastPath.last() + 1;\n        lastPath = ancestorPath;\n        editor.splitNodeByPath(ancestorPath, index, {\n          target: target\n        });\n\n        if (ancestorPath.equals(path)) {\n          break;\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n  });\n};\n/**\n * Unwrap content from an inline parent with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|String} properties\n */\n\n\nCommands$2.unwrapInlineByPath = function (editor, path, properties) {\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var node = document.assertNode(path);\n  var first = node.getFirstText();\n  var last = node.getLastText();\n  var range = selection.moveToRangeOfNode(first, last);\n  editor.unwrapInlineAtRange(range, properties);\n};\n/**\n * Unwrap content from a block parent with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|String} properties\n */\n\n\nCommands$2.unwrapBlockByPath = function (editor, path, properties) {\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var node = document.assertNode(path);\n  var first = node.getFirstText();\n  var last = node.getLastText();\n  var range = selection.moveToRangeOfNode(first, last);\n  editor.unwrapBlockAtRange(range, properties);\n};\n/**\n * Unwrap a single node from its parent.\n *\n * If the node is surrounded with siblings, its parent will be\n * split. If the node is the only child, the parent is removed, and\n * simply replaced by the node itself.  Cannot unwrap a root node.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\n\nCommands$2.unwrapNodeByPath = function (editor, path) {\n  var value = editor.value;\n  var document = value.document;\n  document.assertNode(path);\n  var parentPath = PathUtils.lift(path);\n  var parent = document.assertNode(parentPath);\n  var index = path.last();\n  var parentIndex = parentPath.last();\n  var grandPath = PathUtils.lift(parentPath);\n  var isFirst = index === 0;\n  var isLast = index === parent.nodes.size - 1;\n  editor.withoutNormalizing(function () {\n    if (parent.nodes.size === 1) {\n      editor.moveNodeByPath(path, grandPath, parentIndex + 1);\n      editor.removeNodeByPath(parentPath);\n    } else if (isFirst) {\n      editor.moveNodeByPath(path, grandPath, parentIndex);\n    } else if (isLast) {\n      editor.moveNodeByPath(path, grandPath, parentIndex + 1);\n    } else {\n      var updatedPath = PathUtils.increment(path, 1, parentPath.size - 1);\n      updatedPath = updatedPath.set(updatedPath.size - 1, 0);\n      editor.splitNodeByPath(parentPath, index);\n      editor.moveNodeByPath(updatedPath, grandPath, parentIndex + 1);\n    }\n  });\n};\n/**\n * Unwrap all of the children of a node, by removing the node and replacing it\n * with the children in the tree.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\n\nCommands$2.unwrapChildrenByPath = function (editor, path) {\n  path = PathUtils.create(path);\n  var value = editor.value;\n  var document = value.document;\n  var node = document.assertNode(path);\n  var parentPath = PathUtils.lift(path);\n  var index = path.last();\n  var nodes = node.nodes;\n  editor.withoutNormalizing(function () {\n    nodes.reverse().forEach(function (child, i) {\n      var childIndex = nodes.size - i - 1;\n      var childPath = path.push(childIndex);\n      editor.moveNodeByPath(childPath, parentPath, index + 1);\n    });\n    editor.removeNodeByPath(path);\n  });\n};\n/**\n * Wrap a node in a block with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Block|Object|String} block\n */\n\n\nCommands$2.wrapBlockByPath = function (editor, path, block) {\n  block = Block.create(block);\n  block = block.set('nodes', block.nodes.clear());\n  var parentPath = PathUtils.lift(path);\n  var index = path.last();\n  var newPath = PathUtils.increment(path);\n  editor.withoutNormalizing(function () {\n    editor.insertNodeByPath(parentPath, index, block);\n    editor.moveNodeByPath(newPath, path, 0);\n  });\n};\n/**\n * Wrap a node in an inline with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Block|Object|String} inline\n */\n\n\nCommands$2.wrapInlineByPath = function (editor, path, inline) {\n  inline = Inline.create(inline);\n  inline = inline.set('nodes', inline.nodes.clear());\n  var parentPath = PathUtils.lift(path);\n  var index = path.last();\n  var newPath = PathUtils.increment(path);\n  editor.withoutNormalizing(function () {\n    editor.insertNodeByPath(parentPath, index, inline);\n    editor.moveNodeByPath(newPath, path, 0);\n  });\n};\n/**\n * Wrap a node by `path` with `node`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Node|Object} node\n */\n\n\nCommands$2.wrapNodeByPath = function (editor, path, node) {\n  node = Node.create(node);\n\n  if (node.object === 'block') {\n    editor.wrapBlockByPath(path, node);\n  } else if (node.object === 'inline') {\n    editor.wrapInlineByPath(path, node);\n  }\n};\n/**\n * Mix in `*ByKey` variants.\n */\n\n\nvar COMMANDS = ['addMark', 'insertFragment', 'insertNode', 'insertText', 'mergeNode', 'removeAllMarks', 'removeMark', 'removeNode', 'removeText', 'replaceNode', 'replaceText', 'setMark', 'setNode', 'setText', 'splitNode', 'unwrapBlock', 'unwrapChildren', 'unwrapInline', 'unwrapNode', 'wrapBlock', 'wrapInline', 'wrapNode'];\n\nvar _loop = function _loop(method) {\n  Commands$2[method + 'ByKey'] = function (editor, key) {\n    for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      args[_key3 - 2] = arguments[_key3];\n    }\n\n    var value = editor.value;\n    var document = value.document;\n    var path = document.assertPath(key);\n    editor[method + 'ByPath'].apply(editor, [path].concat(args));\n  };\n};\n\nvar _iteratorNormalCompletion5 = true;\nvar _didIteratorError5 = false;\nvar _iteratorError5 = undefined;\n\ntry {\n  for (var _iterator5 = COMMANDS[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n    var method = _step5.value;\n\n    _loop(method);\n  } // Moving nodes takes two keys, so it's slightly different.\n\n} catch (err) {\n  _didIteratorError5 = true;\n  _iteratorError5 = err;\n} finally {\n  try {\n    if (!_iteratorNormalCompletion5 && _iterator5.return) {\n      _iterator5.return();\n    }\n  } finally {\n    if (_didIteratorError5) {\n      throw _iteratorError5;\n    }\n  }\n}\n\nCommands$2.moveNodeByKey = function (editor, key, newKey) {\n  for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    args[_key - 3] = arguments[_key];\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var path = document.assertPath(key);\n  var newPath = document.assertPath(newKey);\n  editor.moveNodeByPath.apply(editor, [path, newPath].concat(args));\n}; // Splitting descendants takes two keys, so it's slightly different.\n\n\nCommands$2.splitDescendantsByKey = function (editor, key, textKey) {\n  for (var _len2 = arguments.length, args = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n    args[_key2 - 3] = arguments[_key2];\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var path = document.assertPath(key);\n  var textPath = document.assertPath(textKey);\n  editor.splitDescendantsByPath.apply(editor, [path, textPath].concat(args));\n};\n/**\n * Commands.\n *\n * @type {Object}\n */\n\n\nvar Commands$3 = {};\n/**\n * Save an `operation` into the history.\n *\n * @param {Editor} editor\n * @param {Object} operation\n */\n\nCommands$3.save = function (editor, operation) {\n  var operations = editor.operations,\n      value = editor.value;\n  var data = value.data;\n  var _editor$tmp = editor.tmp,\n      save = _editor$tmp.save,\n      merge = _editor$tmp.merge;\n  if (save === false) return;\n  var undos = data.get('undos') || List();\n  var lastBatch = undos.last();\n  var lastOperation = lastBatch && lastBatch.last(); // If `merge` is non-commital, and this is not the first operation in a new\n  // editor, then merge, otherwise merge based on the last operation.\n\n  if (merge == null) {\n    if (operations.size !== 0) {\n      merge = true;\n    } else {\n      merge = shouldMerge(operation, lastOperation);\n    }\n  } // If the `merge` flag is true, add the operation to the last batch.\n\n\n  if (merge && lastBatch) {\n    var batch = lastBatch.push(operation);\n    undos = undos.pop();\n    undos = undos.push(batch);\n  } else {\n    // Otherwise, create a new batch with the operation.\n    var _batch = List([operation]);\n\n    undos = undos.push(_batch);\n  } // Constrain the history to 100 entries for memory's sake.\n\n\n  if (undos.size > 100) {\n    undos = undos.takeLast(100);\n  } // Clear the redos and update the history.\n\n\n  editor.withoutSaving(function () {\n    var redos = List();\n    var newData = data.set('undos', undos).set('redos', redos);\n    editor.setData(newData);\n  });\n};\n/**\n * Redo to the next value in the history.\n *\n * @param {Editor} editor\n */\n\n\nCommands$3.redo = function (editor) {\n  var value = editor.value;\n  var data = value.data;\n  var redos = data.get('redos') || List();\n  var undos = data.get('undos') || List();\n  var batch = redos.last();\n  if (!batch) return;\n  editor.withoutSaving(function () {\n    editor.withoutNormalizing(function () {\n      // Replay the batch of operations.\n      batch.forEach(function (op) {\n        var _op = op,\n            type = _op.type,\n            properties = _op.properties; // When the operation mutates the selection, omit its `isFocused` value to\n        // prevent the editor focus from changing during redoing.\n\n        if (type === 'set_selection') {\n          op = op.set('properties', omit(properties, 'isFocused'));\n        }\n\n        editor.applyOperation(op);\n      }); // Shift the next value into the undo stack.\n\n      redos = redos.pop();\n      undos = undos.push(batch);\n      var newData = data.set('undos', undos).set('redos', redos);\n      editor.setData(newData);\n    });\n  });\n};\n/**\n * Undo the previous operations in the history.\n *\n * @param {Editor} editor\n */\n\n\nCommands$3.undo = function (editor) {\n  var value = editor.value;\n  var data = value.data;\n  var redos = data.get('redos') || List();\n  var undos = data.get('undos') || List();\n  var batch = undos.last();\n  if (!batch) return;\n  editor.withoutSaving(function () {\n    editor.withoutNormalizing(function () {\n      // Replay the inverse of the previous operations.\n      batch.slice().reverse().map(function (op) {\n        return op.invert();\n      }).forEach(function (inverse) {\n        var _inverse = inverse,\n            type = _inverse.type,\n            properties = _inverse.properties; // When the operation mutates the selection, omit its `isFocused` value to\n        // prevent the editor focus from changing during undoing.\n\n        if (type === 'set_selection') {\n          inverse = inverse.set('properties', omit(properties, 'isFocused'));\n        }\n\n        editor.applyOperation(inverse);\n      }); // Shift the previous operations into the redo stack.\n\n      redos = redos.push(batch);\n      undos = undos.pop();\n      var newData = data.set('undos', undos).set('redos', redos);\n      editor.setData(newData);\n    });\n  });\n};\n/**\n * Apply a series of changes inside a synchronous `fn`, without merging any of\n * the new operations into previous save point in the history.\n *\n * @param {Editor} editor\n * @param {Function} fn\n */\n\n\nCommands$3.withoutMerging = function (editor, fn) {\n  var value = editor.tmp.merge;\n  editor.tmp.merge = false;\n  fn(editor);\n  editor.tmp.merge = value;\n};\n/**\n * Apply a series of changes inside a synchronous `fn`, without saving any of\n * their operations into the history.\n *\n * @param {Editor} editor\n * @param {Function} fn\n */\n\n\nCommands$3.withoutSaving = function (editor, fn) {\n  var value = editor.tmp.save;\n  editor.tmp.save = false;\n  fn(editor);\n  editor.tmp.save = value;\n};\n/**\n * Check whether to merge a new operation `o` into the previous operation `p`.\n *\n * @param {Object} o\n * @param {Object} p\n * @return {Boolean}\n */\n\n\nfunction shouldMerge(o, p) {\n  if (!p) return false;\n  var merge = o.type === 'set_selection' && p.type === 'set_selection' || o.type === 'insert_text' && p.type === 'insert_text' && o.offset === p.offset + p.text.length && o.path.equals(p.path) || o.type === 'remove_text' && p.type === 'remove_text' && o.offset + o.text.length === p.offset && o.path.equals(p.path);\n  return merge;\n}\n\nvar Commands$4 = {};\n\nCommands$4.blur = function (editor) {\n  editor.select({\n    isFocused: false\n  });\n};\n\nCommands$4.deselect = function (editor) {\n  var range = Selection.create();\n  editor.select(range);\n};\n\nCommands$4.focus = function (editor) {\n  editor.select({\n    isFocused: true\n  });\n};\n\nCommands$4.flip = function (editor) {\n  editor.command(proxy, 'flip');\n};\n\nCommands$4.moveAnchorBackward = function (editor) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  editor.command.apply(editor, [pointBackward, 'anchor'].concat(args));\n};\n\nCommands$4.moveAnchorWordBackward = function (editor) {\n  for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  editor.command.apply(editor, [pointWordBackward, 'anchor'].concat(args));\n};\n\nCommands$4.moveAnchorForward = function (editor) {\n  for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n\n  editor.command.apply(editor, [pointForward, 'anchor'].concat(args));\n};\n\nCommands$4.moveAnchorWordForward = function (editor) {\n  for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n\n  editor.command.apply(editor, [pointWordForward, 'anchor'].concat(args));\n};\n\nCommands$4.moveAnchorTo = function (editor) {\n  for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    args[_key5 - 1] = arguments[_key5];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveAnchorTo'].concat(args));\n};\n\nCommands$4.moveAnchorToEndOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'anchor', 'end', 'block');\n};\n\nCommands$4.moveAnchorToEndOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'anchor', 'end', 'inline');\n};\n\nCommands$4.moveAnchorToEndOfDocument = function (editor) {\n  editor.moveAnchorToEndOfNode(editor.value.document).moveToAnchor();\n};\n\nCommands$4.moveAnchorToEndOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'next', 'block');\n};\n\nCommands$4.moveAnchorToEndOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'next', 'inline');\n};\n\nCommands$4.moveAnchorToEndOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'next', 'text');\n};\n\nCommands$4.moveAnchorToEndOfNode = function (editor) {\n  for (var _len6 = arguments.length, args = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n    args[_key6 - 1] = arguments[_key6];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveAnchorToEndOfNode'].concat(args));\n};\n\nCommands$4.moveAnchorToEndOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'previous', 'block');\n};\n\nCommands$4.moveAnchorToEndOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'previous', 'inline');\n};\n\nCommands$4.moveAnchorToEndOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'previous', 'text');\n};\n\nCommands$4.moveAnchorToEndOfText = function (editor) {\n  editor.command(pointEdgeObject, 'anchor', 'end', 'text');\n};\n\nCommands$4.moveAnchorToStartOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'anchor', 'start', 'block');\n};\n\nCommands$4.moveAnchorToStartOfDocument = function (editor) {\n  editor.moveAnchorToStartOfNode(editor.value.document).moveToAnchor();\n};\n\nCommands$4.moveAnchorToStartOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'anchor', 'start', 'inline');\n};\n\nCommands$4.moveAnchorToStartOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'next', 'block');\n};\n\nCommands$4.moveAnchorToStartOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'next', 'inline');\n};\n\nCommands$4.moveAnchorToStartOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'next', 'text');\n};\n\nCommands$4.moveAnchorToStartOfNode = function (editor) {\n  for (var _len7 = arguments.length, args = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n    args[_key7 - 1] = arguments[_key7];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveAnchorToStartOfNode'].concat(args));\n};\n\nCommands$4.moveAnchorToStartOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'previous', 'block');\n};\n\nCommands$4.moveAnchorToStartOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'previous', 'inline');\n};\n\nCommands$4.moveAnchorToStartOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'previous', 'text');\n};\n\nCommands$4.moveAnchorToStartOfText = function (editor) {\n  editor.command(pointEdgeObject, 'anchor', 'start', 'text');\n};\n\nCommands$4.moveBackward = function (editor) {\n  var _editor$moveAnchorBac;\n\n  for (var _len8 = arguments.length, args = Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n    args[_key8 - 1] = arguments[_key8];\n  }\n\n  (_editor$moveAnchorBac = editor.moveAnchorBackward.apply(editor, args)).moveFocusBackward.apply(_editor$moveAnchorBac, args);\n};\n\nCommands$4.moveWordBackward = function (editor) {\n  for (var _len9 = arguments.length, args = Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n    args[_key9 - 1] = arguments[_key9];\n  }\n\n  editor.moveFocusWordBackward.apply(editor, args).moveToFocus();\n};\n\nCommands$4.moveEndBackward = function (editor) {\n  for (var _len10 = arguments.length, args = Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {\n    args[_key10 - 1] = arguments[_key10];\n  }\n\n  editor.command.apply(editor, [pointBackward, 'end'].concat(args));\n};\n\nCommands$4.moveEndWordBackward = function (editor) {\n  for (var _len11 = arguments.length, args = Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n    args[_key11 - 1] = arguments[_key11];\n  }\n\n  editor.command.apply(editor, [pointWordBackward, 'end'].concat(args));\n};\n\nCommands$4.moveEndForward = function (editor) {\n  for (var _len12 = arguments.length, args = Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {\n    args[_key12 - 1] = arguments[_key12];\n  }\n\n  editor.command.apply(editor, [pointForward, 'end'].concat(args));\n};\n\nCommands$4.moveEndWordForward = function (editor) {\n  for (var _len13 = arguments.length, args = Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {\n    args[_key13 - 1] = arguments[_key13];\n  }\n\n  editor.command.apply(editor, [pointWordForward, 'end'].concat(args));\n};\n\nCommands$4.moveEndTo = function (editor) {\n  for (var _len14 = arguments.length, args = Array(_len14 > 1 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) {\n    args[_key14 - 1] = arguments[_key14];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveEndTo'].concat(args));\n};\n\nCommands$4.moveEndToEndOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'end', 'end', 'block');\n};\n\nCommands$4.moveEndToEndOfDocument = function (editor) {\n  editor.moveEndToEndOfNode(editor.value.document).moveToEnd();\n};\n\nCommands$4.moveEndToEndOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'end', 'end', 'inline');\n};\n\nCommands$4.moveEndToEndOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'next', 'block');\n};\n\nCommands$4.moveEndToEndOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'next', 'inline');\n};\n\nCommands$4.moveEndToEndOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'next', 'text');\n};\n\nCommands$4.moveEndToEndOfNode = function (editor) {\n  for (var _len15 = arguments.length, args = Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {\n    args[_key15 - 1] = arguments[_key15];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveEndToEndOfNode'].concat(args));\n};\n\nCommands$4.moveEndToEndOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'previous', 'block');\n};\n\nCommands$4.moveEndToEndOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'previous', 'inline');\n};\n\nCommands$4.moveEndToEndOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'previous', 'text');\n};\n\nCommands$4.moveEndToEndOfText = function (editor) {\n  editor.command(pointEdgeObject, 'end', 'end', 'text');\n};\n\nCommands$4.moveEndToStartOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'end', 'start', 'block');\n};\n\nCommands$4.moveEndToStartOfDocument = function (editor) {\n  editor.moveEndToStartOfNode(editor.value.document).moveToEnd();\n};\n\nCommands$4.moveEndToStartOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'end', 'start', 'inline');\n};\n\nCommands$4.moveEndToStartOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'next', 'block');\n};\n\nCommands$4.moveEndToStartOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'next', 'inline');\n};\n\nCommands$4.moveEndToStartOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'next', 'text');\n};\n\nCommands$4.moveEndToStartOfNode = function (editor) {\n  for (var _len16 = arguments.length, args = Array(_len16 > 1 ? _len16 - 1 : 0), _key16 = 1; _key16 < _len16; _key16++) {\n    args[_key16 - 1] = arguments[_key16];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveEndToStartOfNode'].concat(args));\n};\n\nCommands$4.moveEndToStartOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'previous', 'block');\n};\n\nCommands$4.moveEndToStartOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'previous', 'inline');\n};\n\nCommands$4.moveEndToStartOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'previous', 'text');\n};\n\nCommands$4.moveEndToStartOfText = function (editor) {\n  editor.command(pointEdgeObject, 'end', 'start', 'text');\n};\n\nCommands$4.moveFocusBackward = function (editor) {\n  for (var _len17 = arguments.length, args = Array(_len17 > 1 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) {\n    args[_key17 - 1] = arguments[_key17];\n  }\n\n  editor.command.apply(editor, [pointBackward, 'focus'].concat(args));\n};\n\nCommands$4.moveFocusWordBackward = function (editor) {\n  for (var _len18 = arguments.length, args = Array(_len18 > 1 ? _len18 - 1 : 0), _key18 = 1; _key18 < _len18; _key18++) {\n    args[_key18 - 1] = arguments[_key18];\n  }\n\n  editor.command.apply(editor, [pointWordBackward, 'focus'].concat(args));\n};\n\nCommands$4.moveFocusForward = function (editor) {\n  for (var _len19 = arguments.length, args = Array(_len19 > 1 ? _len19 - 1 : 0), _key19 = 1; _key19 < _len19; _key19++) {\n    args[_key19 - 1] = arguments[_key19];\n  }\n\n  editor.command.apply(editor, [pointForward, 'focus'].concat(args));\n};\n\nCommands$4.moveFocusWordForward = function (editor) {\n  for (var _len20 = arguments.length, args = Array(_len20 > 1 ? _len20 - 1 : 0), _key20 = 1; _key20 < _len20; _key20++) {\n    args[_key20 - 1] = arguments[_key20];\n  }\n\n  editor.command.apply(editor, [pointWordForward, 'focus'].concat(args));\n};\n\nCommands$4.moveFocusTo = function (editor) {\n  for (var _len21 = arguments.length, args = Array(_len21 > 1 ? _len21 - 1 : 0), _key21 = 1; _key21 < _len21; _key21++) {\n    args[_key21 - 1] = arguments[_key21];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveFocusTo'].concat(args));\n};\n\nCommands$4.moveFocusToEndOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'focus', 'end', 'block');\n};\n\nCommands$4.moveFocusToEndOfDocument = function (editor) {\n  editor.moveFocusToEndOfNode(editor.value.document).moveToFocus();\n};\n\nCommands$4.moveFocusToEndOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'focus', 'end', 'inline');\n};\n\nCommands$4.moveFocusToEndOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'next', 'block');\n};\n\nCommands$4.moveFocusToEndOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'next', 'inline');\n};\n\nCommands$4.moveFocusToEndOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'next', 'text');\n};\n\nCommands$4.moveFocusToEndOfNode = function (editor) {\n  for (var _len22 = arguments.length, args = Array(_len22 > 1 ? _len22 - 1 : 0), _key22 = 1; _key22 < _len22; _key22++) {\n    args[_key22 - 1] = arguments[_key22];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveFocusToEndOfNode'].concat(args));\n};\n\nCommands$4.moveFocusToEndOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'previous', 'block');\n};\n\nCommands$4.moveFocusToEndOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'previous', 'inline');\n};\n\nCommands$4.moveFocusToEndOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'previous', 'text');\n};\n\nCommands$4.moveFocusToEndOfText = function (editor) {\n  editor.command(pointEdgeObject, 'focus', 'end', 'text');\n};\n\nCommands$4.moveFocusToStartOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'focus', 'start', 'block');\n};\n\nCommands$4.moveFocusToStartOfDocument = function (editor) {\n  editor.moveFocusToStartOfNode(editor.value.document).moveToFocus();\n};\n\nCommands$4.moveFocusToStartOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'focus', 'start', 'inline');\n};\n\nCommands$4.moveFocusToStartOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'next', 'block');\n};\n\nCommands$4.moveFocusToStartOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'next', 'inline');\n};\n\nCommands$4.moveFocusToStartOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'next', 'text');\n};\n\nCommands$4.moveFocusToStartOfNode = function (editor) {\n  for (var _len23 = arguments.length, args = Array(_len23 > 1 ? _len23 - 1 : 0), _key23 = 1; _key23 < _len23; _key23++) {\n    args[_key23 - 1] = arguments[_key23];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveFocusToStartOfNode'].concat(args));\n};\n\nCommands$4.moveFocusToStartOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'previous', 'block');\n};\n\nCommands$4.moveFocusToStartOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'previous', 'inline');\n};\n\nCommands$4.moveFocusToStartOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'previous', 'text');\n};\n\nCommands$4.moveFocusToStartOfText = function (editor) {\n  editor.command(pointEdgeObject, 'focus', 'start', 'text');\n};\n\nCommands$4.moveForward = function (editor) {\n  var _editor$moveAnchorFor;\n\n  for (var _len24 = arguments.length, args = Array(_len24 > 1 ? _len24 - 1 : 0), _key24 = 1; _key24 < _len24; _key24++) {\n    args[_key24 - 1] = arguments[_key24];\n  }\n\n  (_editor$moveAnchorFor = editor.moveAnchorForward.apply(editor, args)).moveFocusForward.apply(_editor$moveAnchorFor, args);\n};\n\nCommands$4.moveWordForward = function (editor) {\n  var _editor$moveFocusWord;\n\n  for (var _len25 = arguments.length, args = Array(_len25 > 1 ? _len25 - 1 : 0), _key25 = 1; _key25 < _len25; _key25++) {\n    args[_key25 - 1] = arguments[_key25];\n  }\n\n  (_editor$moveFocusWord = editor.moveFocusWordForward.apply(editor, args)).moveToFocus.apply(_editor$moveFocusWord, args);\n};\n\nCommands$4.moveStartBackward = function (editor) {\n  for (var _len26 = arguments.length, args = Array(_len26 > 1 ? _len26 - 1 : 0), _key26 = 1; _key26 < _len26; _key26++) {\n    args[_key26 - 1] = arguments[_key26];\n  }\n\n  editor.command.apply(editor, [pointBackward, 'start'].concat(args));\n};\n\nCommands$4.moveStartWordBackward = function (editor) {\n  for (var _len27 = arguments.length, args = Array(_len27 > 1 ? _len27 - 1 : 0), _key27 = 1; _key27 < _len27; _key27++) {\n    args[_key27 - 1] = arguments[_key27];\n  }\n\n  editor.command.apply(editor, [pointWordBackward, 'start'].concat(args));\n};\n\nCommands$4.moveStartForward = function (editor) {\n  for (var _len28 = arguments.length, args = Array(_len28 > 1 ? _len28 - 1 : 0), _key28 = 1; _key28 < _len28; _key28++) {\n    args[_key28 - 1] = arguments[_key28];\n  }\n\n  editor.command.apply(editor, [pointForward, 'start'].concat(args));\n};\n\nCommands$4.moveStartWordForward = function (editor) {\n  for (var _len29 = arguments.length, args = Array(_len29 > 1 ? _len29 - 1 : 0), _key29 = 1; _key29 < _len29; _key29++) {\n    args[_key29 - 1] = arguments[_key29];\n  }\n\n  editor.command.apply(editor, [pointWordForward, 'start'].concat(args));\n};\n\nCommands$4.moveStartTo = function (editor) {\n  for (var _len30 = arguments.length, args = Array(_len30 > 1 ? _len30 - 1 : 0), _key30 = 1; _key30 < _len30; _key30++) {\n    args[_key30 - 1] = arguments[_key30];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveStartTo'].concat(args));\n};\n\nCommands$4.moveStartToEndOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'start', 'end', 'block');\n};\n\nCommands$4.moveStartToEndOfDocument = function (editor) {\n  editor.moveStartToEndOfNode(editor.value.document).moveToStart();\n};\n\nCommands$4.moveStartToEndOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'start', 'end', 'inline');\n};\n\nCommands$4.moveStartToEndOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'next', 'block');\n};\n\nCommands$4.moveStartToEndOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'next', 'inline');\n};\n\nCommands$4.moveStartToEndOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'next', 'text');\n};\n\nCommands$4.moveStartToEndOfNode = function (editor) {\n  for (var _len31 = arguments.length, args = Array(_len31 > 1 ? _len31 - 1 : 0), _key31 = 1; _key31 < _len31; _key31++) {\n    args[_key31 - 1] = arguments[_key31];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveStartToEndOfNode'].concat(args));\n};\n\nCommands$4.moveStartToEndOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'previous', 'block');\n};\n\nCommands$4.moveStartToEndOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'previous', 'inline');\n};\n\nCommands$4.moveStartToEndOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'previous', 'text');\n};\n\nCommands$4.moveStartToEndOfText = function (editor) {\n  editor.command(pointEdgeObject, 'start', 'end', 'text');\n};\n\nCommands$4.moveStartToStartOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'start', 'start', 'block');\n};\n\nCommands$4.moveStartToStartOfDocument = function (editor) {\n  editor.moveStartToStartOfNode(editor.value.document).moveToStart();\n};\n\nCommands$4.moveStartToStartOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'start', 'start', 'inline');\n};\n\nCommands$4.moveStartToStartOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'next', 'block');\n};\n\nCommands$4.moveStartToStartOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'next', 'inline');\n};\n\nCommands$4.moveStartToStartOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'next', 'text');\n};\n\nCommands$4.moveStartToStartOfNode = function (editor) {\n  for (var _len32 = arguments.length, args = Array(_len32 > 1 ? _len32 - 1 : 0), _key32 = 1; _key32 < _len32; _key32++) {\n    args[_key32 - 1] = arguments[_key32];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveStartToStartOfNode'].concat(args));\n};\n\nCommands$4.moveStartToStartOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'previous', 'block');\n};\n\nCommands$4.moveStartToStartOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'previous', 'inline');\n};\n\nCommands$4.moveStartToStartOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'previous', 'text');\n};\n\nCommands$4.moveStartToStartOfText = function (editor) {\n  editor.command(pointEdgeObject, 'start', 'start', 'text');\n};\n\nCommands$4.moveTo = function (editor) {\n  for (var _len33 = arguments.length, args = Array(_len33 > 1 ? _len33 - 1 : 0), _key33 = 1; _key33 < _len33; _key33++) {\n    args[_key33 - 1] = arguments[_key33];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveTo'].concat(args));\n};\n\nCommands$4.moveToAnchor = function (editor) {\n  editor.command(proxy, 'moveToAnchor');\n};\n\nCommands$4.moveToEnd = function (editor) {\n  editor.command(proxy, 'moveToEnd');\n};\n\nCommands$4.moveToEndOfBlock = function (editor) {\n  editor.moveEndToEndOfBlock().moveToEnd();\n};\n\nCommands$4.moveToEndOfDocument = function (editor) {\n  editor.moveEndToEndOfNode(editor.value.document).moveToEnd();\n};\n\nCommands$4.moveToEndOfInline = function (editor) {\n  editor.moveEndToEndOfInline().moveToEnd();\n};\n\nCommands$4.moveToEndOfNextBlock = function (editor) {\n  editor.moveEndToEndOfNextBlock().moveToEnd();\n};\n\nCommands$4.moveToEndOfNextInline = function (editor) {\n  editor.moveEndToEndOfNextInline().moveToEnd();\n};\n\nCommands$4.moveToEndOfNextText = function (editor) {\n  editor.moveEndToEndOfNextText().moveToEnd();\n};\n\nCommands$4.moveToEndOfNode = function (editor) {\n  for (var _len34 = arguments.length, args = Array(_len34 > 1 ? _len34 - 1 : 0), _key34 = 1; _key34 < _len34; _key34++) {\n    args[_key34 - 1] = arguments[_key34];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveToEndOfNode'].concat(args));\n};\n\nCommands$4.moveToEndOfPreviousBlock = function (editor) {\n  editor.moveStartToEndOfPreviousBlock().moveToStart();\n};\n\nCommands$4.moveToEndOfPreviousInline = function (editor) {\n  editor.moveStartToEndOfPreviousInline().moveToStart();\n};\n\nCommands$4.moveToEndOfPreviousText = function (editor) {\n  editor.moveStartToEndOfPreviousText().moveToStart();\n};\n\nCommands$4.moveToEndOfText = function (editor) {\n  editor.moveEndToEndOfText().moveToEnd();\n};\n\nCommands$4.moveToFocus = function (editor) {\n  editor.command(proxy, 'moveToFocus');\n};\n\nCommands$4.moveToRangeOfDocument = function (editor) {\n  editor.moveToRangeOfNode(editor.value.document);\n};\n\nCommands$4.moveToRangeOfNode = function (editor) {\n  for (var _len35 = arguments.length, args = Array(_len35 > 1 ? _len35 - 1 : 0), _key35 = 1; _key35 < _len35; _key35++) {\n    args[_key35 - 1] = arguments[_key35];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveToRangeOfNode'].concat(args));\n};\n\nCommands$4.moveToStart = function (editor) {\n  editor.command(proxy, 'moveToStart');\n};\n\nCommands$4.moveToStartOfBlock = function (editor) {\n  editor.moveStartToStartOfBlock().moveToStart();\n};\n\nCommands$4.moveToStartOfDocument = function (editor) {\n  editor.moveStartToStartOfNode(editor.value.document).moveToStart();\n};\n\nCommands$4.moveToStartOfInline = function (editor) {\n  editor.moveStartToStartOfInline().moveToStart();\n};\n\nCommands$4.moveToStartOfNextBlock = function (editor) {\n  editor.moveEndToStartOfNextBlock().moveToEnd();\n};\n\nCommands$4.moveToStartOfNextInline = function (editor) {\n  editor.moveEndToStartOfNextInline().moveToEnd();\n};\n\nCommands$4.moveToStartOfNextText = function (editor) {\n  editor.moveEndToStartOfNextText().moveToEnd();\n};\n\nCommands$4.moveToStartOfNode = function (editor) {\n  for (var _len36 = arguments.length, args = Array(_len36 > 1 ? _len36 - 1 : 0), _key36 = 1; _key36 < _len36; _key36++) {\n    args[_key36 - 1] = arguments[_key36];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveToStartOfNode'].concat(args));\n};\n\nCommands$4.moveToStartOfPreviousBlock = function (editor) {\n  editor.moveStartToStartOfPreviousBlock().moveToStart();\n};\n\nCommands$4.moveToStartOfPreviousInline = function (editor) {\n  editor.moveStartToStartOfPreviousInline().moveToStart();\n};\n\nCommands$4.moveToStartOfPreviousText = function (editor) {\n  editor.moveStartToStartOfPreviousText().moveToStart();\n};\n\nCommands$4.moveToStartOfText = function (editor) {\n  editor.moveStartToStartOfText().moveToStart();\n};\n\nCommands$4.select = function (editor, properties) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  properties = Selection.createProperties(properties);\n  var _options$snapshot = options.snapshot,\n      snapshot = _options$snapshot === undefined ? false : _options$snapshot;\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var newProperties = {};\n  var next = selection.setProperties(properties);\n  next = document.resolveSelection(next); // Re-compute the properties, to ensure that we get their normalized values.\n\n  properties = pick(next, Object.keys(properties)); // Remove any properties that are already equal to the current selection. And\n  // create a dictionary of the previous values for all of the properties that\n  // are being changed, for the inverse operation.\n\n  for (var k in properties) {\n    if (snapshot === true || !is(properties[k], selection[k])) {\n      newProperties[k] = properties[k];\n    }\n  } // If the selection moves, clear any marks, unless the new selection\n  // properties change the marks in some way.\n\n\n  if (selection.marks && !newProperties.marks && (newProperties.anchor || newProperties.focus)) {\n    newProperties.marks = null;\n  } // If there are no new properties to set, abort to avoid extra operations.\n\n\n  if (Object.keys(newProperties).length === 0) {\n    return;\n  } // TODO: for some reason toJSON() is required here (it breaks selections between blocks)? - 2018-10-10\n\n\n  var prevProperties = pick(selection.toJSON(), Object.keys(newProperties));\n  editor.applyOperation({\n    type: 'set_selection',\n    value: value,\n    properties: prevProperties,\n    newProperties: newProperties\n  }, snapshot ? {\n    skip: false,\n    merge: false\n  } : {});\n};\n\nCommands$4.setAnchor = function (editor) {\n  for (var _len37 = arguments.length, args = Array(_len37 > 1 ? _len37 - 1 : 0), _key37 = 1; _key37 < _len37; _key37++) {\n    args[_key37 - 1] = arguments[_key37];\n  }\n\n  editor.command.apply(editor, [proxy, 'setAnchor'].concat(args));\n};\n\nCommands$4.setEnd = function (editor) {\n  for (var _len38 = arguments.length, args = Array(_len38 > 1 ? _len38 - 1 : 0), _key38 = 1; _key38 < _len38; _key38++) {\n    args[_key38 - 1] = arguments[_key38];\n  }\n\n  editor.command.apply(editor, [proxy, 'setEnd'].concat(args));\n};\n\nCommands$4.setFocus = function (editor) {\n  for (var _len39 = arguments.length, args = Array(_len39 > 1 ? _len39 - 1 : 0), _key39 = 1; _key39 < _len39; _key39++) {\n    args[_key39 - 1] = arguments[_key39];\n  }\n\n  editor.command.apply(editor, [proxy, 'setFocus'].concat(args));\n};\n\nCommands$4.setStart = function (editor) {\n  for (var _len40 = arguments.length, args = Array(_len40 > 1 ? _len40 - 1 : 0), _key40 = 1; _key40 < _len40; _key40++) {\n    args[_key40 - 1] = arguments[_key40];\n  }\n\n  editor.command.apply(editor, [proxy, 'setStart'].concat(args));\n};\n\nCommands$4.snapshotSelection = function (editor) {\n  editor.withoutMerging(function () {\n    editor.select(editor.value.selection, {\n      snapshot: true\n    });\n  });\n};\n/**\n * Helpers.\n */\n\n\nfunction proxy(editor, method) {\n  var _editor$value$selecti;\n\n  for (var _len41 = arguments.length, args = Array(_len41 > 2 ? _len41 - 2 : 0), _key41 = 2; _key41 < _len41; _key41++) {\n    args[_key41 - 2] = arguments[_key41];\n  }\n\n  var range = (_editor$value$selecti = editor.value.selection)[method].apply(_editor$value$selecti, args);\n\n  editor.select(range);\n}\n\nfunction pointEdgeObject(editor, point, edge, object) {\n  var Point = point.slice(0, 1).toUpperCase() + point.slice(1);\n  var Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1);\n  var Object = object.slice(0, 1).toUpperCase() + object.slice(1);\n  var method = 'move' + Point + 'To' + Edge + 'OfNode';\n  var getNode = object === 'text' ? 'getNode' : 'getClosest' + Object;\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var p = selection[point];\n  var node = document[getNode](p.key);\n  if (!node) return;\n  editor[method](node);\n}\n\nfunction pointEdgeSideObject(editor, point, edge, side, object) {\n  var Point = point.slice(0, 1).toUpperCase() + point.slice(1);\n  var Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1);\n  var Side = side.slice(0, 1).toUpperCase() + side.slice(1);\n  var Object = object.slice(0, 1).toUpperCase() + object.slice(1);\n  var method = 'move' + Point + 'To' + Edge + 'OfNode';\n  var getNode = object === 'text' ? 'getNode' : 'getClosest' + Object;\n  var getDirectionNode = 'get' + Side + Object;\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var p = selection[point];\n  var node = document[getNode](p.key);\n  if (!node) return;\n  var target = document[getDirectionNode](node.key);\n  if (!target) return;\n  editor[method](target);\n}\n\nfunction pointBackward(editor, point) {\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  if (n === 0) return;\n  if (n < 0) return pointForward(editor, point, -n);\n  var Point = point.slice(0, 1).toUpperCase() + point.slice(1);\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var p = selection[point];\n  var hasVoidParent = document.hasVoidParent(p.path, editor); // what is this?\n\n  if (!hasVoidParent && p.offset - n >= 0) {\n    var range = selection['move' + Point + 'Backward'](n);\n    editor.select(range);\n    return;\n  }\n\n  var previous = document.getPreviousText(p.path);\n  if (!previous) return;\n  var block = document.getClosestBlock(p.path);\n  var isInBlock = block.hasNode(previous.key);\n  var isPreviousInVoid = previous && document.hasVoidParent(previous.key, editor);\n  editor['move' + Point + 'ToEndOfNode'](previous); // when is this called?\n\n  if (!hasVoidParent && !isPreviousInVoid && isInBlock) {\n    var _range = editor.value.selection['move' + Point + 'Backward'](n);\n\n    editor.select(_range);\n  }\n}\n\nfunction pointForward(editor, point) {\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  if (n === 0) return;\n  if (n < 0) return pointBackward(editor, point, -n);\n  var Point = point.slice(0, 1).toUpperCase() + point.slice(1);\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var p = selection[point];\n  var text = document.getNode(p.path);\n  var hasVoidParent = document.hasVoidParent(p.path, editor); // what is this?\n\n  if (!hasVoidParent && p.offset + n <= text.text.length) {\n    var range = selection['move' + Point + 'Forward'](n);\n    editor.select(range);\n    return;\n  }\n\n  var next = document.getNextText(p.path);\n  if (!next) return;\n  var block = document.getClosestBlock(p.path);\n  var isInBlock = block.hasNode(next.key);\n  var isNextInVoid = document.hasVoidParent(next.key, editor);\n  editor['move' + Point + 'ToStartOfNode'](next); // when is this called?\n\n  if (!hasVoidParent && !isNextInVoid && isInBlock) {\n    var _range2 = editor.value.selection['move' + Point + 'Forward'](n);\n\n    editor.select(_range2);\n  }\n}\n\nfunction pointWordBackward(editor, pointName) {\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var point = selection[pointName];\n  var block = document.getClosestBlock(point.key);\n  var offset = block.getOffset(point.key);\n  var o = offset + point.offset;\n  var text = block.text;\n  var n = TextUtils.getWordOffsetBackward(text, o);\n  editor.command(pointBackward, pointName, n > 0 ? n : 1);\n}\n\nfunction pointWordForward(editor, pointName) {\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var point = selection[pointName];\n  var block = document.getClosestBlock(point.key);\n  var offset = block.getOffset(point.key);\n  var o = offset + point.offset;\n  var text = block.text;\n  var n = TextUtils.getWordOffsetForward(text, o);\n  editor.command(pointForward, pointName, n > 0 ? n : 1);\n}\n/**\n * Commands.\n *\n * @type {Object}\n */\n\n\nvar Commands$5 = {};\n/**\n * Set `properties` on the value.\n *\n * @param {Editor} editor\n * @param {Object|Value} properties\n */\n\nCommands$5.setData = function (editor) {\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var value = editor.value;\n  var newProperties = Value.createProperties({\n    data: data\n  });\n  var prevProperties = pick(value, Object.keys(newProperties));\n  editor.applyOperation({\n    type: 'set_value',\n    properties: prevProperties,\n    newProperties: newProperties\n  });\n};\n\nCommands$5.addAnnotation = function (editor, annotation) {\n  annotation = Annotation.create(annotation);\n  editor.applyOperation({\n    type: 'add_annotation',\n    annotation: annotation\n  });\n};\n\nCommands$5.removeAnnotation = function (editor, annotation) {\n  annotation = Annotation.create(annotation);\n  editor.applyOperation({\n    type: 'remove_annotation',\n    annotation: annotation\n  });\n};\n\nCommands$5.setAnnotation = function (editor, annotation, newProperties) {\n  annotation = Annotation.create(annotation);\n  newProperties = Annotation.createProperties(newProperties);\n  editor.applyOperation({\n    type: 'set_annotation',\n    properties: annotation,\n    newProperties: newProperties\n  });\n};\n/**\n * A plugin that adds a set of queries to the editor.\n *\n * @param {Object} queries\n * @return {Object}\n */\n\n\nfunction QueriesPlugin() {\n  var queries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  /**\n   * On construct, register all the queries.\n   *\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onConstruct(editor, next) {\n    for (var query in queries) {\n      editor.registerQuery(query);\n    }\n\n    return next();\n  }\n  /**\n   * On query, if it exists in our list of queries, call it.\n   *\n   * @param {Object} query\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onQuery(query, editor, next) {\n    var type = query.type,\n        args = query.args;\n    var fn = queries[type];\n    if (!fn) return next();\n    var ret = fn.apply(undefined, [editor].concat(toConsumableArray(args)));\n    return ret === undefined ? next() : ret;\n  }\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n\n  return {\n    onConstruct: onConstruct,\n    onQuery: onQuery\n  };\n}\n/**\n * Define a Slate error.\n *\n * @type {SlateError}\n */\n\n\nvar SlateError = function (_Error) {\n  inherits(SlateError, _Error);\n\n  function SlateError(code) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, SlateError);\n\n    var _this = possibleConstructorReturn(this, (SlateError.__proto__ || Object.getPrototypeOf(SlateError)).call(this, code));\n\n    _this.code = code;\n\n    for (var key in attrs) {\n      _this[key] = attrs[key];\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(_this, _this.constructor);\n    } else {\n      _this.stack = new Error().stack;\n    }\n\n    return _this;\n  }\n\n  return SlateError;\n}(Error);\n/**\n * Create a plugin from a `schema` definition.\n *\n * @param {Object} schema\n * @return {Object}\n */\n\n\nfunction SchemaPlugin(schema) {\n  var rules = schema.rules,\n      document = schema.document,\n      blocks = schema.blocks,\n      inlines = schema.inlines,\n      marks = schema.marks,\n      annotations = schema.annotations,\n      decorations = schema.decorations;\n  var schemaRules = [];\n\n  if (rules) {\n    schemaRules = schemaRules.concat(rules);\n  }\n\n  if (document) {\n    schemaRules.push(_extends({\n      match: [{\n        object: 'document'\n      }]\n    }, document));\n  }\n\n  if (blocks) {\n    for (var key in blocks) {\n      schemaRules.push(_extends({\n        match: [{\n          object: 'block',\n          type: key\n        }]\n      }, blocks[key]));\n    }\n  }\n\n  if (inlines) {\n    for (var _key in inlines) {\n      schemaRules.push(_extends({\n        match: [{\n          object: 'inline',\n          type: _key\n        }]\n      }, inlines[_key]));\n    }\n  }\n\n  if (marks) {\n    for (var _key2 in marks) {\n      schemaRules.push(_extends({\n        match: [{\n          object: 'mark',\n          type: _key2\n        }]\n      }, marks[_key2]));\n    }\n  }\n\n  if (annotations) {\n    for (var _key3 in annotations) {\n      schemaRules.push(_extends({\n        match: [{\n          object: 'annotation',\n          type: _key3\n        }]\n      }, annotations[_key3]));\n    }\n  }\n\n  if (decorations) {\n    for (var _key4 in decorations) {\n      schemaRules.push(_extends({\n        match: [{\n          object: 'decoration',\n          type: _key4\n        }]\n      }, decorations[_key4]));\n    }\n  }\n  /**\n   * Check if a `format` is atomic based on the schema rules.\n   *\n   * @param {Editor} editor\n   * @param {Format} format\n   * @return {Boolean}\n   */\n\n\n  function isAtomic(editor, format) {\n    var rule = schemaRules.find(function (r) {\n      return 'isAtomic' in r && testRules(format, r.match);\n    });\n    return rule && rule.isAtomic;\n  }\n  /**\n   * Check if a `node` is void based on the schema rules.\n   *\n   * @param {Editor} editor\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n\n  function isVoid(editor, node) {\n    var rule = schemaRules.find(function (r) {\n      return 'isVoid' in r && testRules(node, r.match);\n    });\n    return rule && rule.isVoid;\n  }\n  /**\n   * Normalize a `node` with the schema rules, returning a function that will\n   * fix the invalid node, or void if the node is valid.\n   *\n   * @param {Node} node\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Function|Void}\n   */\n\n\n  function normalizeNode(node, editor, next) {\n    var error = validateNode(node, editor, function () {});\n    if (!error) return next();\n    return function () {\n      var rule = error.rule;\n      var size = editor.operations.size; // First run the user-provided `normalize` function if one exists...\n\n      if (rule.normalize) {\n        rule.normalize(editor, error);\n      } // If the `normalize` function did not add any operations to the editor\n      // object, it can't have normalized, so run the default one.\n\n\n      if (editor.operations.size === size) {\n        defaultNormalize(editor, error);\n      }\n    };\n  }\n  /**\n   * Validate a `node` with the schema rules, returning a `SlateError` if it's\n   * invalid.\n   *\n   * @param {Node} node\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Error|Void}\n   */\n\n\n  function validateNode(node, editor, next) {\n    var matches = schemaRules.filter(function (r) {\n      return testRules(node, r.match);\n    });\n    var failure = validateRules(node, matches, schemaRules, {\n      every: true\n    });\n    if (!failure) return next();\n    var error = new SlateError(failure.code, failure);\n    return error;\n  }\n  /**\n   * On schema-related queries, respond if we can.\n   *\n   * @param {Object} query\n   * @param {Function} next\n   */\n\n\n  var queries = QueriesPlugin({\n    isAtomic: isAtomic,\n    isVoid: isVoid\n  });\n  /**\n   * Return the plugins.\n   *\n   * @type {Object}\n   */\n\n  return [{\n    normalizeNode: normalizeNode,\n    validateNode: validateNode\n  }, queries];\n}\n/**\n * Normalize an invalid value with `error` with default remedies.\n *\n * @param {Editor} editor\n * @param {SlateError} error\n */\n\n\nfunction defaultNormalize(editor, error) {\n  var code = error.code,\n      node = error.node,\n      child = error.child,\n      next = error.next,\n      previous = error.previous,\n      key = error.key,\n      mark = error.mark;\n\n  switch (code) {\n    case 'child_max_invalid':\n    case 'child_object_invalid':\n    case 'child_type_invalid':\n    case 'child_unknown':\n    case 'first_child_object_invalid':\n    case 'first_child_type_invalid':\n    case 'last_child_object_invalid':\n    case 'last_child_type_invalid':\n      {\n        return child.object === 'text' && node.object === 'block' && node.nodes.size === 1 ? editor.removeNodeByKey(node.key) : editor.removeNodeByKey(child.key);\n      }\n\n    case 'previous_sibling_object_invalid':\n    case 'previous_sibling_type_invalid':\n      {\n        return previous.object === 'text' && node.object === 'block' && node.nodes.size === 1 ? editor.removeNodeByKey(node.key) : editor.removeNodeByKey(previous.key);\n      }\n\n    case 'next_sibling_object_invalid':\n    case 'next_sibling_type_invalid':\n      {\n        return next.object === 'text' && node.object === 'block' && node.nodes.size === 1 ? editor.removeNodeByKey(node.key) : editor.removeNodeByKey(next.key);\n      }\n\n    case 'child_min_invalid':\n    case 'node_text_invalid':\n    case 'parent_object_invalid':\n    case 'parent_type_invalid':\n      {\n        return node.object === 'document' ? node.nodes.forEach(function (n) {\n          return editor.removeNodeByKey(n.key);\n        }) : editor.removeNodeByKey(node.key);\n      }\n\n    case 'node_data_invalid':\n      {\n        return node.data.get(key) === undefined && node.object !== 'document' ? editor.removeNodeByKey(node.key) : editor.setNodeByKey(node.key, {\n          data: node.data.delete(key)\n        });\n      }\n\n    case 'node_mark_invalid':\n      {\n        return node.getTexts().forEach(function (t) {\n          return editor.removeMarkByKey(t.key, 0, t.text.length, mark);\n        });\n      }\n\n    default:\n      {\n        return editor.removeNodeByKey(node.key);\n      }\n  }\n}\n/**\n * Check that an `object` matches one of a set of `rules`.\n *\n * @param {Mixed} object\n * @param {Object|Array} rules\n * @return {Boolean}\n */\n\n\nfunction testRules(object, rules) {\n  var error = validateRules(object, rules);\n  return !error;\n}\n/**\n * Validate that a `object` matches a `rule` object or array.\n *\n * @param {Mixed} object\n * @param {Object|Array} rule\n * @param {Array|Void} rules\n * @return {Error|Void}\n */\n\n\nfunction validateRules(object, rule, rules) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$every = options.every,\n      every = _options$every === undefined ? false : _options$every,\n      _options$match = options.match,\n      match = _options$match === undefined ? null : _options$match;\n\n  if (typeof rule === 'function') {\n    var valid = rule(object, match);\n    return valid ? null : fail('node_invalid', {\n      rule: rule,\n      node: object\n    });\n  }\n\n  if (Array.isArray(rule)) {\n    var array = rule.length ? rule : [{}];\n    var first = void 0;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = array[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var r = _step.value;\n\n        var _error = validateRules(object, r, rules);\n\n        first = first || _error;\n        if (every && _error) return _error;\n        if (!every && !_error) return;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return first;\n  }\n\n  var error = validateObject(object, rule) || validateType(object, rule) || validateData(object, rule) || validateMarks(object, rule) || validateText(object, rule) || validateFirst(object, rule) || validateLast(object, rule) || validateNodes(object, rule, rules);\n  return error;\n}\n\nfunction validateObject(node, rule) {\n  if (rule.object == null) return;\n  if (rule.object === node.object) return;\n  if (typeof rule.object === 'function' && rule.object(node.object)) return;\n  return fail('node_object_invalid', {\n    rule: rule,\n    node: node\n  });\n}\n\nfunction validateType(node, rule) {\n  if (rule.type == null) return;\n  if (rule.type === node.type) return;\n  if (typeof rule.type === 'function' && rule.type(node.type)) return;\n  return fail('node_type_invalid', {\n    rule: rule,\n    node: node\n  });\n}\n\nfunction validateData(node, rule) {\n  if (rule.data == null) return;\n  if (node.data == null) return;\n\n  if (typeof rule.data === 'function') {\n    if (rule.data(node.data)) return;\n    return fail('node_data_invalid', {\n      rule: rule,\n      node: node\n    });\n  }\n\n  for (var key in rule.data) {\n    var fn = rule.data[key];\n    var value = node.data && node.data.get(key);\n    var valid = typeof fn === 'function' ? fn(value) : fn === value;\n    if (valid) continue;\n    return fail('node_data_invalid', {\n      rule: rule,\n      node: node,\n      key: key,\n      value: value\n    });\n  }\n}\n\nfunction validateMarks(node, rule) {\n  if (rule.marks == null) return;\n  var marks = node.object === 'text' ? node.marks.toArray() : node.getMarks().toArray();\n\n  var _loop = function _loop(mark) {\n    var valid = rule.marks.some(function (def) {\n      return typeof def.type === 'function' ? def.type(mark.type) : def.type === mark.type;\n    });\n    if (valid) return 'continue';\n    return {\n      v: fail('node_mark_invalid', {\n        rule: rule,\n        node: node,\n        mark: mark\n      })\n    };\n  };\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = marks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var mark = _step2.value;\n\n      var _ret = _loop(mark);\n\n      switch (_ret) {\n        case 'continue':\n          continue;\n\n        default:\n          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n}\n\nfunction validateText(node, rule) {\n  if (rule.text == null) return;\n  var text = node.text;\n  var valid = typeof rule.text === 'function' ? rule.text(text) : rule.text.test(text);\n  if (valid) return;\n  return fail('node_text_invalid', {\n    rule: rule,\n    node: node,\n    text: text\n  });\n}\n\nfunction validateFirst(node, rule) {\n  if (rule.first == null) return;\n  var first = node.nodes.first();\n  if (!first) return;\n  var error = validateRules(first, rule.first);\n  if (!error) return;\n  error.rule = rule;\n  error.node = node;\n  error.child = first;\n  error.code = error.code.replace('node_', 'first_child_');\n  return error;\n}\n\nfunction validateLast(node, rule) {\n  if (rule.last == null) return;\n  var last = node.nodes.last();\n  if (!last) return;\n  var error = validateRules(last, rule.last);\n  if (!error) return;\n  error.rule = rule;\n  error.node = node;\n  error.child = last;\n  error.code = error.code.replace('node_', 'last_child_');\n  return error;\n}\n\nfunction validateNodes(node, rule) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  if (node.nodes == null) return;\n  var children = node.nodes;\n  var defs = rule.nodes != null ? rule.nodes.slice() : [];\n  var count = 0;\n  var lastCount = 0;\n  var min = null;\n  var index = -1;\n  var def = null;\n  var max = null;\n  var child = null;\n  var previous = null;\n  var next = null;\n\n  function nextDef() {\n    if (defs.length === 0) return false;\n    def = defs.shift();\n    lastCount = count;\n    count = 0;\n    min = def.min || null;\n    max = def.max || null;\n    return true;\n  }\n\n  function nextChild() {\n    index += 1;\n    previous = index ? children.get(index - 1) : null;\n    child = children.get(index);\n    next = children.get(index + 1);\n    if (!child) return false;\n    lastCount = count;\n    count += 1;\n    return true;\n  }\n\n  function rewind() {\n    if (index > 0) {\n      index -= 1;\n      count = lastCount;\n    }\n  }\n\n  if (rule.nodes != null) {\n    nextDef();\n  }\n\n  while (nextChild()) {\n    var err = validateParent(node, child, rules) || validatePrevious(node, child, previous, index, rules) || validateNext(node, child, next, index, rules);\n    if (err) return err;\n\n    if (rule.nodes != null) {\n      if (!def) {\n        return fail('child_unknown', {\n          rule: rule,\n          node: node,\n          child: child,\n          index: index\n        });\n      }\n\n      if (def.match) {\n        var error = validateRules(child, def.match);\n\n        if (error) {\n          // Since we want to report overflow on last matching child we don't\n          // immediately check for count > max, but instead do so once we find\n          // a child that doesn't match.\n          if (max != null && count - 1 > max) {\n            rewind();\n            return fail('child_max_invalid', {\n              rule: rule,\n              node: node,\n              index: index,\n              child: children.get(index),\n              count: count,\n              limit: max\n            });\n          }\n\n          var lastMin = min; // If there are more groups after this one then child might actually\n          // be valid.\n\n          if (nextDef()) {\n            // If we've already satisfied the minimum for the current group,\n            // then we can rewind and proceed to the next group.\n            if (lastCount - 1 >= lastMin) {\n              index -= 1;\n              continue;\n            } // Otherwise we know that current value is underflowing. There are\n            // three possible causes for this...\n            // 1. There might just not be enough elements for current group, and\n            // current child is in fact the first of the next group. If so, the\n            // next def will not report errors, in which case we can rewind and\n            // report an minimum error.\n\n\n            if (validateRules(child, def.match) == null) {\n              rewind();\n              return fail('child_min_invalid', {\n                rule: rule,\n                node: node,\n                index: index,\n                count: lastCount - 1,\n                limit: lastMin\n              });\n            } // 2. The current group is underflowing, but there is also an\n            // invalid child before the next group.\n            // 3. Or the current group is not underflowing but it appears so\n            // because there's an invalid child between its members.\n            // It's either the second or third case. If it's the second then\n            // we could report an underflow, but presence of an invalid child\n            // is arguably more important, so we report it first. It also lets\n            // us avoid checking for which case exactly is it.\n\n\n            error.rule = rule;\n            error.node = node;\n            error.child = child;\n            error.index = index;\n            error.code = error.code.replace('node_', 'child_');\n            return error;\n          } // Otherwise either we exhausted the last group, in which case it's\n          // an unknown child, ...\n\n\n          if (max != null && count > max) {\n            return fail('child_unknown', {\n              rule: rule,\n              node: node,\n              child: child,\n              index: index\n            });\n          } // ... or it's an invalid child for the last group.\n\n\n          error.rule = rule;\n          error.node = node;\n          error.child = child;\n          error.index = index;\n          error.code = error.code.replace('node_', 'child_');\n          return error;\n        }\n      }\n    }\n  } // Since we want to report overflow on last matching child we don't\n  // immediately check for count > max, but do so after processing all nodes.\n\n\n  if (max != null && count > max) {\n    return fail('child_max_invalid', {\n      rule: rule,\n      node: node,\n      index: index - 1,\n      count: count,\n      child: children.get(index - 1),\n      limit: max\n    });\n  }\n\n  if (rule.nodes != null) {\n    do {\n      if (count < min) {\n        return fail('child_min_invalid', {\n          rule: rule,\n          node: node,\n          index: index,\n          count: count,\n          limit: min\n        });\n      }\n    } while (nextDef());\n  }\n}\n\nfunction validateParent(node, child, rules) {\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = rules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var rule = _step3.value;\n      if (rule.parent == null) continue;\n      if (!testRules(child, rule.match)) continue;\n      var error = validateRules(node, rule.parent);\n      if (!error) continue;\n      error.rule = rule;\n      error.parent = node;\n      error.node = child;\n      error.code = error.code.replace('node_', 'parent_');\n      return error;\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n}\n\nfunction validatePrevious(node, child, previous, index, rules) {\n  if (!previous) return;\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = rules[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var rule = _step4.value;\n      if (rule.previous == null) continue;\n      if (!testRules(child, rule.match)) continue;\n      var error = validateRules(previous, rule.previous);\n      if (!error) continue;\n      error.rule = rule;\n      error.node = node;\n      error.child = child;\n      error.index = index;\n      error.previous = previous;\n      error.code = error.code.replace('node_', 'previous_sibling_');\n      return error;\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n}\n\nfunction validateNext(node, child, next, index, rules) {\n  if (!next) return;\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = rules[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var rule = _step5.value;\n      if (rule.next == null) continue;\n      if (!testRules(child, rule.match)) continue;\n      var error = validateRules(next, rule.next, [], {\n        match: child\n      });\n      if (!error) continue;\n      error.rule = rule;\n      error.node = node;\n      error.child = child;\n      error.index = index;\n      error.next = next;\n      error.code = error.code.replace('node_', 'next_sibling_');\n      return error;\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n}\n/**\n * Create an interim failure object with `code` and `attrs`.\n *\n * @param {String} code\n * @param {Object} attrs\n * @return {Object}\n */\n\n\nfunction fail(code, attrs) {\n  return _extends({\n    code: code\n  }, attrs);\n}\n/**\n * Ensure that an expanded selection is deleted first using the `editor.delete`\n * command. This guarantees that it uses the proper semantic \"intent\" instead of\n * using `deleteAtRange` under the covers and skipping `delete`.\n *\n * @param {Editor}\n */\n\n\nfunction deleteExpanded(editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.delete();\n  }\n}\n/**\n * Commands.\n *\n * @type {Object}\n */\n\n\nvar Commands$6 = {};\n/**\n * Add a `mark` to the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Mark} mark\n */\n\nCommands$6.addMark = function (editor, mark) {\n  mark = Mark.create(mark);\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.addMarkAtRange(selection, mark);\n  } else if (selection.marks) {\n    var marks = selection.marks.add(mark);\n    var sel = selection.set('marks', marks);\n    editor.select(sel);\n  } else {\n    var _marks = document.getActiveMarksAtRange(selection).add(mark);\n\n    var _sel = selection.set('marks', _marks);\n\n    editor.select(_sel);\n  }\n};\n/**\n * Add a list of `marks` to the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Set<Mark>|Array<Object>} marks\n */\n\n\nCommands$6.addMarks = function (editor, marks) {\n  marks.forEach(function (mark) {\n    return editor.addMark(mark);\n  });\n};\n/**\n * Delete at the current selection.\n *\n * @param {Editor} editor\n */\n\n\nCommands$6.delete = function (editor) {\n  var value = editor.value;\n  var selection = value.selection;\n  editor.deleteAtRange(selection); // COMPAT: Ensure that the selection is collapsed, because in certain cases\n  // when deleting across inline nodes, when splitting the inline node the end\n  // point of the selection will end up after the split point.\n\n  editor.moveToFocus();\n};\n/**\n * Delete backward `n` characters.\n *\n * @param {Editor} editor\n * @param {Number} n (optional)\n */\n\n\nCommands$6.deleteBackward = function (editor) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var value = editor.value;\n  var selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteBackwardAtRange(selection, n);\n  }\n};\n/**\n * Delete backward one character.\n *\n * @param {Editor} editor\n */\n\n\nCommands$6.deleteCharBackward = function (editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteCharBackwardAtRange(selection);\n  }\n};\n/**\n * Delete backward one line.\n *\n * @param {Editor} editor\n */\n\n\nCommands$6.deleteLineBackward = function (editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteLineBackwardAtRange(selection);\n  }\n};\n/**\n * Delete backward one word.\n *\n * @param {Editor} editor\n */\n\n\nCommands$6.deleteWordBackward = function (editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteWordBackwardAtRange(selection);\n  }\n};\n/**\n * Delete backward `n` characters.\n *\n * @param {Editor} editor\n * @param {Number} n (optional)\n */\n\n\nCommands$6.deleteForward = function (editor) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var value = editor.value;\n  var selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteForwardAtRange(selection, n);\n  }\n};\n/**\n * Delete backward one character.\n *\n * @param {Editor} editor\n */\n\n\nCommands$6.deleteCharForward = function (editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteCharForwardAtRange(selection);\n  }\n};\n/**\n * Delete backward one line.\n *\n * @param {Editor} editor\n */\n\n\nCommands$6.deleteLineForward = function (editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteLineForwardAtRange(selection);\n  }\n};\n/**\n * Delete backward one word.\n *\n * @param {Editor} editor\n */\n\n\nCommands$6.deleteWordForward = function (editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteWordForwardAtRange(selection);\n  }\n};\n/**\n * Insert a `block` at the current selection.\n *\n * @param {Editor} editor\n * @param {String|Object|Block} block\n */\n\n\nCommands$6.insertBlock = function (editor, block) {\n  deleteExpanded(editor);\n  block = Block.create(block);\n  var value = editor.value;\n  var selection = value.selection;\n  editor.insertBlockAtRange(selection, block); // If the node was successfully inserted, update the selection.\n\n  var node = editor.value.document.getNode(block.key);\n  if (node) editor.moveToEndOfNode(node);\n};\n/**\n * Insert a `fragment` at the current selection.\n *\n * @param {Editor} editor\n * @param {Document} fragment\n */\n\n\nCommands$6.insertFragment = function (editor, fragment) {\n  if (!fragment.nodes.size) return;\n  deleteExpanded(editor);\n  var value = editor.value;\n  var _value = value,\n      document = _value.document,\n      selection = _value.selection;\n  var start = selection.start,\n      end = selection.end;\n  var _value2 = value,\n      startText = _value2.startText,\n      endText = _value2.endText,\n      startInline = _value2.startInline;\n  var lastText = fragment.getLastText();\n  var lastInline = fragment.getClosestInline(lastText.key);\n  var lastBlock = fragment.getClosestBlock(lastText.key);\n  var firstChild = fragment.nodes.first();\n  var lastChild = fragment.nodes.last();\n  var keys = Array.from(document.texts(), function (_ref) {\n    var _ref2 = slicedToArray(_ref, 1),\n        text = _ref2[0];\n\n    return text.key;\n  });\n  var isAppending = !startInline || start.isAtStartOfNode(startText) || end.isAtStartOfNode(startText) || start.isAtEndOfNode(endText) || end.isAtEndOfNode(endText);\n  var isInserting = firstChild.hasBlockChildren() || lastChild.hasBlockChildren();\n  editor.insertFragmentAtRange(selection, fragment);\n  value = editor.value;\n  document = value.document;\n  var newTexts = document.getTexts().filter(function (n) {\n    return !keys.includes(n.key);\n  });\n  var newText = isAppending ? newTexts.last() : newTexts.takeLast(2).first();\n\n  if (newText && (lastInline || isInserting)) {\n    editor.moveToEndOfNode(newText);\n  } else if (newText) {\n    // The position within the last text node needs to be calculated. This is the length\n    // of all text nodes within the last block, but if the last block contains inline nodes,\n    // these have to be skipped.\n    var nodes = lastBlock.nodes;\n    var lastIndex = nodes.findLastIndex(function (node) {\n      return node && node.object === 'inline';\n    });\n    var remainingTexts = nodes.takeLast(nodes.size - lastIndex - 1);\n    var remainingTextLength = remainingTexts.reduce(function (acc, val) {\n      return acc + val.text.length;\n    }, 0);\n    editor.moveToStartOfNode(newText).moveForward(remainingTextLength);\n  }\n};\n/**\n * Insert an `inline` at the current selection.\n *\n * @param {Editor} editor\n * @param {String|Object|Inline} inline\n */\n\n\nCommands$6.insertInline = function (editor, inline) {\n  deleteExpanded(editor);\n  inline = Inline.create(inline);\n  var value = editor.value;\n  var selection = value.selection;\n  editor.insertInlineAtRange(selection, inline); // If the node was successfully inserted, update the selection.\n\n  var node = editor.value.document.getNode(inline.key);\n  if (node) editor.moveToEndOfNode(node);\n};\n/**\n * Insert a string of `text` with optional `marks` at the current selection.\n *\n * @param {Editor} editor\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\n\nCommands$6.insertText = function (editor, text, marks) {\n  deleteExpanded(editor);\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  marks = marks || selection.marks || document.getInsertMarksAtRange(selection);\n  editor.withoutNormalizing(function () {\n    editor.insertTextAtRange(selection, text, marks); // If the text was successfully inserted, and the selection had marks on it,\n    // unset the selection's marks.\n\n    if (selection.marks && document !== editor.value.document) {\n      editor.select({\n        marks: null\n      });\n    }\n  });\n};\n/**\n * Remove a `mark` from the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Mark} mark\n */\n\n\nCommands$6.removeMark = function (editor, mark) {\n  mark = Mark.create(mark);\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.removeMarkAtRange(selection, mark);\n  } else if (selection.marks) {\n    var marks = selection.marks.remove(mark);\n    var sel = selection.set('marks', marks);\n    editor.select(sel);\n  } else {\n    var _marks2 = document.getActiveMarksAtRange(selection).remove(mark);\n\n    var _sel2 = selection.set('marks', _marks2);\n\n    editor.select(_sel2);\n  }\n};\n/**\n * Replace an `oldMark` with a `newMark` in the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Mark} oldMark\n * @param {Mark} newMark\n */\n\n\nCommands$6.replaceMark = function (editor, oldMark, newMark) {\n  editor.removeMark(oldMark);\n  editor.addMark(newMark);\n};\n/**\n * Set the `properties` of block nodes.\n *\n * @param {Editor} editor\n * @param {Object|String} properties\n */\n\n\nCommands$6.setBlocks = function (editor, properties) {\n  var value = editor.value;\n  var selection = value.selection;\n  editor.setBlocksAtRange(selection, properties);\n};\n/**\n * Set the `properties` of inline nodes.\n *\n * @param {Editor} editor\n * @param {Object|String} properties\n */\n\n\nCommands$6.setInlines = function (editor, properties) {\n  var value = editor.value;\n  var selection = value.selection;\n  editor.setInlinesAtRange(selection, properties);\n};\n/**\n * Split the block node at the current selection, to optional `depth`.\n *\n * @param {Editor} editor\n * @param {Number} depth (optional)\n */\n\n\nCommands$6.splitBlock = function (editor) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  deleteExpanded(editor);\n  var value = editor.value;\n  var selection = value.selection,\n      document = value.document;\n  var marks = selection.marks || document.getInsertMarksAtRange(selection);\n  editor.splitBlockAtRange(selection, depth).moveToEnd();\n\n  if (marks && marks.size !== 0) {\n    editor.select({\n      marks: marks\n    });\n  }\n};\n/**\n * Split the inline nodes to optional `height`.\n *\n * @param {Editor} editor\n * @param {Number} height (optional)\n */\n\n\nCommands$6.splitInline = function (editor, height) {\n  deleteExpanded(editor);\n  var value = editor.value;\n  var selection = value.selection;\n  editor.splitInlineAtRange(selection, height);\n};\n/**\n * Add or remove a `mark` from the characters in the current selection,\n * depending on whether it's already there.\n *\n * @param {Editor} editor\n * @param {Mark} mark\n */\n\n\nCommands$6.toggleMark = function (editor, mark) {\n  mark = Mark.create(mark);\n  var value = editor.value;\n  var exists = value.activeMarks.has(mark);\n\n  if (exists) {\n    editor.removeMark(mark);\n  } else {\n    editor.addMark(mark);\n  }\n};\n/**\n * Unwrap nodes from a block with `properties`.\n *\n * @param {Editor} editor\n * @param {String|Object} properties\n */\n\n\nCommands$6.unwrapBlock = function (editor, properties) {\n  var value = editor.value;\n  var selection = value.selection;\n  editor.unwrapBlockAtRange(selection, properties);\n};\n/**\n * Unwrap nodes from an inline with `properties`.\n *\n * @param {Editor} editor\n * @param {String|Object} properties\n */\n\n\nCommands$6.unwrapInline = function (editor, properties) {\n  var value = editor.value;\n  var selection = value.selection;\n  editor.unwrapInlineAtRange(selection, properties);\n};\n/**\n * Wrap nodes in a new `block`.\n *\n * @param {Editor} editor\n * @param {Block|Object|String} block\n */\n\n\nCommands$6.wrapBlock = function (editor, block) {\n  var value = editor.value;\n  var selection = value.selection;\n  editor.wrapBlockAtRange(selection, block);\n};\n/**\n * Wrap nodes in a new `inline`.\n *\n * @param {Editor} editor\n * @param {Inline|Object|String} inline\n */\n\n\nCommands$6.wrapInline = function (editor, inline) {\n  var value = editor.value;\n  var selection = value.selection;\n  editor.wrapInlineAtRange(selection, inline);\n};\n/**\n * Wrap the current selection with prefix/suffix.\n *\n * @param {Editor} editor\n * @param {String} prefix\n * @param {String} suffix\n */\n\n\nCommands$6.wrapText = function (editor, prefix) {\n  var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : prefix;\n  var value = editor.value;\n  var selection = value.selection;\n  editor.wrapTextAtRange(selection, prefix, suffix); // If the selection was collapsed, it will have moved the start offset too.\n\n  if (selection.isCollapsed) {\n    editor.moveStartBackward(prefix.length);\n  } // Adding the suffix will have pushed the end of the selection further on, so\n  // we need to move it back to account for this.\n\n\n  editor.moveEndBackward(suffix.length); // There's a chance that the selection points moved \"through\" each other,\n  // resulting in a now-incorrect selection direction.\n\n  if (selection.isForward !== editor.value.selection.isForward) {\n    editor.flip();\n  }\n};\n/**\n * A plugin that defines the core Slate logic.\n *\n * @param {Object} options\n * @return {Object}\n */\n\n\nfunction CorePlugin() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _options$plugins = options.plugins,\n      plugins = _options$plugins === undefined ? [] : _options$plugins;\n  /**\n   * The core Slate commands.\n   *\n   * @type {Object}\n   */\n\n  var commands = CommandsPlugin(_extends({}, Commands$1, Commands$2, Commands$3, Commands$4, Commands$5, Commands$6));\n  /**\n   * The core Slate queries.\n   *\n   * @type {Object}\n   */\n\n  var queries = QueriesPlugin({\n    isAtomic: function isAtomic() {\n      return false;\n    },\n    isVoid: function isVoid() {\n      return false;\n    }\n  });\n  /**\n   * The core Slate schema.\n   *\n   * @type {Object}\n   */\n\n  var schema = SchemaPlugin({\n    rules: [// Only allow block nodes in documents.\n    {\n      match: {\n        object: 'document'\n      },\n      nodes: [{\n        match: {\n          object: 'block'\n        }\n      }]\n    }, // Only allow block nodes or inline and text nodes in blocks.\n    {\n      match: {\n        object: 'block',\n        first: {\n          object: 'block'\n        }\n      },\n      nodes: [{\n        match: {\n          object: 'block'\n        }\n      }]\n    }, {\n      match: {\n        object: 'block',\n        first: [{\n          object: 'inline'\n        }, {\n          object: 'text'\n        }]\n      },\n      nodes: [{\n        match: [{\n          object: 'inline'\n        }, {\n          object: 'text'\n        }]\n      }]\n    }, // Only allow inline and text nodes in inlines.\n    {\n      match: {\n        object: 'inline'\n      },\n      nodes: [{\n        match: [{\n          object: 'inline'\n        }, {\n          object: 'text'\n        }]\n      }]\n    }, // Ensure that block and inline nodes have at least one text child.\n    {\n      match: [{\n        object: 'block'\n      }, {\n        object: 'inline'\n      }],\n      nodes: [{\n        min: 1\n      }],\n      normalize: function normalize(editor, error) {\n        var code = error.code,\n            node = error.node;\n\n        if (code === 'child_min_invalid' && node.nodes.isEmpty()) {\n          editor.insertNodeByKey(node.key, 0, Text.create());\n        }\n      }\n    }, // Ensure that inline nodes are surrounded by text nodes.\n    {\n      match: {\n        object: 'block'\n      },\n      first: [{\n        object: 'block'\n      }, {\n        object: 'text'\n      }],\n      last: [{\n        object: 'block'\n      }, {\n        object: 'text'\n      }],\n      normalize: function normalize(editor, error) {\n        var code = error.code,\n            node = error.node;\n        var text = Text.create();\n        var i = void 0;\n\n        if (code === 'first_child_object_invalid') {\n          i = 0;\n        } else if (code === 'last_child_object_invalid') {\n          i = node.nodes.size;\n        } else {\n          return;\n        }\n\n        editor.insertNodeByKey(node.key, i, text);\n      }\n    }, {\n      match: {\n        object: 'inline'\n      },\n      first: [{\n        object: 'block'\n      }, {\n        object: 'text'\n      }],\n      last: [{\n        object: 'block'\n      }, {\n        object: 'text'\n      }],\n      previous: [{\n        object: 'block'\n      }, {\n        object: 'text'\n      }],\n      next: [{\n        object: 'block'\n      }, {\n        object: 'text'\n      }],\n      normalize: function normalize(editor, error) {\n        var code = error.code,\n            node = error.node,\n            index = error.index;\n        var text = Text.create();\n        var i = void 0;\n\n        if (code === 'first_child_object_invalid') {\n          i = 0;\n        } else if (code === 'last_child_object_invalid') {\n          i = node.nodes.size;\n        } else if (code === 'previous_sibling_object_invalid') {\n          i = index;\n        } else if (code === 'next_sibling_object_invalid') {\n          i = index + 1;\n        } else {\n          return;\n        }\n\n        editor.insertNodeByKey(node.key, i, text);\n      }\n    }, // Merge adjacent text nodes with the same marks.\n    {\n      match: {\n        object: 'text'\n      },\n      next: function next(_next, match) {\n        return _next.object !== 'text' || !match.marks.equals(_next.marks);\n      },\n      normalize: function normalize(editor, error) {\n        var code = error.code,\n            next = error.next;\n\n        if (code === 'next_sibling_invalid') {\n          editor.mergeNodeByKey(next.key);\n        }\n      }\n    }, // Remove extra adjacent empty text nodes.\n    {\n      match: {\n        object: 'text'\n      },\n      previous: function previous(prev) {\n        return prev.object !== 'text' || prev.text !== '';\n      },\n      next: function next(_next2) {\n        return _next2.object !== 'text' || _next2.text !== '';\n      },\n      normalize: function normalize(editor, error) {\n        var code = error.code,\n            next = error.next,\n            previous = error.previous;\n\n        if (code === 'next_sibling_invalid') {\n          editor.removeNodeByKey(next.key);\n        } else if (code === 'previous_sibling_invalid') {\n          editor.removeNodeByKey(previous.key);\n        }\n      }\n    }]\n  });\n  /**\n   * Return the plugins.\n   *\n   * @type {Array}\n   */\n\n  return [schema].concat(toConsumableArray(plugins), [commands, queries]);\n}\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$2 = Debug('slate:editor');\n/**\n * Editor.\n *\n * @type {Editor}\n */\n\nvar Editor = function () {\n  /**\n   * Create a new `Editor` with `attrs`.\n   *\n   * @param {Object} attrs\n   * @param {Object} options\n   */\n  function Editor() {\n    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, Editor);\n    var _options$controller = options.controller,\n        controller = _options$controller === undefined ? this : _options$controller,\n        _options$construct = options.construct,\n        construct = _options$construct === undefined ? true : _options$construct;\n    var _attrs$onChange = attrs.onChange,\n        onChange = _attrs$onChange === undefined ? function () {} : _attrs$onChange,\n        _attrs$plugins = attrs.plugins,\n        plugins = _attrs$plugins === undefined ? [] : _attrs$plugins,\n        _attrs$readOnly = attrs.readOnly,\n        readOnly = _attrs$readOnly === undefined ? false : _attrs$readOnly,\n        _attrs$value = attrs.value,\n        value = _attrs$value === undefined ? Value.create() : _attrs$value;\n    this.controller = controller;\n    this.middleware = {};\n    this.onChange = onChange;\n    this.operations = List();\n    this.readOnly = null;\n    this.value = null;\n    this.tmp = {\n      dirty: [],\n      flushing: false,\n      merge: null,\n      normalize: true,\n      save: true\n    };\n    var core = CorePlugin({\n      plugins: plugins\n    });\n    registerPlugin(this, core);\n\n    if (construct) {\n      this.run('onConstruct');\n      this.setReadOnly(readOnly);\n      this.setValue(value, options);\n    }\n  }\n  /**\n   * Apply an `operation` to the editor, updating its value.\n   *\n   * @param {Operation|Object} operation\n   * @return {Editor}\n   */\n\n\n  createClass(Editor, [{\n    key: 'applyOperation',\n    value: function applyOperation(operation) {\n      var _this = this;\n\n      var operations = this.operations,\n          controller = this.controller;\n      var value = this.value; // Add in the current `value` in case the operation was serialized.\n\n      if (isPlainObject(operation)) {\n        operation = _extends({}, operation, {\n          value: value\n        });\n      }\n\n      operation = Operation.create(operation); // Save the operation into the history. Since `save` is a command, we need\n      // to do it without normalizing, since it would have side effects.\n\n      this.withoutNormalizing(function () {\n        controller.save(operation);\n        value = _this.value;\n      }); // Apply the operation to the value.\n\n      debug$2('apply', {\n        operation: operation\n      });\n      this.value = operation.apply(value);\n      this.operations = operations.push(operation); // Get the paths of the affected nodes, and mark them as dirty.\n\n      var newDirtyPaths = getDirtyPaths(operation);\n      var dirty = this.tmp.dirty.reduce(function (memo, path) {\n        path = PathUtils.create(path);\n        var transformed = PathUtils.transform(path, operation);\n        memo = memo.concat(transformed.toArray());\n        return memo;\n      }, newDirtyPaths);\n      this.tmp.dirty = dirty; // If we're not already, queue the flushing process on the next tick.\n\n      if (!this.tmp.flushing) {\n        this.tmp.flushing = true;\n        Promise.resolve().then(function () {\n          return _this.flush();\n        });\n      }\n\n      return controller;\n    }\n    /**\n     * Flush the editor's current change.\n     *\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'flush',\n    value: function flush() {\n      this.run('onChange');\n      var value = this.value,\n          operations = this.operations,\n          controller = this.controller;\n      var change = {\n        value: value,\n        operations: operations\n      };\n      this.operations = List();\n      this.tmp.flushing = false;\n      this.onChange(change);\n      return controller;\n    }\n    /**\n     * Trigger a command by `type` with `...args`.\n     *\n     * @param {String|Function} type\n     * @param {Any} ...args\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'command',\n    value: function command(type) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var controller = this.controller;\n\n      if (typeof type === 'function') {\n        type.apply(undefined, [controller].concat(args));\n        normalizeDirtyPaths(this);\n        return controller;\n      }\n\n      debug$2('command', {\n        type: type,\n        args: args\n      });\n      var obj = {\n        type: type,\n        args: args\n      };\n      this.run('onCommand', obj);\n      normalizeDirtyPaths(this);\n      return controller;\n    }\n    /**\n     * Checks if a command by `type` has been registered.\n     *\n     * @param {String} type\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasCommand',\n    value: function hasCommand(type) {\n      var controller = this.controller;\n      var has = type in controller && controller[type].__command;\n      return has;\n    }\n    /**\n     * Checks if a query by `type` has been registered.\n     *\n     * @param {String} type\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasQuery',\n    value: function hasQuery(type) {\n      var controller = this.controller;\n      var has = type in controller && controller[type].__query;\n      return has;\n    }\n    /**\n     * Normalize all of the nodes in the document from scratch.\n     *\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize() {\n      var value = this.value,\n          controller = this.controller;\n      var document = value.document;\n      var table = document.getKeysToPathsTable();\n      var paths = Object.values(table).map(PathUtils.create);\n      this.tmp.dirty = this.tmp.dirty.concat(paths);\n      normalizeDirtyPaths(this);\n      var selection = value.selection;\n      document = value.document;\n\n      if (selection.isUnset && document.nodes.size) {\n        controller.moveToStartOfDocument();\n      }\n\n      return controller;\n    }\n    /**\n     * Ask a query by `type` with `...args`.\n     *\n     * @param {String|Function} type\n     * @param {Any} ...args\n     * @return {Any}\n     */\n\n  }, {\n    key: 'query',\n    value: function query(type) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      var controller = this.controller;\n\n      if (typeof type === 'function') {\n        return type.apply(undefined, [controller].concat(args));\n      }\n\n      debug$2('query', {\n        type: type,\n        args: args\n      });\n      var obj = {\n        type: type,\n        args: args\n      };\n      return this.run('onQuery', obj);\n    }\n    /**\n     * Register a command `type` with the editor.\n     *\n     * @param {String} type\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'registerCommand',\n    value: function registerCommand(type) {\n      var _this2 = this;\n\n      var controller = this.controller;\n\n      if (type in controller && controller[type].__command) {\n        return controller;\n      }\n\n      invariant(!(type in controller), 'You cannot register a `' + type + '` command because it would overwrite an existing property of the `Editor`.');\n\n      var method = function method() {\n        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n\n        return _this2.command.apply(_this2, [type].concat(args));\n      };\n\n      controller[type] = method;\n      method.__command = true;\n      return controller;\n    }\n    /**\n     * Register a query `type` with the editor.\n     *\n     * @param {String} type\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'registerQuery',\n    value: function registerQuery(type) {\n      var _this3 = this;\n\n      var controller = this.controller;\n\n      if (type in controller && controller[type].__query) {\n        return controller;\n      }\n\n      invariant(!(type in controller), 'You cannot register a `' + type + '` query because it would overwrite an existing property of the `Editor`.');\n\n      var method = function method() {\n        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n          args[_key4] = arguments[_key4];\n        }\n\n        return _this3.query.apply(_this3, [type].concat(args));\n      };\n\n      controller[type] = method;\n      method.__query = true;\n      return controller;\n    }\n    /**\n     * Run through the middleware stack by `key` with `args`.\n     *\n     * @param {String} key\n     * @param {Any} ...args\n     * @return {Any}\n     */\n\n  }, {\n    key: 'run',\n    value: function run(key) {\n      for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        args[_key5 - 1] = arguments[_key5];\n      }\n\n      var controller = this.controller,\n          middleware = this.middleware;\n      var fns = middleware[key] || [];\n      var i = 0;\n\n      function next() {\n        var fn = fns[i++];\n        if (!fn) return;\n\n        for (var _len6 = arguments.length, overrides = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n          overrides[_key6] = arguments[_key6];\n        }\n\n        if (overrides.length) {\n          args = overrides;\n        }\n\n        var ret = fn.apply(undefined, toConsumableArray(args).concat([controller, next]));\n        return ret;\n      }\n\n      Object.defineProperty(next, 'change', {\n        get: function get$$1() {\n          invariant(false, 'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.');\n        }\n      });\n      Object.defineProperty(next, 'onChange', {\n        get: function get$$1() {\n          invariant(false, 'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.');\n        }\n      });\n      Object.defineProperty(next, 'props', {\n        get: function get$$1() {\n          invariant(false, 'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.');\n        }\n      });\n      Object.defineProperty(next, 'schema', {\n        get: function get$$1() {\n          invariant(false, 'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.');\n        }\n      });\n      Object.defineProperty(next, 'stack', {\n        get: function get$$1() {\n          invariant(false, 'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.');\n        }\n      });\n      return next();\n    }\n    /**\n     * Set the `readOnly` flag.\n     *\n     * @param {Boolean} readOnly\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'setReadOnly',\n    value: function setReadOnly(readOnly) {\n      this.readOnly = readOnly;\n      return this;\n    }\n    /**\n     * Set the editor's `value`.\n     *\n     * @param {Value} value\n     * @param {Options} options\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'setValue',\n    value: function setValue(value) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _options$normalize = options.normalize,\n          normalize = _options$normalize === undefined ? value !== this.value : _options$normalize;\n      this.value = value;\n\n      if (normalize) {\n        this.normalize();\n      }\n\n      return this;\n    }\n    /**\n     * Apply a series of changes inside a synchronous `fn`, deferring\n     * normalization until after the function has finished executing.\n     *\n     * @param {Function} fn\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'withoutNormalizing',\n    value: function withoutNormalizing(fn) {\n      var controller = this.controller;\n      var value = this.tmp.normalize;\n      this.tmp.normalize = false;\n      fn(controller);\n      this.tmp.normalize = value;\n      normalizeDirtyPaths(this);\n      return controller;\n    }\n    /**\n     * Deprecated.\n     */\n\n  }, {\n    key: 'change',\n    value: function change(fn) {\n      warning(false, 'As of Slate 0.43 the `change` object has been replaced with `editor`, so the `editor.change()` method is deprecated.`');\n\n      for (var _len7 = arguments.length, args = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n        args[_key7 - 1] = arguments[_key7];\n      }\n\n      fn.apply(undefined, [this.controller].concat(args));\n    }\n  }, {\n    key: 'call',\n    value: function call(fn) {\n      warning(false, 'As of Slate 0.43 the `editor.call(fn)` method has been deprecated, please use `editor.command(fn)` instead.');\n\n      for (var _len8 = arguments.length, args = Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n        args[_key8 - 1] = arguments[_key8];\n      }\n\n      fn.apply(undefined, [this.controller].concat(args));\n      return this.controller;\n    }\n  }, {\n    key: 'applyOperations',\n    value: function applyOperations(operations) {\n      var _this4 = this;\n\n      warning(false, 'As of Slate 0.43 the `applyOperations` method is deprecated, please apply each operation in a loop instead.');\n      operations.forEach(function (op) {\n        return _this4.applyOperation(op);\n      });\n      return this.controller;\n    }\n  }, {\n    key: 'setOperationFlag',\n    value: function setOperationFlag(key, value) {\n      warning(false, 'As of slate@0.41 the `change.setOperationFlag` method has been deprecated.');\n      this.tmp[key] = value;\n      return this;\n    }\n  }, {\n    key: 'getFlag',\n    value: function getFlag(key) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      warning(false, 'As of slate@0.41 the `change.getFlag` method has been deprecated.');\n      return options[key] !== undefined ? options[key] : this.tmp[key];\n    }\n  }, {\n    key: 'unsetOperationFlag',\n    value: function unsetOperationFlag(key) {\n      warning(false, 'As of slate@0.41 the `change.unsetOperationFlag` method has been deprecated.');\n      delete this.tmp[key];\n      return this;\n    }\n  }, {\n    key: 'withoutNormalization',\n    value: function withoutNormalization(fn) {\n      warning(false, 'As of slate@0.41 the `change.withoutNormalization` helper has been renamed to `change.withoutNormalizing`.');\n      return this.withoutNormalizing(fn);\n    }\n  }, {\n    key: 'editor',\n    get: function get$$1() {\n      warning(false, \"As of Slate 0.43 the `change` object has been replaced with `editor`, so you don't need to access `change.editor`.\");\n      return this.controller;\n    }\n  }]);\n  return Editor;\n}();\n/**\n * Get the \"dirty\" paths for a given `operation`.\n *\n * @param {Operation} operation\n * @return {Array}\n */\n\n\nfunction getDirtyPaths(operation) {\n  var type = operation.type,\n      node = operation.node,\n      path = operation.path,\n      newPath = operation.newPath;\n\n  switch (type) {\n    case 'add_mark':\n    case 'insert_text':\n    case 'remove_mark':\n    case 'remove_text':\n    case 'set_mark':\n    case 'set_node':\n      {\n        var ancestors = PathUtils.getAncestors(path).toArray();\n        return [].concat(toConsumableArray(ancestors), [path]);\n      }\n\n    case 'insert_node':\n      {\n        var table = node.getKeysToPathsTable();\n        var paths = Object.values(table).map(function (p) {\n          return path.concat(p);\n        });\n\n        var _ancestors = PathUtils.getAncestors(path).toArray();\n\n        return [].concat(toConsumableArray(_ancestors), [path], toConsumableArray(paths));\n      }\n\n    case 'split_node':\n      {\n        var _ancestors2 = PathUtils.getAncestors(path).toArray();\n\n        var nextPath = PathUtils.increment(path);\n        return [].concat(toConsumableArray(_ancestors2), [path, nextPath]);\n      }\n\n    case 'merge_node':\n      {\n        var _ancestors3 = PathUtils.getAncestors(path).toArray();\n\n        var previousPath = PathUtils.decrement(path);\n        return [].concat(toConsumableArray(_ancestors3), [previousPath]);\n      }\n\n    case 'move_node':\n      {\n        if (PathUtils.isEqual(path, newPath)) {\n          return [];\n        }\n\n        var oldAncestors = PathUtils.getAncestors(path).reduce(function (arr, p) {\n          arr.push.apply(arr, toConsumableArray(PathUtils.transform(p, operation).toArray()));\n          return arr;\n        }, []);\n        var newAncestors = PathUtils.getAncestors(newPath).reduce(function (arr, p) {\n          arr.push.apply(arr, toConsumableArray(PathUtils.transform(p, operation).toArray()));\n          return arr;\n        }, []);\n        return [].concat(toConsumableArray(oldAncestors), toConsumableArray(newAncestors));\n      }\n\n    case 'remove_node':\n      {\n        var _ancestors4 = PathUtils.getAncestors(path).toArray();\n\n        return [].concat(toConsumableArray(_ancestors4));\n      }\n\n    default:\n      {\n        return [];\n      }\n  }\n}\n/**\n * Normalize any new \"dirty\" paths that have been added to the change.\n *\n * @param {Editor}\n */\n\n\nfunction normalizeDirtyPaths(editor) {\n  if (!editor.tmp.normalize) {\n    return;\n  }\n\n  if (!editor.tmp.dirty.length) {\n    return;\n  }\n\n  editor.withoutNormalizing(function () {\n    while (editor.tmp.dirty.length) {\n      var path = editor.tmp.dirty.pop();\n      normalizeNodeByPath(editor, path);\n    }\n  });\n}\n/**\n * Normalize the node at a specific `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\n\nfunction normalizeNodeByPath(editor, path) {\n  var controller = editor.controller;\n  var value = editor.value;\n  var _value = value,\n      document = _value.document;\n  var node = document.assertNode(path);\n  var iterations = 0;\n  var max = 100 + (node.object === 'text' ? 1 : node.nodes.size);\n\n  while (node) {\n    var fn = node.normalize(controller);\n\n    if (!fn) {\n      break;\n    } // Run the normalize `fn` to fix the node.\n\n\n    fn(controller); // Attempt to re-find the node by path, or by key if it has changed\n    // locations in the tree continue iterating.\n\n    value = editor.value;\n    document = value.document;\n    var _node = node,\n        key = _node.key;\n    var found = document.getDescendant(path);\n\n    if (found && found.key === key) {\n      node = found;\n    } else {\n      found = document.getDescendant(key);\n\n      if (found) {\n        node = found;\n        path = document.getPath(key);\n      } else {\n        // If it no longer exists by key, it was removed, so we're done.\n        break;\n      }\n    } // Increment the iterations counter, and check to make sure that we haven't\n    // exceeded the max. Without this check, it's easy for the `normalize`\n    // function of a schema rule to be written incorrectly and for an infinite\n    // invalid loop to occur.\n\n\n    iterations++;\n\n    if (iterations > max) {\n      throw new Error('A schema rule could not be normalized after sufficient iterations. This is usually due to a `rule.normalize` or `plugin.normalizeNode` function of a schema being incorrectly written, causing an infinite loop.');\n    }\n  }\n}\n/**\n * Register a `plugin` with the editor.\n *\n * @param {Editor} editor\n * @param {Object|Array|Null} plugin\n */\n\n\nfunction registerPlugin(editor, plugin) {\n  if (Array.isArray(plugin)) {\n    plugin.forEach(function (p) {\n      return registerPlugin(editor, p);\n    });\n    return;\n  }\n\n  if (plugin == null) {\n    return;\n  }\n\n  var commands = plugin.commands,\n      queries = plugin.queries,\n      schema = plugin.schema,\n      rest = objectWithoutProperties(plugin, ['commands', 'queries', 'schema']);\n\n  if (commands) {\n    var commandsPlugin = CommandsPlugin(commands);\n    registerPlugin(editor, commandsPlugin);\n  }\n\n  if (queries) {\n    var queriesPlugin = QueriesPlugin(queries);\n    registerPlugin(editor, queriesPlugin);\n  }\n\n  if (schema) {\n    var schemaPlugin = SchemaPlugin(schema);\n    registerPlugin(editor, schemaPlugin);\n  }\n\n  for (var key in rest) {\n    var fn = rest[key];\n    var middleware = editor.middleware[key] = editor.middleware[key] || [];\n    middleware.push(fn);\n  }\n}\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$13 = {\n  marks: undefined,\n  text: undefined\n  /**\n   * Leaf.\n   *\n   * @type {Leaf}\n   */\n\n};\n\nvar Leaf$1 = function (_Record) {\n  inherits(Leaf, _Record);\n\n  function Leaf() {\n    classCallCheck(this, Leaf);\n    return possibleConstructorReturn(this, (Leaf.__proto__ || Object.getPrototypeOf(Leaf)).apply(this, arguments));\n  }\n\n  createClass(Leaf, [{\n    key: 'updateMark',\n\n    /**\n     * Update a `mark` at leaf, replace with newMark\n     *\n     * @param {Mark} mark\n     * @param {Mark} newMark\n     * @returns {Leaf}\n     */\n    value: function updateMark(mark, newMark) {\n      var marks = this.marks;\n      if (newMark.equals(mark)) return this;\n      if (!marks.has(mark)) return this;\n      var newMarks = marks.withMutations(function (collection) {\n        collection.remove(mark).add(newMark);\n      });\n      return this.set('marks', newMarks);\n    }\n    /**\n     * Add a `mark` to the leaf.\n     *\n     * @param {Mark} mark\n     * @returns {Text}\n     */\n\n  }, {\n    key: 'addMark',\n    value: function addMark(mark) {\n      var marks = this.marks;\n      return this.set('marks', marks.add(mark));\n    }\n    /**\n     * Add a `set` of marks to the leaf.\n     *\n     * @param {Set<Mark>} set\n     * @returns {Text}\n     */\n\n  }, {\n    key: 'addMarks',\n    value: function addMarks(set$$1) {\n      var marks = this.marks;\n      return this.set('marks', marks.union(set$$1));\n    }\n    /**\n     * Insert a text `string` into the leaf at `offset`.\n     *\n     * @param {Number} offset\n     * @param {String} string\n     * @return {Leaf}\n     */\n\n  }, {\n    key: 'insertText',\n    value: function insertText(offset, string) {\n      var text = this.text;\n      var next = text.slice(0, offset) + string + text.slice(offset);\n      return this.set('text', next);\n    }\n    /**\n     * Remove a `mark` from the leaf.\n     *\n     * @param {Mark} mark\n     * @returns {Text}\n     */\n\n  }, {\n    key: 'removeMark',\n    value: function removeMark(mark) {\n      var marks = this.marks;\n      return this.set('marks', marks.remove(mark));\n    }\n    /**\n     * Return a JSON representation of the leaf.\n     *\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var object = {\n        object: this.object,\n        text: this.text,\n        marks: this.marks.toArray().map(function (m) {\n          return m.toJSON();\n        })\n      };\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Leaf` with `attrs`.\n     *\n     * @param {Object|Leaf} attrs\n     * @return {Leaf}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      warning(false, 'As of slate@0.47 the `Leaf` model is deprecated.');\n\n      if (Leaf.isLeaf(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs === 'string') {\n        attrs = {\n          text: attrs\n        };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Leaf.fromJSON(attrs);\n      }\n\n      throw new Error('`Leaf.create` only accepts objects, strings or leaves, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a valid List of `Leaf` from `leaves`\n     *\n     * @param {List<Leaf>} leaves\n     * @return {List<Leaf>}\n     */\n\n  }, {\n    key: 'createLeaves',\n    value: function createLeaves(leaves) {\n      if (leaves.size <= 1) return leaves;\n      var invalid = false; // TODO: we can make this faster with [List] and then flatten\n\n      var result = List().withMutations(function (cache) {\n        // Search from the leaves left end to find invalid node;\n        leaves.findLast(function (leaf, index) {\n          var firstLeaf = cache.first(); // If the first leaf of cache exist, check whether the first leaf is connectable with the current leaf\n\n          if (firstLeaf) {\n            // If marks equals, then the two leaves can be connected\n            if (firstLeaf.marks.equals(leaf.marks)) {\n              invalid = true;\n              cache.set(0, firstLeaf.set('text', '' + leaf.text + firstLeaf.text));\n              return;\n            } // If the cached leaf is empty, drop the empty leaf with the upcoming leaf\n\n\n            if (firstLeaf.text === '') {\n              invalid = true;\n              cache.set(0, leaf);\n              return;\n            } // If the current leaf is empty, drop the leaf\n\n\n            if (leaf.text === '') {\n              invalid = true;\n              return;\n            }\n          }\n\n          cache.unshift(leaf);\n        });\n      });\n      if (!invalid) return leaves;\n      return result;\n    }\n    /**\n     * Split a list of leaves to two lists; if the leaves are valid leaves, the returned leaves are also valid\n     * Corner Cases:\n     *   1. if offset is smaller than 0, then return [List(), leaves]\n     *   2. if offset is bigger than the text length, then return [leaves, List()]\n     *\n     * @param {List<Leaf> leaves\n     * @return {Array<List<Leaf>>}\n     */\n\n  }, {\n    key: 'splitLeaves',\n    value: function splitLeaves(leaves, offset) {\n      if (offset < 0) return [List(), leaves];\n\n      if (leaves.size === 0) {\n        return [List(), List()];\n      }\n\n      var endOffset = 0;\n      var index = -1;\n      var left = void 0,\n          right = void 0;\n      leaves.find(function (leaf) {\n        index++;\n        var startOffset = endOffset;\n        var text = leaf.text;\n        endOffset += text.length;\n        if (endOffset < offset) return false;\n        if (startOffset > offset) return false;\n        var length = offset - startOffset;\n        left = leaf.set('text', text.slice(0, length));\n        right = leaf.set('text', text.slice(length));\n        return true;\n      });\n      if (!left) return [leaves, List()];\n\n      if (left.text === '') {\n        if (index === 0) {\n          return [List.of(left), leaves];\n        }\n\n        return [leaves.take(index), leaves.skip(index)];\n      }\n\n      if (right.text === '') {\n        if (index === leaves.size - 1) {\n          return [leaves, List.of(right)];\n        }\n\n        return [leaves.take(index + 1), leaves.skip(index + 1)];\n      }\n\n      return [leaves.take(index).push(left), leaves.skip(index + 1).unshift(right)];\n    }\n    /**\n     * Create a `Leaf` list from `attrs`.\n     *\n     * @param {Array<Leaf|Object>|List<Leaf|Object>} attrs\n     * @return {List<Leaf>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (List.isList(attrs) || Array.isArray(attrs)) {\n        var list = new List(attrs.map(Leaf.create));\n        return list;\n      }\n\n      throw new Error('`Leaf.createList` only accepts arrays or lists, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a `Leaf` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Leaf}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var _object$text = object.text,\n          text = _object$text === undefined ? '' : _object$text,\n          _object$marks = object.marks,\n          marks = _object$marks === undefined ? [] : _object$marks;\n      var leaf = new Leaf({\n        text: text,\n        marks: Set(marks.map(Mark.fromJSON))\n      });\n      return leaf;\n    }\n    /**\n     * Check if `any` is a list of leaves.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isLeafList',\n    value: function isLeafList(any) {\n      return List.isList(any) && any.every(function (item) {\n        return Leaf.isLeaf(item);\n      });\n    }\n  }]);\n  return Leaf;\n}(Record(DEFAULTS$13));\n/**\n * Mix in an `Interface` to a `Class`.\n *\n * @param {Class} Interface\n * @param {Class} Class\n */\n\n\nfunction mixin(Interface, Classes) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = Classes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var Class = _step.value; // Copy static properties from the interface.\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = Object.getOwnPropertyNames(Interface)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var name = _step2.value;\n          if (Class.hasOwnProperty(name)) continue;\n          var desc = Object.getOwnPropertyDescriptor(Interface, name);\n          Object.defineProperty(Class, name, desc);\n        } // Copy instance properties from the interface.\n\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = Object.getOwnPropertyNames(Interface.prototype)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _name = _step3.value;\n          if (Class.prototype.hasOwnProperty(_name)) continue;\n          var desc = Object.getOwnPropertyDescriptor(Interface.prototype, _name);\n          Object.defineProperty(Class.prototype, _name, desc);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n/**\n * A factory for the interface that all Slate objects implement.\n *\n * @type {Function}\n */\n\n\nfunction create$2(type) {\n  var TYPE = TYPES[type];\n  var camel = '' + type.charAt(0).toUpperCase() + type.slice(1);\n  var is$$1 = 'is' + camel;\n\n  var ObjectInterface = function () {\n    function ObjectInterface() {\n      classCallCheck(this, ObjectInterface);\n    }\n\n    createClass(ObjectInterface, [{\n      key: 'object',\n\n      /**\n       * Return the type of the object.\n       *\n       * @return {String}\n       */\n      get: function get$$1() {\n        return type;\n      }\n    }]);\n    return ObjectInterface;\n  }();\n\n  ObjectInterface[is$$1] = isObject.bind(null, type);\n  ObjectInterface.prototype[TYPE] = true;\n  return ObjectInterface;\n}\n/**\n * Mix in the object interfaces.\n */\n\n\nObject.entries({\n  Annotation: Annotation,\n  Block: Block,\n  Change: Change,\n  Decoration: Decoration,\n  Document: Document,\n  Editor: Editor,\n  Inline: Inline,\n  Leaf: Leaf$1,\n  Mark: Mark,\n  Node: Node,\n  Operation: Operation,\n  Point: Point,\n  Range: Range,\n  Selection: Selection,\n  Text: Text,\n  Value: Value\n}).forEach(function (_ref) {\n  var _ref2 = slicedToArray(_ref, 2),\n      camel = _ref2[0],\n      obj = _ref2[1];\n\n  return mixin(create$2(camel.toLowerCase()), [obj]);\n});\n/**\n * The interface that all Slate models implement.\n *\n * @type {Class}\n */\n\nvar ModelInterface = function () {\n  function ModelInterface() {\n    classCallCheck(this, ModelInterface);\n  }\n\n  createClass(ModelInterface, [{\n    key: 'toJS',\n\n    /**\n     * Alias `toJS`.\n     */\n    value: function toJS() {\n      return this.toJSON.apply(this, arguments);\n    }\n  }], [{\n    key: 'fromJS',\n\n    /**\n     * Alias `fromJS`.\n     */\n    value: function fromJS() {\n      return this.fromJSON.apply(this, arguments);\n    }\n  }]);\n  return ModelInterface;\n}();\n/**\n * Mix in the common interface.\n *\n * @param {Record}\n */\n\n\nmixin(ModelInterface, [Annotation, Block, Decoration, Document, Inline, Leaf$1, Mark, Node, Operation, Point, Range, Selection, Text, Value]);\n/* global WeakMap, Map, Symbol */\n\n/**\n * GLOBAL: True if memoization should is enabled.\n *\n * @type {Boolean}\n */\n\nvar ENABLED = true;\n/**\n * The leaf node of a cache tree. Used to support variable argument length. A\n * unique object, so that native Maps will key it by reference.\n *\n * @type {Symbol}\n */\n\nvar LEAF = Symbol('LEAF');\n/**\n * The node of a cache tree for a WeakMap to store cache visited by objects\n *\n * @type {Symbol}\n */\n\nvar STORE_KEY = Symbol('STORE_KEY');\n/**\n * Values to represent a memoized undefined and null value. Allows efficient value\n * retrieval using Map.get only.\n *\n * @type {Symbol}\n */\n\nvar UNDEFINED = Symbol('undefined');\nvar NULL = Symbol('null');\n/**\n * Default value for unset keys in native Maps\n *\n * @type {Undefined}\n */\n\nvar UNSET = undefined;\n/**\n * Global Store for all cached values\n *\n * @type {WeakMap}\n */\n\nvar memoizeStore = new WeakMap();\n/**\n * Memoize all of the `properties` on a `object`.\n *\n * @param {Object} object\n * @param {Array} properties\n * @return {Record}\n */\n\nfunction memoize(object, properties) {\n  var _loop = function _loop(property) {\n    var original = object[property];\n\n    if (!original) {\n      throw new Error('Object does not have a property named \"' + property + '\".');\n    }\n\n    object[property] = function () {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      } // If memoization is disabled, call into the original method.\n\n\n      if (!ENABLED) return original.apply(this, args);\n\n      if (!memoizeStore.has(this)) {\n        memoizeStore.set(this, {\n          noArgs: {},\n          hasArgs: {}\n        });\n      }\n\n      var _memoizeStore$get = memoizeStore.get(this),\n          noArgs = _memoizeStore$get.noArgs,\n          hasArgs = _memoizeStore$get.hasArgs;\n\n      var takesArguments = args.length !== 0;\n      var cachedValue = void 0;\n      var keys = void 0;\n\n      if (takesArguments) {\n        keys = [property].concat(args);\n        cachedValue = getIn(hasArgs, keys);\n      } else {\n        cachedValue = noArgs[property];\n      } // If we've got a result already, return it.\n\n\n      if (cachedValue !== UNSET) {\n        return cachedValue === UNDEFINED ? undefined : cachedValue;\n      } // Otherwise calculate what it should be once and cache it.\n\n\n      var value = original.apply(this, args);\n      var v = value === undefined ? UNDEFINED : value;\n\n      if (takesArguments) {\n        setIn(hasArgs, keys, v);\n      } else {\n        noArgs[property] = v;\n      }\n\n      return value;\n    };\n  };\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var property = _step.value;\n\n      _loop(property);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n/**\n * Get a value at a key path in a tree of Map.\n *\n * If not set, returns UNSET.\n * If the set value is undefined, returns UNDEFINED.\n *\n * @param {Map} map\n * @param {Array} keys\n * @return {Any|UNSET|UNDEFINED}\n */\n\n\nfunction getIn(map, keys) {\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var key = _step2.value;\n\n      if (key === undefined) {\n        key = UNDEFINED;\n      } else if (key == null) {\n        key = NULL;\n      }\n\n      if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {\n        map = map[STORE_KEY] && map[STORE_KEY].get(key);\n      } else {\n        map = map[key];\n      }\n\n      if (map === UNSET) return UNSET;\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return map[LEAF];\n}\n/**\n * Set a value at a key path in a tree of Map, creating Maps on the go.\n *\n * @param {Map} map\n * @param {Array} keys\n * @param {Any} value\n * @return {Map}\n */\n\n\nfunction setIn(map, keys, value) {\n  var child = map;\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var key = _step3.value;\n\n      if (key === undefined) {\n        key = UNDEFINED;\n      } else if (key == null) {\n        key = NULL;\n      }\n\n      if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) !== 'object') {\n        if (!child[key]) {\n          child[key] = {};\n        }\n\n        child = child[key];\n        continue;\n      }\n\n      if (!child[STORE_KEY]) {\n        child[STORE_KEY] = new WeakMap();\n      }\n\n      if (!child[STORE_KEY].has(key)) {\n        var newChild = {};\n        child[STORE_KEY].set(key, newChild);\n        child = newChild;\n        continue;\n      }\n\n      child = child[STORE_KEY].get(key);\n    } // The whole path has been created, so set the value to the bottom most map.\n\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  child[LEAF] = value;\n  return map;\n}\n/**\n * In DEV mode, clears the previously memoized values, globally.\n *\n * @return {Void}\n */\n\n\nfunction resetMemoization() {\n  memoizeStore = new WeakMap();\n}\n/**\n * In DEV mode, enable or disable the use of memoize values, globally.\n *\n * @param {Boolean} enabled\n * @return {Void}\n */\n\n\nfunction useMemoization(enabled) {\n  ENABLED = enabled;\n}\n/**\n * The interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Class}\n */\n\n\nvar NodeInterface = function () {\n  function NodeInterface() {\n    classCallCheck(this, NodeInterface);\n  }\n\n  createClass(NodeInterface, [{\n    key: 'getFirstText',\n\n    /**\n     * Get the first text node of a node, or the node itself.\n     *\n     * @return {Node|Null}\n     */\n    value: function getFirstText() {\n      if (this.object === 'text') {\n        return this;\n      }\n\n      var descendant = null;\n      var found = this.nodes.find(function (node) {\n        if (node.object === 'text') return true;\n        descendant = node.getFirstText();\n        return !!descendant;\n      });\n      return descendant || found;\n    }\n    /**\n     * Get an object mapping all the keys in the node to their paths.\n     *\n     * @return {Object}\n     */\n\n  }, {\n    key: 'getKeysToPathsTable',\n    value: function getKeysToPathsTable() {\n      var ret = defineProperty({}, this.key, []);\n\n      if (this.nodes) {\n        this.nodes.forEach(function (node, i) {\n          var nested = node.getKeysToPathsTable();\n\n          for (var key in nested) {\n            var path = nested[key];\n            warning(!(key in ret), 'A node with a duplicate key of \"' + key + '\" was found! Duplicate keys are not allowed, you should use `node.regenerateKey` before inserting if you are reusing an existing node.');\n            ret[key] = [i].concat(toConsumableArray(path));\n          }\n        });\n      }\n\n      return ret;\n    }\n    /**\n     * Get the last text node of a node, or the node itself.\n     *\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getLastText',\n    value: function getLastText() {\n      if (this.object === 'text') {\n        return this;\n      }\n\n      var descendant = null;\n      var found = this.nodes.findLast(function (node) {\n        if (node.object === 'text') return true;\n        descendant = node.getLastText();\n        return descendant;\n      });\n      return descendant || found;\n    }\n    /**\n     * Get a node in the tree, or the node itself.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNode',\n    value: function getNode(path) {\n      path = this.resolvePath(path);\n      if (!path) return null;\n      if (this.object === 'text' && path.size) return null;\n      var node = path.size ? this.getDescendant(path) : this;\n      return node;\n    }\n    /**\n     * Find the path to a node.\n     *\n     * @param {String|List} key\n     * @return {List}\n     */\n\n  }, {\n    key: 'getPath',\n    value: function getPath(key) {\n      // COMPAT: Handle passing in a path, to match other methods.\n      if (List.isList(key)) {\n        return key;\n      } // COMPAT: Handle a node object by iterating the descendants tree, so that\n      // we avoid using keys for the future.\n\n\n      if (Node.isNode(key) && this.descendants) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.descendants()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref = _step.value;\n\n            var _ref2 = slicedToArray(_ref, 2);\n\n            var node = _ref2[0];\n            var _path = _ref2[1];\n            if (key === node) return _path;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      var dict = this.getKeysToPathsTable();\n      var path = dict[key];\n      return path ? List(path) : null;\n    }\n    /**\n     * Get the concatenated text string of a node.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'getText',\n    value: function getText() {\n      if (this.object === 'text') {\n        return this.text;\n      }\n\n      var text = this.nodes.reduce(function (memo, c) {\n        return memo + c.text;\n      }, '');\n      return text;\n    }\n    /**\n     * Check if a node exists.\n     *\n     * @param {List|String} path\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasNode',\n    value: function hasNode(path) {\n      var node = this.getNode(path);\n      return !!node;\n    }\n    /**\n     * Normalize the text node with an `editor`.\n     *\n     * @param {Editor} editor\n     * @return {Function|Void}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(editor) {\n      var normalizer = editor.run('normalizeNode', this);\n      return normalizer;\n    }\n    /**\n     * Regenerate the node's key.\n     *\n     * @return {Node}\n     */\n\n  }, {\n    key: 'regenerateKey',\n    value: function regenerateKey() {\n      var key = KeyUtils.create();\n      var node = this.set('key', key);\n      return node;\n    }\n    /**\n     * Resolve a path from a path list or key string.\n     *\n     * An `index` can be provided, in which case paths created from a key string\n     * will have the index pushed onto them. This is helpful in cases where you\n     * want to accept either a `path` or a `key, index` combination for targeting\n     * a location in the tree that doesn't exist yet, like when inserting.\n     *\n     * @param {List|String} value\n     * @param {Number} index\n     * @return {List}\n     */\n\n  }, {\n    key: 'resolvePath',\n    value: function resolvePath(path, index) {\n      if (typeof path === 'string') {\n        path = this.getPath(path);\n\n        if (index != null) {\n          path = path.concat(index);\n        }\n      } else {\n        path = PathUtils.create(path);\n      }\n\n      return path;\n    }\n    /**\n     * Validate the node with an `editor`.\n     *\n     * @param {Editor} editor\n     * @return {Error|Void}\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(editor) {\n      var error = editor.run('validateNode', this);\n      return error;\n    }\n  }]);\n  return NodeInterface;\n}();\n/**\n * Memoize read methods.\n */\n\n\nmemoize(NodeInterface.prototype, ['getFirstText', 'getKeysToPathsTable', 'getLastText', 'getText', 'normalize', 'validate']);\n/**\n * Mix in the node interface.\n */\n\nmixin(NodeInterface, [Block, Document, Inline, Text]);\nvar global$1 = typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {};\n\nfunction identity() {\n  return true;\n}\n/**\n * The interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Class}\n */\n\n\nvar ElementInterface = function () {\n  function ElementInterface() {\n    classCallCheck(this, ElementInterface);\n  }\n\n  createClass(ElementInterface, [{\n    key: 'addMark',\n\n    /**\n     * Add `mark` to text at `path`.\n     *\n     * @param {List|String} path\n     * @param {Mark} mark\n     * @return {Node}\n     */\n    value: function addMark(path, mark) {\n      path = this.resolvePath(path);\n      var node = this.assertDescendant(path);\n      node = node.addMark(mark);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n    /**\n     * Create an iteratable for all of the ancestors of the node.\n     *\n     * @return {Iterable}\n     */\n\n  }, {\n    key: 'ancestors',\n    value: function ancestors(path) {\n      var iterable = this.createIterable({\n        path: path,\n        direction: null,\n        downward: false,\n        includeTargetAncestors: true,\n        includeRoot: true\n      });\n      return iterable;\n    }\n    /**\n     * Create an iteratable for all of the blocks of a node with `options`.\n     *\n     * @param {Options}\n     * @return {Iterable}\n     */\n\n  }, {\n    key: 'blocks',\n    value: function blocks() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var onlyLeaves = options.onlyLeaves,\n          onlyRoots = options.onlyRoots,\n          onlyTypes = options.onlyTypes,\n          _match = options.match,\n          rest = objectWithoutProperties(options, ['onlyLeaves', 'onlyRoots', 'onlyTypes', 'match']);\n      var iterable = this.descendants(_extends({\n        includeDocument: false,\n        includeInlines: false,\n        includeTexts: false\n      }, rest, {\n        match: function match(node, path) {\n          if (onlyTypes && !onlyTypes.includes(node.type)) {\n            return false;\n          } else if (onlyRoots && path.size !== 1) {\n            return false;\n          } else if (onlyLeaves && !node.isLeafBlock()) {\n            return false;\n          } else if (_match && !_match(node, path)) {\n            return false;\n          } else {\n            return true;\n          }\n        }\n      }));\n      return iterable;\n    }\n    /**\n     * Create an annotation with `properties` relative to the node.\n     *\n     * @param {Object|Annotation} properties\n     * @return {Annotation}\n     */\n\n  }, {\n    key: 'createAnnotation',\n    value: function createAnnotation(properties) {\n      properties = Annotation.createProperties(properties);\n      var annotation = this.resolveAnnotation(properties);\n      return annotation;\n    }\n    /**\n     * Create a decoration with `properties` relative to the node.\n     *\n     * @param {Object|Decoration} properties\n     * @return {Decoration}\n     */\n\n  }, {\n    key: 'createDecoration',\n    value: function createDecoration(properties) {\n      properties = Decoration.createProperties(properties);\n      var decoration = this.resolveDecoration(properties);\n      return decoration;\n    }\n    /**\n     * Create an iteratable function starting at `target` path with `options`.\n     *\n     * @param {Object} options (optional)\n     * @return {Function}\n     */\n\n  }, {\n    key: 'createIterable',\n    value: function createIterable() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _options$direction = options.direction,\n          direction = _options$direction === undefined ? 'forward' : _options$direction,\n          _options$downward = options.downward,\n          downward = _options$downward === undefined ? true : _options$downward,\n          _options$upward = options.upward,\n          upward = _options$upward === undefined ? true : _options$upward,\n          _options$includeBlock = options.includeBlocks,\n          includeBlocks = _options$includeBlock === undefined ? true : _options$includeBlock,\n          _options$includeDocum = options.includeDocument,\n          includeDocument = _options$includeDocum === undefined ? true : _options$includeDocum,\n          _options$includeInlin = options.includeInlines,\n          includeInlines = _options$includeInlin === undefined ? true : _options$includeInlin,\n          _options$includeRoot = options.includeRoot,\n          includeRoot = _options$includeRoot === undefined ? false : _options$includeRoot,\n          _options$includeTarge = options.includeTarget,\n          includeTarget = _options$includeTarge === undefined ? !!options.range : _options$includeTarge,\n          _options$includeTarge2 = options.includeTargetAncestors,\n          includeTargetAncestors = _options$includeTarge2 === undefined ? false : _options$includeTarge2,\n          _options$includeTexts = options.includeTexts,\n          includeTexts = _options$includeTexts === undefined ? true : _options$includeTexts,\n          _options$match = options.match,\n          match = _options$match === undefined ? null : _options$match;\n      var root = this;\n      var targetPath = null;\n      var targetRange = null; // You can iterate over either a range or a path, but not both.\n\n      if (options.range) {\n        targetRange = root.resolveRange(options.range);\n        targetPath = root.resolvePath(targetRange.start.path);\n      } else if (options.path) {\n        targetPath = root.resolvePath(options.path);\n      }\n\n      var targetNode = targetPath && root.assertNode(targetPath);\n      var NativeSet = typeof window === 'undefined' ? global$1.Set : window.Set; // Return an object that implements the iterable interface.\n\n      return defineProperty({}, Symbol.iterator, function () {\n        var visited = new NativeSet();\n        var startPath = targetRange && targetRange.start.path;\n        var endPath = targetRange && targetRange.end.path;\n        var path = targetPath;\n        var node = targetNode;\n        var includedTarget = false;\n        var includedStart = false;\n        var includingStart = false;\n\n        var result = function result() {\n          // When these are nulled out we've finished iterating.\n          if (!path || !node) {\n            return {\n              done: true\n            };\n          } // We often don't want to include the root node itself.\n\n\n          if (!includeRoot && node === root) {\n            return next();\n          }\n\n          if (!includeBlocks && node.object === 'block') {\n            return next();\n          }\n\n          if (!includeDocument && node.object === 'document') {\n            return next();\n          }\n\n          if (!includeInlines && node.object === 'inline') {\n            return next();\n          }\n\n          if (!includeTexts && node.object === 'text') {\n            return next();\n          }\n\n          if (match && !match(node, path)) {\n            return next();\n          }\n\n          return {\n            value: [node, path],\n            done: false\n          };\n        };\n\n        var next = function next() {\n          if (!path || !node) {\n            return result();\n          } // When iterating over a range, we need to include the specific\n          // ancestors in the start path of the range manually.\n\n\n          if (startPath && !includedStart) {\n            if (!includingStart) {\n              includingStart = true;\n              path = PathUtils.create([]);\n              node = root;\n              return result();\n            }\n\n            if (path.size === startPath.size - 1) {\n              includedStart = true;\n              path = targetPath;\n              node = targetNode;\n              return next();\n            }\n\n            path = startPath.slice(0, path.size + 1);\n            node = root.assertNode(path);\n            return result();\n          } // Sometimes we want to include the target itself.\n\n\n          if (includeTarget && !includedTarget) {\n            includedTarget = true;\n            return result();\n          } // When iterating over a range, if we get to the end path then exit.\n\n\n          if (endPath && path.equals(endPath)) {\n            node = null;\n            path = null;\n            return next();\n          } // If we're allowed to go downward, and we haven't decsended yet, do so.\n\n\n          if (downward && node.nodes && node.nodes.size && !visited.has(node)) {\n            visited.add(node);\n            var nextIndex = direction === 'forward' ? 0 : node.nodes.size - 1;\n            path = path.push(nextIndex);\n            node = root.assertNode(path);\n            return result();\n          } // If we're going forward...\n\n\n          if (direction === 'forward') {\n            var newPath = PathUtils.increment(path);\n            var newNode = root.getNode(newPath);\n\n            if (newNode) {\n              path = newPath;\n              node = newNode;\n              return result();\n            }\n          } // If we're going backward...\n\n\n          if (direction === 'backward' && path.last() !== 0) {\n            var _newPath = PathUtils.decrement(path);\n\n            var _newNode = root.getNode(_newPath);\n\n            if (_newNode) {\n              path = _newPath;\n              node = _newNode;\n              return result();\n            }\n          } // If we're going upward...\n\n\n          if (upward && path.size) {\n            path = PathUtils.lift(path);\n            node = root.assertNode(path); // Sometimes we'll have already visited the node on the way down\n            // so we don't want to double count it.\n\n            if (visited.has(node)) {\n              return next();\n            }\n\n            visited.add(node); // If ancestors of the target node shouldn't be included, skip them.\n\n            if (!includeTargetAncestors) {\n              return next();\n            } else {\n              return result();\n            }\n          }\n\n          path = null;\n          node = null;\n          return next();\n        };\n\n        return {\n          next: next\n        };\n      });\n    }\n    /**\n     * Create a point with `properties` relative to the node.\n     *\n     * @param {Object|Point} properties\n     * @return {Range}\n     */\n\n  }, {\n    key: 'createPoint',\n    value: function createPoint(properties) {\n      properties = Point.createProperties(properties);\n      var point = this.resolvePoint(properties);\n      return point;\n    }\n    /**\n     * Create a range with `properties` relative to the node.\n     *\n     * @param {Object|Range} properties\n     * @return {Range}\n     */\n\n  }, {\n    key: 'createRange',\n    value: function createRange(properties) {\n      properties = Range.createProperties(properties);\n      var range = this.resolveRange(properties);\n      return range;\n    }\n    /**\n     * Create a selection with `properties` relative to the node.\n     *\n     * @param {Object|Selection} properties\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'createSelection',\n    value: function createSelection(properties) {\n      properties = Selection.createProperties(properties);\n      var selection = this.resolveSelection(properties);\n      return selection;\n    }\n    /**\n     * Create an iteratable for all of the descendants of the node.\n     *\n     * @param {Object} options\n     * @return {Iterable}\n     */\n\n  }, {\n    key: 'descendants',\n    value: function descendants(options) {\n      var iterable = this.createIterable(_extends({\n        path: []\n      }, options));\n      return iterable;\n    }\n    /**\n     * Find all of the descendants that match a `predicate`.\n     *\n     * @param {Function} predicate\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'filterDescendants',\n    value: function filterDescendants() {\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\n      var matches = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.descendants()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _ref2 = _step.value;\n\n          var _ref3 = slicedToArray(_ref2, 2);\n\n          var node = _ref3[0];\n          var path = _ref3[1];\n\n          if (predicate(node, path)) {\n            matches.push(node);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return List(matches);\n    }\n    /**\n     * Find the first descendant that matches a `predicate`.\n     *\n     * @param {Function} predicate\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'findDescendant',\n    value: function findDescendant() {\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.descendants()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _ref4 = _step2.value;\n\n          var _ref5 = slicedToArray(_ref4, 2);\n\n          var node = _ref5[0];\n          var path = _ref5[1];\n\n          if (predicate(node, path)) {\n            return node;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Iterate over all descendants, breaking if `predicate` returns false.\n     *\n     * @param {Function} predicate\n     */\n\n  }, {\n    key: 'forEachDescendant',\n    value: function forEachDescendant() {\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this.descendants()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _next = _step3.value;\n          var ret = predicate.apply(undefined, toConsumableArray(_next));\n\n          if (ret === false) {\n            return;\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n    /**\n     * Get a set of the active marks in a `range`. Active marks are marks that are\n     * on every text node in a given range. This is a common distinction for\n     * highlighting toolbar buttons for example.\n     *\n     * TODO: this method needs to be cleaned up, it's very hard to follow and\n     * probably doing unnecessary work.\n     *\n     * @param {Range} range\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getActiveMarksAtRange',\n    value: function getActiveMarksAtRange(range) {\n      range = this.resolveRange(range);\n\n      if (range.isUnset) {\n        return Set();\n      }\n\n      if (range.isCollapsed) {\n        var _range = range,\n            _start = _range.start;\n        return this.getInsertMarksAtPoint(_start);\n      }\n\n      var _range2 = range,\n          start = _range2.start,\n          end = _range2.end;\n      var startPath = start.path;\n      var startOffset = start.offset;\n      var endPath = end.path;\n      var endOffset = end.offset;\n      var startText = this.getDescendant(startPath);\n      var endText = this.getDescendant(endPath);\n\n      if (!startPath.equals(endPath)) {\n        while (!startPath.equals(endPath) && endOffset === 0) {\n          var _texts = this.texts({\n            path: endPath,\n            direction: 'backward'\n          });\n\n          var _texts2 = slicedToArray(_texts, 1);\n\n          var _texts2$ = slicedToArray(_texts2[0], 2);\n\n          endText = _texts2$[0];\n          endPath = _texts2$[1];\n          endOffset = endText.text.length;\n        }\n\n        while (!startPath.equals(endPath) && startOffset === startText.text.length) {\n          var _texts3 = this.texts({\n            path: startPath\n          });\n\n          var _texts4 = slicedToArray(_texts3, 1);\n\n          var _texts4$ = slicedToArray(_texts4[0], 2);\n\n          startText = _texts4$[0];\n          startPath = _texts4$[1];\n          startOffset = 0;\n        }\n      }\n\n      if (startPath.equals(endPath)) {\n        return startText.marks;\n      }\n\n      var startMarks = startText.marks; // PERF: if start marks is empty we can return early.\n\n      if (startMarks.size === 0) {\n        return Set();\n      }\n\n      var endMarks = endText.marks;\n      var marks = startMarks.intersect(endMarks); // If marks is already empty, the active marks is empty\n\n      if (marks.size === 0) {\n        return marks;\n      }\n\n      var _texts5 = this.texts({\n        path: startPath\n      });\n\n      var _texts6 = slicedToArray(_texts5, 1);\n\n      var _texts6$ = slicedToArray(_texts6[0], 2);\n\n      startText = _texts6$[0];\n      startPath = _texts6$[1];\n\n      while (!startPath.equals(endPath)) {\n        if (startText.text.length !== 0) {\n          marks = marks.intersect(startText.marks);\n\n          if (marks.size === 0) {\n            return Set();\n          }\n        }\n\n        var _texts7 = this.texts({\n          path: startPath\n        });\n\n        var _texts8 = slicedToArray(_texts7, 1);\n\n        var _texts8$ = slicedToArray(_texts8[0], 2);\n\n        startText = _texts8$[0];\n        startPath = _texts8$[1];\n      }\n\n      return marks;\n    }\n    /**\n     * Get a list of the ancestors of a descendant.\n     *\n     * @param {List|String} path\n     * @return {List<Node>|Null}\n     */\n\n  }, {\n    key: 'getAncestors',\n    value: function getAncestors(path) {\n      var iterable = this.ancestors(path);\n      var array = Array.from(iterable, function (_ref6) {\n        var _ref7 = slicedToArray(_ref6, 1),\n            node = _ref7[0];\n\n        return node;\n      }).reverse();\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get the leaf block descendants of the node.\n     *\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getBlocks',\n    value: function getBlocks() {\n      var iterable = this.blocks({\n        onlyLeaves: true\n      });\n      var array = Array.from(iterable, function (_ref8) {\n        var _ref9 = slicedToArray(_ref8, 1),\n            node = _ref9[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get all of the leaf blocks that match a `type`.\n     *\n     * @param {String} type\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getBlocksByType',\n    value: function getBlocksByType(type) {\n      var iterable = this.blocks({\n        onlyLeaves: true,\n        onlyTypes: [type]\n      });\n      var array = Array.from(iterable, function (_ref10) {\n        var _ref11 = slicedToArray(_ref10, 1),\n            node = _ref11[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get a child node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getChild',\n    value: function getChild(path) {\n      path = this.resolvePath(path);\n\n      if (!path || path.size > 1) {\n        return null;\n      }\n\n      var child = this.nodes.get(path.first());\n      return child;\n    }\n    /**\n     * Get closest parent of node that matches a `predicate`.\n     *\n     * @param {List|String} path\n     * @param {Function} predicate\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getClosest',\n    value: function getClosest(path, predicate) {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = this.ancestors(path)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var _ref12 = _step4.value;\n\n          var _ref13 = slicedToArray(_ref12, 2);\n\n          var n = _ref13[0];\n          var p = _ref13[1];\n\n          if (predicate(n, p)) {\n            return n;\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Get the closest block parent of a node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getClosestBlock',\n    value: function getClosestBlock(path) {\n      var closest = this.getClosest(path, function (n) {\n        return n.object === 'block';\n      });\n      return closest;\n    }\n    /**\n     * Get the closest inline parent of a node by `path`.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getClosestInline',\n    value: function getClosestInline(path) {\n      var closest = this.getClosest(path, function (n) {\n        return n.object === 'inline';\n      });\n      return closest;\n    }\n    /**\n     * Get the closest void parent of a node by `path`.\n     *\n     * @param {List|String} path\n     * @param {Editor} editor\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getClosestVoid',\n    value: function getClosestVoid(path, editor) {\n      invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `node.getClosestVoid` method takes an `editor` instead of a `value`.');\n      var closest = this.getClosest(path, function (n) {\n        return editor.isVoid(n);\n      });\n      return closest;\n    }\n    /**\n     * Get the common ancestor of nodes `a` and `b`.\n     *\n     * @param {List} a\n     * @param {List} b\n     * @return {Node}\n     */\n\n  }, {\n    key: 'getCommonAncestor',\n    value: function getCommonAncestor(a, b) {\n      a = this.resolvePath(a);\n      b = this.resolvePath(b);\n\n      if (!a || !b) {\n        return null;\n      }\n\n      var path = PathUtils.relate(a, b);\n      var node = this.getNode(path);\n      return node;\n    }\n    /**\n     * Get the decorations for the node from an `editor`.\n     *\n     * @param {Editor} editor\n     * @return {List}\n     */\n\n  }, {\n    key: 'getDecorations',\n    value: function getDecorations(editor) {\n      var decorations = editor.run('decorateNode', this);\n      decorations = Decoration.createList(decorations);\n      return decorations;\n    }\n    /**\n     * Get the depth of a descendant, with optional `startAt`.\n     *\n     * @param {List|String} path\n     * @param {Number} startAt\n     * @return {Number|Null}\n     */\n\n  }, {\n    key: 'getDepth',\n    value: function getDepth(path) {\n      var startAt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      path = this.resolvePath(path);\n\n      if (!path) {\n        return null;\n      }\n\n      var node = this.getNode(path);\n      var depth = node ? path.size - 1 + startAt : null;\n      return depth;\n    }\n    /**\n     * Get a descendant node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getDescendant',\n    value: function getDescendant(path) {\n      path = this.resolvePath(path);\n\n      if (!path || !path.size) {\n        return null;\n      }\n\n      var node = this;\n      path.forEach(function (index) {\n        node = node.getIn(['nodes', index]);\n        return !!node;\n      });\n      return node;\n    }\n    /**\n     * Get all of the descendant nodes in a `range`.\n     *\n     * @param {Range} range\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getDescendantsAtRange',\n    value: function getDescendantsAtRange(range) {\n      var iterable = this.descendants({\n        range: range\n      });\n      var array = Array.from(iterable, function (_ref14) {\n        var _ref15 = slicedToArray(_ref14, 1),\n            node = _ref15[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get a fragment of the node at a `range`.\n     *\n     * @param {Range} range\n     * @return {Document}\n     */\n\n  }, {\n    key: 'getFragmentAtRange',\n    value: function getFragmentAtRange(range) {\n      range = this.resolveRange(range);\n\n      if (range.isUnset) {\n        return Document.create();\n      }\n\n      var _range3 = range,\n          start = _range3.start,\n          end = _range3.end;\n      var node = this;\n      var targetPath = end.path;\n      var targetPosition = end.offset;\n      var side = 'end';\n\n      while (targetPath.size) {\n        var index = targetPath.last();\n        node = node.splitNode(targetPath, targetPosition);\n        targetPosition = index + 1;\n        targetPath = PathUtils.lift(targetPath);\n\n        if (!targetPath.size && side === 'end') {\n          targetPath = start.path;\n          targetPosition = start.offset;\n          side = 'start';\n        }\n      }\n\n      var startIndex = start.path.first() + 1;\n      var endIndex = end.path.first() + 2;\n      var nodes = node.nodes.slice(startIndex, endIndex);\n      var fragment = Document.create({\n        nodes: nodes\n      });\n      return fragment;\n    }\n    /**\n     * Get the furthest ancestors of a node that matches a `predicate`.\n     *\n     * @param {Path} path\n     * @param {Function} predicate\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthest',\n    value: function getFurthest(path) {\n      var predicate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;\n      var iterable = this.ancestors(path);\n      var results = Array.from(iterable).reverse();\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = results[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var _ref16 = _step5.value;\n\n          var _ref17 = slicedToArray(_ref16, 2);\n\n          var n = _ref17[0];\n          var p = _ref17[1];\n\n          if (predicate(n, p)) {\n            return n;\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Get the furthest block parent of a node.\n     *\n     * @param {Path} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthestBlock',\n    value: function getFurthestBlock(path) {\n      var furthest = this.getFurthest(path, function (n) {\n        return n.object === 'block';\n      });\n      return furthest;\n    }\n    /**\n     * Get the furthest child ancestor of a node at `path`.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthestChild',\n    value: function getFurthestChild(path) {\n      path = this.resolvePath(path);\n\n      if (!path || !path.size) {\n        return null;\n      }\n\n      var furthest = this.nodes.get(path.first());\n      return furthest;\n    }\n    /**\n     * Get the furthest inline parent of a node.\n     *\n     * @param {Path} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthestInline',\n    value: function getFurthestInline(path) {\n      var furthest = this.getFurthest(path, function (n) {\n        return n.object === 'inline';\n      });\n      return furthest;\n    }\n    /**\n     * Get the closest inline nodes for each text node in the node.\n     *\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getInlines',\n    value: function getInlines() {\n      var iterable = this.inlines({\n        onlyLeaves: true\n      });\n      var array = Array.from(iterable, function (_ref18) {\n        var _ref19 = slicedToArray(_ref18, 1),\n            node = _ref19[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get all of the leaf inline nodes that match a `type`.\n     *\n     * @param {String} type\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getInlinesByType',\n    value: function getInlinesByType(type) {\n      var iterable = this.inlines({\n        onlyLeaves: true,\n        onlyTypes: [type]\n      });\n      var array = Array.from(iterable, function (_ref20) {\n        var _ref21 = slicedToArray(_ref20, 1),\n            node = _ref21[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get a set of marks that would occur on the next insert at a `point` in the\n     * node. This mimics expected rich text editing behaviors of mark contiuation.\n     *\n     * @param {Point} point\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getInsertMarksAtPoint',\n    value: function getInsertMarksAtPoint(point) {\n      point = this.resolvePoint(point);\n      var _point = point,\n          path = _point.path,\n          offset = _point.offset;\n      var text = this.getDescendant(path); // PERF: we can exit early if the offset isn't at the start of the node.\n\n      if (offset !== 0) {\n        return text.marks;\n      }\n\n      var blockNode = void 0;\n      var blockPath = void 0;\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = this.ancestors(path)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var entry = _step6.value;\n\n          var _entry = slicedToArray(entry, 2),\n              n = _entry[0],\n              p = _entry[1];\n\n          if (n.object === 'block') {\n            blockNode = n;\n            blockPath = p;\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      var relativePath = PathUtils.drop(path, blockPath.size);\n\n      var _blockNode$texts = blockNode.texts({\n        path: relativePath,\n        direction: 'backward'\n      }),\n          _blockNode$texts2 = slicedToArray(_blockNode$texts, 1),\n          previous = _blockNode$texts2[0]; // If there's no previous text, we're at the start of the block, so use\n      // the current text nodes marks.\n\n\n      if (!previous) {\n        return text.marks;\n      } // Otherwise, continue with the previous text node's marks instead.\n\n\n      var _previous = slicedToArray(previous, 1),\n          previousText = _previous[0];\n\n      return previousText.marks;\n    }\n    /**\n     * Get a set of marks that would occur on the next insert at a `range`.\n     * This mimics expected rich text editing behaviors of mark contiuation.\n     *\n     * @param {Range} range\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getInsertMarksAtRange',\n    value: function getInsertMarksAtRange(range) {\n      range = this.resolveRange(range);\n      var _range4 = range,\n          start = _range4.start;\n\n      if (range.isUnset) {\n        return Set();\n      }\n\n      if (range.isCollapsed) {\n        return this.getInsertMarksAtPoint(start);\n      }\n\n      var text = this.getDescendant(start.path);\n      return text.marks;\n    }\n    /**\n     * Get the bottom-most block descendants in a `range`.\n     *\n     * @param {Range} range\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getLeafBlocksAtRange',\n    value: function getLeafBlocksAtRange(range) {\n      var iterable = this.blocks({\n        range: range,\n        onlyLeaves: true\n      });\n      var array = Array.from(iterable, function (_ref22) {\n        var _ref23 = slicedToArray(_ref22, 1),\n            node = _ref23[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get the bottom-most inline nodes for each text node in a `range`.\n     *\n     * @param {Range} range\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getLeafInlinesAtRange',\n    value: function getLeafInlinesAtRange(range) {\n      var iterable = this.inlines({\n        range: range,\n        onlyLeaves: true\n      });\n      var array = Array.from(iterable, function (_ref24) {\n        var _ref25 = slicedToArray(_ref24, 1),\n            node = _ref25[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get an object mapping all the keys in the node to their paths.\n     *\n     * @return {Map}\n     */\n\n  }, {\n    key: 'getNodesToPathsMap',\n    value: function getNodesToPathsMap() {\n      var root = this;\n      var map = typeof window === 'undefined' ? new global$1.Map() : new window.Map();\n      map.set(root, PathUtils.create([]));\n      root.forEachDescendant(function (node, path) {\n        map.set(node, path);\n      });\n      return map;\n    }\n    /**\n     * Get all of the marks for all of the characters of every text node.\n     *\n     * @return {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getMarks',\n    value: function getMarks() {\n      var iterable = this.marks();\n      var array = Array.from(iterable, function (_ref26) {\n        var _ref27 = slicedToArray(_ref26, 1),\n            mark = _ref27[0];\n\n        return mark;\n      });\n      return OrderedSet(array);\n    }\n    /**\n     * Get a set of the marks in a `range`.\n     *\n     * @param {Range} range\n     * @return {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getMarksAtRange',\n    value: function getMarksAtRange(range) {\n      var iterable = this.marks({\n        range: range\n      });\n      var array = Array.from(iterable, function (_ref28) {\n        var _ref29 = slicedToArray(_ref28, 1),\n            mark = _ref29[0];\n\n        return mark;\n      });\n      return OrderedSet(array);\n    }\n    /**\n     * Get all of the marks that match a `type`.\n     *\n     * @param {String} type\n     * @return {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getMarksByType',\n    value: function getMarksByType(type) {\n      var iterable = this.marks({\n        onlyTypes: [type]\n      });\n      var array = Array.from(iterable, function (_ref30) {\n        var _ref31 = slicedToArray(_ref30, 1),\n            mark = _ref31[0];\n\n        return mark;\n      });\n      return OrderedSet(array);\n    }\n    /**\n     * Get the block node after a descendant text node by `path`.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNextBlock',\n    value: function getNextBlock(path) {\n      var _blocks = this.blocks({\n        path: path,\n        onlyLeaves: true\n      }),\n          _blocks2 = slicedToArray(_blocks, 1),\n          entry = _blocks2[0];\n\n      var block = entry ? entry[0] : null;\n      return block;\n    }\n    /**\n     * Get the next node in the tree, returning siblings or ancestor siblings.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNextNode',\n    value: function getNextNode(path) {\n      var iterable = this.createIterable({\n        path: path,\n        downward: false\n      });\n\n      var _iterable = slicedToArray(iterable, 1),\n          entry = _iterable[0];\n\n      var node = entry ? entry[0] : null;\n      return node;\n    }\n    /**\n     * Get the next sibling of a node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNextSibling',\n    value: function getNextSibling(path) {\n      var _siblings = this.siblings(path),\n          _siblings2 = slicedToArray(_siblings, 1),\n          entry = _siblings2[0];\n\n      var node = entry ? entry[0] : null;\n      return node;\n    }\n    /**\n     * Get the text node after a descendant text node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNextText',\n    value: function getNextText(path) {\n      var _texts9 = this.texts({\n        path: path\n      }),\n          _texts10 = slicedToArray(_texts9, 1),\n          entry = _texts10[0];\n\n      var node = entry ? entry[0] : null;\n      return node;\n    }\n    /**\n     * Get the offset for a descendant text node by `path` or `key`.\n     *\n     * @param {List|string} path\n     * @return {Number}\n     */\n\n  }, {\n    key: 'getOffset',\n    value: function getOffset(path) {\n      path = this.resolvePath(path);\n      this.assertDescendant(path); // Calculate the offset of the nodes before the highest child.\n\n      var index = path.first();\n      var offset = this.nodes.slice(0, index).reduce(function (memo, n) {\n        return memo + n.text.length;\n      }, 0); // Recurse if need be.\n\n      var ret = path.size === 1 ? offset : offset + this.nodes.get(index).getOffset(PathUtils.drop(path));\n      return ret;\n    }\n    /**\n     * Get the offset from a `range`.\n     *\n     * @param {Range} range\n     * @return {Number}\n     */\n\n  }, {\n    key: 'getOffsetAtRange',\n    value: function getOffsetAtRange(range) {\n      range = this.resolveRange(range);\n\n      if (range.isUnset) {\n        throw new Error('The range cannot be unset to calculcate its offset.');\n      }\n\n      if (range.isExpanded) {\n        throw new Error('The range must be collapsed to calculcate its offset.');\n      }\n\n      var _range5 = range,\n          start = _range5.start;\n      var offset = this.getOffset(start.path) + start.offset;\n      return offset;\n    }\n    /**\n     * Get the parent of a descendant node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getParent',\n    value: function getParent(path) {\n      path = this.resolvePath(path);\n      if (!path) return null;\n      if (!path.size) return null;\n      var parentPath = PathUtils.lift(path);\n      var parent = this.getNode(parentPath);\n      return parent;\n    }\n    /**\n     * Get the block node before a descendant text node by `path`.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getPreviousBlock',\n    value: function getPreviousBlock(path) {\n      var _blocks3 = this.blocks({\n        path: path,\n        onlyLeaves: true,\n        direction: 'backward'\n      }),\n          _blocks4 = slicedToArray(_blocks3, 1),\n          entry = _blocks4[0];\n\n      var block = entry ? entry[0] : null;\n      return block;\n    }\n    /**\n     * Get the previous node from a node in the tree.\n     *\n     * This will not only check for siblings but instead move up the tree\n     * returning the previous ancestor if no sibling is found.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getPreviousNode',\n    value: function getPreviousNode(path) {\n      var iterable = this.createIterable({\n        path: path,\n        downward: false,\n        direction: 'backward'\n      });\n\n      var _iterable2 = slicedToArray(iterable, 1),\n          entry = _iterable2[0];\n\n      var node = entry ? entry[0] : null;\n      return node;\n    }\n    /**\n     * Get the previous sibling of a node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getPreviousSibling',\n    value: function getPreviousSibling(path) {\n      var _siblings3 = this.siblings(path, {\n        direction: 'backward'\n      }),\n          _siblings4 = slicedToArray(_siblings3, 1),\n          entry = _siblings4[0];\n\n      var node = entry ? entry[0] : null;\n      return node;\n    }\n    /**\n     * Get the text node before a descendant text node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getPreviousText',\n    value: function getPreviousText(path) {\n      var _texts11 = this.texts({\n        path: path,\n        direction: 'backward'\n      }),\n          _texts12 = slicedToArray(_texts11, 1),\n          entry = _texts12[0];\n\n      var node = entry ? entry[0] : null;\n      return node;\n    }\n    /**\n     * Get only the root block nodes in a `range`.\n     *\n     * @param {Range} range\n     * @return {List}\n     */\n\n  }, {\n    key: 'getRootBlocksAtRange',\n    value: function getRootBlocksAtRange(range) {\n      var iterable = this.blocks({\n        range: range,\n        onlyRoots: true\n      });\n      var array = Array.from(iterable, function (_ref32) {\n        var _ref33 = slicedToArray(_ref32, 1),\n            node = _ref33[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get only the root inline nodes in a `range`.\n     *\n     * @param {Range} range\n     * @return {List}\n     */\n\n  }, {\n    key: 'getRootInlinesAtRange',\n    value: function getRootInlinesAtRange(range) {\n      var iterable = this.inlines({\n        range: range,\n        onlyRoots: true\n      });\n      var array = Array.from(iterable, function (_ref34) {\n        var _ref35 = slicedToArray(_ref34, 1),\n            node = _ref35[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get the descendent text node at an `offset`.\n     *\n     * @param {String} offset\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getTextAtOffset',\n    value: function getTextAtOffset(offset) {\n      // PERF: Add a few shortcuts for the obvious cases.\n      if (offset === 0) return this.getFirstText();\n      if (offset === this.text.length) return this.getLastText();\n      if (offset < 0 || offset > this.text.length) return null;\n      var length = 0;\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = this.texts()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var _ref36 = _step7.value;\n\n          var _ref37 = slicedToArray(_ref36, 1);\n\n          var node = _ref37[0];\n          length += node.text.length;\n\n          if (length > offset) {\n            return node;\n          }\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Get the direction of the node's text.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'getTextDirection',\n    value: function getTextDirection() {\n      var dir = getDirection(this.text);\n      return dir === 'neutral' ? null : dir;\n    }\n    /**\n     * Recursively get all of the child text nodes in order of appearance.\n     *\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getTexts',\n    value: function getTexts() {\n      var iterable = this.texts();\n      var array = Array.from(iterable, function (_ref38) {\n        var _ref39 = slicedToArray(_ref38, 1),\n            node = _ref39[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get all of the text nodes in a `range` as a List.\n     *\n     * @param {Range} range\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getTextsAtRange',\n    value: function getTextsAtRange(range) {\n      var iterable = this.texts({\n        range: range\n      });\n      var array = Array.from(iterable, function (_ref40) {\n        var _ref41 = slicedToArray(_ref40, 1),\n            node = _ref41[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Check if the node has block children.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasBlockChildren',\n    value: function hasBlockChildren() {\n      return !!(this.nodes && this.nodes.find(function (n) {\n        return n.object === 'block';\n      }));\n    }\n    /**\n     * Check if a child node exists.\n     *\n     * @param {List|String} path\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasChild',\n    value: function hasChild(path) {\n      var child = this.getChild(path);\n      return !!child;\n    }\n    /**\n     * Check if a node has inline children.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasInlineChildren',\n    value: function hasInlineChildren() {\n      return !!(this.nodes && this.nodes.find(function (n) {\n        return n.object === 'inline' || n.object === 'text';\n      }));\n    }\n    /**\n     * Recursively check if a child node exists.\n     *\n     * @param {List|String} path\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasDescendant',\n    value: function hasDescendant(path) {\n      var descendant = this.getDescendant(path);\n      return !!descendant;\n    }\n    /**\n     * Check if a node has a void parent.\n     *\n     * @param {List|String} path\n     * @param {Editor} editor\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasVoidParent',\n    value: function hasVoidParent(path, editor) {\n      invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `node.hasVoidParent` method takes an `editor` instead of a `value`.');\n      var closest = this.getClosestVoid(path, editor);\n      return !!closest;\n    }\n    /**\n     * Create an iteratable for all of the inlines of a node with `options`.\n     *\n     * @param {Options}\n     * @return {Iterable}\n     */\n\n  }, {\n    key: 'inlines',\n    value: function inlines() {\n      var _this = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var onlyLeaves = options.onlyLeaves,\n          onlyRoots = options.onlyRoots,\n          onlyTypes = options.onlyTypes,\n          _match2 = options.match,\n          rest = objectWithoutProperties(options, ['onlyLeaves', 'onlyRoots', 'onlyTypes', 'match']);\n      var iterable = this.descendants(_extends({\n        includeBlocks: false,\n        includeTexts: false,\n        includeDocument: false\n      }, rest, {\n        match: function match(node, path) {\n          if (onlyTypes && !onlyTypes.includes(node.type)) {\n            return false;\n          } else if (onlyLeaves && !node.isLeafInline()) {\n            return false;\n          } else if (onlyRoots && _this.getParent(path).object !== 'block') {\n            return false;\n          } else if (_match2 && !_match2(node, path)) {\n            return false;\n          } else {\n            return true;\n          }\n        }\n      }));\n      return iterable;\n    }\n    /**\n     * Insert a `node`.\n     *\n     * @param {List|String} path\n     * @param {Node} node\n     * @return {Node}\n     */\n\n  }, {\n    key: 'insertNode',\n    value: function insertNode(path, node) {\n      path = this.resolvePath(path);\n      var index = path.last();\n      var parentPath = PathUtils.lift(path);\n      var parent = this.assertNode(parentPath);\n      var nodes = parent.nodes.splice(index, 0, node);\n      parent = parent.set('nodes', nodes);\n      var ret = this.replaceNode(parentPath, parent);\n      return ret;\n    }\n    /**\n     * Insert `text` at `offset` in node by `path`.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @param {String} text\n     * @return {Node}\n     */\n\n  }, {\n    key: 'insertText',\n    value: function insertText(path, offset, text) {\n      path = this.resolvePath(path);\n      var node = this.assertDescendant(path);\n      node = node.insertText(offset, text);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n    /**\n     * Check whether the node is a leaf block.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isLeafBlock',\n    value: function isLeafBlock() {\n      if (this.object !== 'block') {\n        return false;\n      }\n\n      if (this.nodes.some(function (n) {\n        return n.object === 'block';\n      })) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Check whether the node is a leaf inline.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isLeafInline',\n    value: function isLeafInline() {\n      if (this.object !== 'inline') {\n        return false;\n      }\n\n      if (this.nodes.some(function (n) {\n        return n.object === 'inline';\n      })) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Check whether a descendant node is inside a `range` by `path`.\n     *\n     * @param {List|String} path\n     * @param {Range} range\n     * @return {Node}\n     */\n\n  }, {\n    key: 'isInRange',\n    value: function isInRange(path, range) {\n      path = this.resolvePath(path);\n      range = this.resolveRange(range);\n\n      if (range.isUnset) {\n        return false;\n      }\n\n      var toStart = PathUtils.compare(path, range.start.path);\n      var toEnd = PathUtils.compare(path, range.end.path);\n      var isInRange = toStart !== -1 && toEnd !== 1;\n      return isInRange;\n    }\n    /**\n     * Map all child nodes, updating them in their parents. This method is\n     * optimized to not return a new node if no changes are made.\n     *\n     * @param {Function} predicate\n     * @return {Node}\n     */\n\n  }, {\n    key: 'mapChildren',\n    value: function mapChildren() {\n      var _this2 = this;\n\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\n      var nodes = this.nodes;\n      nodes.forEach(function (node, i) {\n        var ret = predicate(node, i, _this2.nodes);\n        if (ret !== node) nodes = nodes.set(ret.key, ret);\n      });\n      var ret = this.set('nodes', nodes);\n      return ret;\n    }\n    /**\n     * Map all descendant nodes, updating them in their parents. This method is\n     * optimized to not return a new node if no changes are made.\n     *\n     * @param {Function} predicate\n     * @return {Node}\n     */\n\n  }, {\n    key: 'mapDescendants',\n    value: function mapDescendants() {\n      var _this3 = this;\n\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\n      var nodes = this.nodes;\n      nodes.forEach(function (node, index) {\n        var ret = node;\n        if (ret.object !== 'text') ret = ret.mapDescendants(predicate);\n        ret = predicate(ret, index, _this3.nodes);\n        if (ret === node) return;\n        nodes = nodes.set(index, ret);\n      });\n      var ret = this.set('nodes', nodes);\n      return ret;\n    }\n    /**\n     * Create an iteratable for all the marks in text nodes with `options`.\n     *\n     * @param {Options}\n     * @return {Iterable}\n     */\n\n  }, {\n    key: 'marks',\n    value: function marks() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _options$onlyTypes = options.onlyTypes,\n          onlyTypes = _options$onlyTypes === undefined ? null : _options$onlyTypes,\n          match = options.match,\n          rest = objectWithoutProperties(options, ['onlyTypes', 'match']);\n      var texts = this.texts(rest);\n      return defineProperty({}, Symbol.iterator, function () {\n        var iterator = texts[Symbol.iterator]();\n        var node = null;\n        var path = null;\n        var remaining = [];\n\n        var next = function next() {\n          if (remaining.length) {\n            var mark = remaining.shift();\n\n            if (onlyTypes && !onlyTypes.includes(mark.type)) {\n              return next();\n            } else if (match && !match(mark, node, path)) {\n              return next();\n            }\n\n            return {\n              value: [mark, node, path],\n              done: false\n            };\n          }\n\n          var _iterator$next = iterator.next(),\n              value = _iterator$next.value,\n              done = _iterator$next.done;\n\n          if (done) {\n            return {\n              done: true\n            };\n          }\n\n          var _value = slicedToArray(value, 2);\n\n          node = _value[0];\n          path = _value[1];\n          remaining = node.marks.toArray();\n          return next();\n        };\n\n        return {\n          next: next\n        };\n      });\n    }\n    /**\n     * Merge a node backwards its previous sibling.\n     *\n     * @param {List|Key} path\n     * @return {Node}\n     */\n\n  }, {\n    key: 'mergeNode',\n    value: function mergeNode(path) {\n      var b = this.assertNode(path);\n      path = this.resolvePath(path);\n\n      if (path.last() === 0) {\n        throw new Error('Unable to merge node because it has no previous sibling: ' + b);\n      }\n\n      var withPath = PathUtils.decrement(path);\n      var a = this.assertNode(withPath);\n\n      if (a.object !== b.object) {\n        throw new Error('Unable to merge two different kinds of nodes: ' + a + ' and ' + b);\n      }\n\n      var newNode = a.object === 'text' ? a.mergeText(b) : a.set('nodes', a.nodes.concat(b.nodes));\n      var ret = this;\n      ret = ret.removeNode(path);\n      ret = ret.removeNode(withPath);\n      ret = ret.insertNode(withPath, newNode);\n      return ret;\n    }\n    /**\n     * Move a node by `path` to `newPath`.\n     *\n     * A `newIndex` can be provided when move nodes by `key`, to account for not\n     * being able to have a key for a location in the tree that doesn't exist yet.\n     *\n     * @param {List|Key} path\n     * @param {List|Key} newPath\n     * @param {Number} newIndex\n     * @return {Node}\n     */\n\n  }, {\n    key: 'moveNode',\n    value: function moveNode(path, newPath) {\n      var newIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var node = this.assertNode(path);\n      path = this.resolvePath(path);\n      newPath = this.resolvePath(newPath, newIndex);\n      var newParentPath = PathUtils.lift(newPath);\n      this.assertNode(newParentPath); // TODO: this is a bit hacky, re-creating the operation that led to this method being called\n      // Alternative 1: pass the operation through from apply -> value.moveNode\n      // Alternative 2: add a third property to the operation called \"transformedNewPath\", pass that through\n\n      var op = Operation.create({\n        type: 'move_node',\n        path: path,\n        newPath: newPath\n      });\n      newPath = PathUtils.transform(path, op).first();\n      var ret = this;\n      ret = ret.removeNode(path);\n      ret = ret.insertNode(newPath, node);\n      return ret;\n    }\n    /**\n     * Remove `mark` from text at `path`.\n     *\n     * @param {List} path\n     * @param {Mark} mark\n     * @return {Node}\n     */\n\n  }, {\n    key: 'removeMark',\n    value: function removeMark(path, mark) {\n      path = this.resolvePath(path);\n      var node = this.assertDescendant(path);\n      node = node.removeMark(mark);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n    /**\n     * Remove a node.\n     *\n     * @param {List|String} path\n     * @return {Node}\n     */\n\n  }, {\n    key: 'removeNode',\n    value: function removeNode(path) {\n      this.assertDescendant(path);\n      path = this.resolvePath(path);\n      var deep = path.flatMap(function (x) {\n        return ['nodes', x];\n      });\n      var ret = this.deleteIn(deep);\n      return ret;\n    }\n    /**\n     * Remove `text` at `offset` in node.\n     *\n     * @param {List|Key} path\n     * @param {Number} offset\n     * @param {String} text\n     * @return {Node}\n     */\n\n  }, {\n    key: 'removeText',\n    value: function removeText(path, offset, text) {\n      var node = this.assertDescendant(path);\n      node = node.removeText(offset, text.length);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n    /**\n     * Replace a `node` in the tree.\n     *\n     * @param {List|Key} path\n     * @param {Node} node\n     * @return {Node}\n     */\n\n  }, {\n    key: 'replaceNode',\n    value: function replaceNode(path, node) {\n      path = this.resolvePath(path);\n\n      if (!path) {\n        throw new Error('Unable to replace a node because it could not be found in the first place: ' + path);\n      }\n\n      if (!path.size) return node;\n      this.assertNode(path);\n      var deep = path.flatMap(function (x) {\n        return ['nodes', x];\n      });\n      var ret = this.setIn(deep, node);\n      return ret;\n    }\n    /**\n     * Resolve a `annotation`, relative to the node, ensuring that the keys and\n     * offsets in the annotation exist and that they are synced with the paths.\n     *\n     * @param {Annotation|Object} annotation\n     * @return {Annotation}\n     */\n\n  }, {\n    key: 'resolveAnnotation',\n    value: function resolveAnnotation(annotation) {\n      annotation = Annotation.create(annotation);\n      annotation = annotation.normalize(this);\n      return annotation;\n    }\n    /**\n     * Resolve a `decoration`, relative to the node, ensuring that the keys and\n     * offsets in the decoration exist and that they are synced with the paths.\n     *\n     * @param {Decoration|Object} decoration\n     * @return {Decoration}\n     */\n\n  }, {\n    key: 'resolveDecoration',\n    value: function resolveDecoration(decoration) {\n      decoration = Decoration.create(decoration);\n      decoration = decoration.normalize(this);\n      return decoration;\n    }\n    /**\n     * Resolve a `point`, relative to the node, ensuring that the keys and\n     * offsets in the point exist and that they are synced with the paths.\n     *\n     * @param {Point|Object} point\n     * @return {Point}\n     */\n\n  }, {\n    key: 'resolvePoint',\n    value: function resolvePoint(point) {\n      point = Point.create(point);\n      point = point.normalize(this);\n      return point;\n    }\n    /**\n     * Resolve a `range`, relative to the node, ensuring that the keys and\n     * offsets in the range exist and that they are synced with the paths.\n     *\n     * @param {Range|Object} range\n     * @return {Range}\n     */\n\n  }, {\n    key: 'resolveRange',\n    value: function resolveRange(range) {\n      range = Range.create(range);\n      range = range.normalize(this);\n      return range;\n    }\n    /**\n     * Resolve a `selection`, relative to the node, ensuring that the keys and\n     * offsets in the selection exist and that they are synced with the paths.\n     *\n     * @param {Selection|Object} selection\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'resolveSelection',\n    value: function resolveSelection(selection) {\n      selection = Selection.create(selection);\n      selection = selection.normalize(this);\n      return selection;\n    }\n    /**\n     * Set `properties` on a node.\n     *\n     * @param {List|String} path\n     * @param {Object} properties\n     * @return {Node}\n     */\n\n  }, {\n    key: 'setNode',\n    value: function setNode(path, properties) {\n      var node = this.assertNode(path);\n      node = node.merge(properties);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n    /**\n     * Set `properties` on `mark` on text at `offset` and `length` in node.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @param {Number} length\n     * @param {Mark} mark\n     * @param {Object} properties\n     * @return {Node}\n     */\n\n  }, {\n    key: 'setMark',\n    value: function setMark(path, properties, newProperties) {\n      path = this.resolvePath(path);\n      var node = this.assertDescendant(path);\n      node = node.setMark(properties, newProperties);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n    /**\n     * Create an iteratable for the siblings in the tree at `path`.\n     *\n     * @param {List|Array} path\n     * @return {Iterable}\n     */\n\n  }, {\n    key: 'siblings',\n    value: function siblings(path, options) {\n      var iterable = this.createIterable(_extends({\n        path: path,\n        upward: false,\n        downward: false\n      }, options));\n      return iterable;\n    }\n    /**\n     * Split a node by `path` at `position` with optional `properties` to apply\n     * to the newly split node.\n     *\n     * @param {List|String} path\n     * @param {Number} position\n     * @param {Object} properties\n     * @return {Node}\n     */\n\n  }, {\n    key: 'splitNode',\n    value: function splitNode(path, position, properties) {\n      var child = this.assertNode(path);\n      path = this.resolvePath(path);\n      var a = void 0;\n      var b = void 0;\n\n      if (child.object === 'text') {\n        var _child$splitText = child.splitText(position);\n\n        var _child$splitText2 = slicedToArray(_child$splitText, 2);\n\n        a = _child$splitText2[0];\n        b = _child$splitText2[1];\n      } else {\n        var befores = child.nodes.take(position);\n        var afters = child.nodes.skip(position);\n        a = child.set('nodes', befores);\n        b = child.set('nodes', afters).regenerateKey();\n      }\n\n      if (properties && child.object !== 'text') {\n        b = b.merge(properties);\n      }\n\n      var ret = this;\n      ret = ret.removeNode(path);\n      ret = ret.insertNode(path, b);\n      ret = ret.insertNode(path, a);\n      return ret;\n    }\n    /**\n     * Create an iteratable for all the text node descendants.\n     *\n     * @param {Object} options\n     * @return {Iterable}\n     */\n\n  }, {\n    key: 'texts',\n    value: function texts(options) {\n      var iterable = this.descendants(_extends({\n        includeBlocks: false,\n        includeInlines: false,\n        includeDocument: false\n      }, options));\n      return iterable;\n    }\n    /**\n     * Deprecated.\n     */\n\n  }, {\n    key: 'getBlocksAtRange',\n    value: function getBlocksAtRange(range) {\n      warning(false, 'As of slate@0.44 the `node.getBlocksAtRange` method has been renamed to `getLeafBlocksAtRange`.');\n      return this.getLeafBlocksAtRange(range);\n    }\n  }, {\n    key: 'getBlocksAtRangeAsArray',\n    value: function getBlocksAtRangeAsArray(range) {\n      warning(false, 'As of slate@0.44 the `node.getBlocksAtRangeAsArray` method has been renamed to `getLeafBlocksAtRangeAsArray`.');\n      return this.getLeafBlocksAtRangeAsArray(range);\n    }\n  }, {\n    key: 'getInlinesAtRange',\n    value: function getInlinesAtRange(range) {\n      warning(false, 'As of slate@0.44 the `node.getInlinesAtRange` method has been renamed to `getLeafInlinesAtRange`.');\n      return this.getLeafInlinesAtRange(range);\n    }\n  }, {\n    key: 'getInlinesAtRangeAsArray',\n    value: function getInlinesAtRangeAsArray(range) {\n      warning(false, 'As of slate@0.44 the `node.getInlinesAtRangeAsArray` method has been renamed to `getLeafInlinesAtRangeAsArray`.');\n      return this.getLeafInlinesAtRangeAsArray(range);\n    }\n  }, {\n    key: 'getNextTextAndPath',\n    value: function getNextTextAndPath(path) {\n      warning(false, 'As of slate@0.47, the `getNextTextAndPath` method has been renamed to `getNextTextEntry`.');\n      return this.getNextTextEntry(path);\n    }\n  }, {\n    key: 'getNextDeepMatchingNodeAndPath',\n    value: function getNextDeepMatchingNodeAndPath(path) {\n      var iterator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n      warning(false, 'As of slate@0.47, the `getNextDeepMatchingNodeAndPath` method is deprecated.');\n      var match = this.getNextMatchingNodeAndPath(path);\n      if (!match) return null;\n\n      var _match3 = slicedToArray(match, 2),\n          nextNode = _match3[0],\n          nextPath = _match3[1];\n\n      var childMatch = void 0;\n\n      var assign = function assign() {\n        childMatch = nextNode.object !== 'text' && nextNode.findFirstDescendantAndPath(iterator, nextPath);\n        return childMatch;\n      };\n\n      while (assign(childMatch)) {\n        var _childMatch = childMatch;\n\n        var _childMatch2 = slicedToArray(_childMatch, 2);\n\n        nextNode = _childMatch2[0];\n        nextPath = _childMatch2[1];\n      }\n\n      if (!nextNode) return null;\n      return iterator(nextNode) ? [nextNode, nextPath] : this.getNextDeepMatchingNodeAndPath(match[1], iterator);\n    }\n  }, {\n    key: 'getPreviousTextAndPath',\n    value: function getPreviousTextAndPath(path) {\n      warning(false, 'As of slate@0.47, the `getPreviousTextAndPath` method has been renamed to `getPreviousTextEntry`.');\n      return this.getPreviousTextEntry(path);\n    }\n  }, {\n    key: 'findFirstDescendantAndPath',\n    value: function findFirstDescendantAndPath(iterator, pathToThisNode) {\n      warning(false, 'As of slate@0.47, the `findFirstDescendantAndPath` method is deprecated.');\n      return this.findDescendantAndPath(iterator, pathToThisNode, false);\n    }\n  }, {\n    key: 'getPreviousMatchingNodeAndPath',\n    value: function getPreviousMatchingNodeAndPath(path) {\n      var iterator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n      warning(false, 'As of slate@0.47, the `getPreviousMatchingNodeAndPath` method is deprecated.');\n      if (!path) return null;\n\n      for (var i = path.size; i > 0; i--) {\n        var p = path.slice(0, i);\n        if (p.last() === 0) continue;\n        var previousPath = PathUtils.decrement(p);\n        var previousNode = this.getNode(previousPath);\n\n        while (previousNode && !iterator(previousNode)) {\n          previousPath = PathUtils.decrement(previousPath);\n          previousNode = this.getNode(previousPath);\n        }\n\n        if (previousNode) return [previousNode, previousPath];\n      }\n\n      return null;\n    }\n  }, {\n    key: 'getPreviousDeepMatchingNodeAndPath',\n    value: function getPreviousDeepMatchingNodeAndPath(path) {\n      var iterator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n      warning(false, 'As of slate@0.47, the `getPreviousDeepMatchingNodeAndPath` method is deprecated.');\n      var match = this.getPreviousMatchingNodeAndPath(path);\n      if (!match) return null;\n\n      var _match4 = slicedToArray(match, 2),\n          previousNode = _match4[0],\n          previousPath = _match4[1];\n\n      var childMatch = void 0;\n\n      var assign = function assign() {\n        childMatch = previousNode.object !== 'text' && previousNode.findLastDescendantAndPath(iterator, previousPath);\n        return childMatch;\n      };\n\n      while (assign(childMatch)) {\n        var _childMatch3 = childMatch;\n\n        var _childMatch4 = slicedToArray(_childMatch3, 2);\n\n        previousNode = _childMatch4[0];\n        previousPath = _childMatch4[1];\n      }\n\n      if (!previousNode) return null;\n      return iterator(previousNode) ? [previousNode, previousPath] : this.getPreviousDeepMatchingNodeAndPath(match[1], iterator);\n    }\n  }, {\n    key: 'findLastDescendantAndPath',\n    value: function findLastDescendantAndPath(iterator, pathToThisNode) {\n      warning(false, 'As of slate@0.47, the `findLastDescendantAndPath` method is deprecated.');\n      return this.findDescendantAndPath(iterator, pathToThisNode, true);\n    }\n  }, {\n    key: 'findDescendantAndPath',\n    value: function findDescendantAndPath(iterator) {\n      var pathToThisNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PathUtils.create([]);\n      var findLast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      warning(false, 'As of slate@0.47, the `findDescendantAndPath` method is deprecated.');\n      var found = void 0;\n      var foundPath = void 0;\n      this.forEachDescendantWithPath(function (node, path, nodes) {\n        if (iterator(node, path, nodes)) {\n          found = node;\n          foundPath = path;\n          return false;\n        }\n      }, pathToThisNode, findLast);\n      return found ? [found, foundPath] : null;\n    }\n  }, {\n    key: 'forEachDescendantWithPath',\n    value: function forEachDescendantWithPath(iterator) {\n      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PathUtils.create([]);\n      var findLast = arguments[2];\n      warning(false, 'As of slate@0.47, the `forEachDescendantWithPath` method is deprecated.');\n      var nodes = this.nodes;\n      var ret = void 0;\n      if (findLast) nodes = nodes.reverse();\n      nodes.forEach(function (child, i) {\n        var childPath = path.concat(i);\n\n        if (iterator(child, childPath, nodes) === false) {\n          ret = false;\n          return false;\n        }\n\n        if (child.object !== 'text') {\n          ret = child.forEachDescendantWithPath(iterator, childPath, findLast);\n          return ret;\n        }\n      });\n      return ret;\n    }\n  }, {\n    key: 'getNextMatchingNodeAndPath',\n    value: function getNextMatchingNodeAndPath(path) {\n      var iterator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n      warning(false, 'As of slate@0.47, the `getNextMatchingNodeAndPath` method is deprecated.');\n      if (!path) return null;\n\n      for (var i = path.size; i > 0; i--) {\n        var p = path.slice(0, i);\n        var nextPath = PathUtils.increment(p);\n        var nextNode = this.getNode(nextPath);\n\n        while (nextNode && !iterator(nextNode)) {\n          nextPath = PathUtils.increment(nextPath);\n          nextNode = this.getNode(nextPath);\n        }\n\n        if (nextNode) return [nextNode, nextPath];\n      }\n\n      return null;\n    }\n  }, {\n    key: 'getSelectionIndexes',\n    value: function getSelectionIndexes(range) {\n      var isSelected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      warning(false, 'As of slate@0.47, the `getSelectionIndexes` method is deprecated.');\n      var start = range.start,\n          end = range.end; // PERF: if we're not selected, we can exit early.\n\n      if (!isSelected) {\n        return null;\n      } // PERF: if we've been given an invalid selection we can exit early.\n\n\n      if (range.isUnset) {\n        return null;\n      } // PERF: if the start and end keys are the same, just check for the child\n      // that contains that single key.\n\n\n      if (start.path.equals(end.path)) {\n        var child = this.getFurthestAncestor(start.path);\n        var index = child ? this.nodes.indexOf(child) : null;\n        return {\n          start: index,\n          end: index + 1\n        };\n      } // Otherwise, check all of the children...\n\n\n      var startIndex = null;\n      var endIndex = null;\n      this.nodes.forEach(function (child, i) {\n        if (child.object === 'text') {\n          if (startIndex == null && child.key === start.key) startIndex = i;\n          if (endIndex == null && child.key === end.key) endIndex = i + 1;\n        } else {\n          if (startIndex == null && child.hasDescendant(start.key)) startIndex = i;\n          if (endIndex == null && child.hasDescendant(end.key)) endIndex = i + 1;\n        } // PERF: exit early if both start and end have been found.\n\n\n        return startIndex == null || endIndex == null;\n      });\n\n      if (isSelected && startIndex == null) {\n        startIndex = 0;\n      }\n\n      if (isSelected && endIndex == null) {\n        endIndex = this.nodes.size;\n      }\n\n      if (startIndex == null) {\n        return null;\n      }\n\n      return {\n        start: startIndex,\n        end: endIndex\n      };\n    }\n  }, {\n    key: 'getTextsBetweenPositionsAsArray',\n    value: function getTextsBetweenPositionsAsArray(startPath, endPath) {\n      warning(false, 'As of slate@0.47, the `getTextsBetweenPositionsAsArray` method is deprecated.');\n      startPath = this.resolvePath(startPath);\n      endPath = this.resolvePath(endPath);\n      return this.getTextsBetweenPathPositionsAsArray(startPath, endPath);\n    }\n  }, {\n    key: 'getOrderedMarksBetweenPositions',\n    value: function getOrderedMarksBetweenPositions(startPath, startOffset, endPath, endOffset) {\n      warning(false, 'As of slate@0.47, the `getOrderedMarksBetweenPositions` method is deprecated.');\n      startPath = this.resolvePath(startPath);\n      endPath = this.resolvePath(endPath);\n      var startText = this.getDescendant(startPath); // PERF: if the paths are equal, we can just use the start.\n\n      if (PathUtils.isEqual(startPath, endPath)) {\n        return startText.marks;\n      }\n\n      var texts = this.getTextsBetweenPathPositionsAsArray(startPath, endPath);\n      return OrderedSet().withMutations(function (result) {\n        texts.forEach(function (text) {\n          result.union(text.marks);\n        });\n      });\n    }\n  }, {\n    key: 'getTextsBetweenPathPositionsAsArray',\n    value: function getTextsBetweenPathPositionsAsArray(startPath, endPath) {\n      warning(false, 'As of slate@0.47, the `getTextsBetweenPathPositionsAsArray` method is deprecated.'); // PERF: the most common case is when the range is in a single text node,\n      // where we can avoid a lot of iterating of the tree.\n\n      if (startPath && endPath && PathUtils.isEqual(startPath, endPath)) {\n        return [this.getDescendant(startPath)];\n      } else if (!startPath && !endPath) {\n        return this.getTextsAsArray();\n      }\n\n      var startIndex = startPath ? startPath.get(0, 0) : 0;\n      var endIndex = endPath ? endPath.get(0, this.nodes.size - 1) : this.nodes.size - 1;\n      var array = [];\n      this.nodes.slice(startIndex, endIndex + 1).forEach(function (node, i) {\n        if (node.object === 'text') {\n          array.push(node);\n        } else {\n          // For the node at start and end of this list, we want to provide a start and end path\n          // For other nodes, we can just get all their text nodes, they are between the paths\n          var childStartPath = startPath && i === 0 ? PathUtils.drop(startPath) : null;\n          var childEndPath = endPath && i === endIndex - startIndex ? PathUtils.drop(endPath) : null;\n          array = array.concat(node.getTextsBetweenPathPositionsAsArray(childStartPath, childEndPath));\n        }\n      });\n      return array;\n    }\n  }, {\n    key: 'getFurthestAncestor',\n    value: function getFurthestAncestor(path) {\n      warning(false, 'As of slate@0.47, the `getFurthestAncestor` method has been renamed to `getFurthestChild`.');\n      return this.getFurthestChild(path);\n    }\n  }, {\n    key: 'getLeafBlocksAtRangeAsArray',\n    value: function getLeafBlocksAtRangeAsArray(range) {\n      warning(false, 'As of slate@0.47, the `getLeafBlocksAtRangeAsArray` method is deprecated.');\n      range = this.resolveRange(range);\n      if (range.isUnset) return [];\n      var _range6 = range,\n          start = _range6.start,\n          end = _range6.end;\n      return this.getLeafBlocksBetweenPathPositionsAsArray(start.path, end.path);\n    }\n  }, {\n    key: 'getLeafBlocksBetweenPathPositionsAsArray',\n    value: function getLeafBlocksBetweenPathPositionsAsArray(startPath, endPath) {\n      warning(false, 'As of slate@0.47, the `getLeafBlocksBetweenPathPositionsAsArray` method is deprecated.'); // PERF: the most common case is when the range is in a single block node,\n      // where we can avoid a lot of iterating of the tree.\n\n      if (startPath && endPath && PathUtils.isEqual(startPath, endPath)) {\n        return [this.getClosestBlock(startPath)];\n      } else if (!startPath && !endPath) {\n        return this.getBlocksAsArray();\n      }\n\n      var startIndex = startPath ? startPath.get(0, 0) : 0;\n      var endIndex = endPath ? endPath.get(0, this.nodes.size - 1) : this.nodes.size - 1;\n      var array = [];\n      this.nodes.slice(startIndex, endIndex + 1).forEach(function (node, i) {\n        if (node.object !== 'block') {\n          return;\n        } else if (node.isLeafBlock()) {\n          array.push(node);\n        } else {\n          var childStartPath = startPath && i === 0 ? PathUtils.drop(startPath) : null;\n          var childEndPath = endPath && i === endIndex - startIndex ? PathUtils.drop(endPath) : null;\n          array = array.concat(node.getLeafBlocksBetweenPathPositionsAsArray(childStartPath, childEndPath));\n        }\n      });\n      return array;\n    }\n  }, {\n    key: 'getBlocksAsArray',\n    value: function getBlocksAsArray() {\n      warning(false, 'As of slate@0.47, the `getBlocksAsArray` method is deprecated.');\n      var iterable = this.blocks({\n        onlyLeaves: true\n      });\n      var array = Array.from(iterable, function (_ref43) {\n        var _ref44 = slicedToArray(_ref43, 1),\n            node = _ref44[0];\n\n        return node;\n      });\n      return array;\n    }\n  }, {\n    key: 'getBlocksByTypeAsArray',\n    value: function getBlocksByTypeAsArray(type) {\n      warning(false, 'As of slate@0.47, the `getBlocksByTypeAsArray` method is deprecated.');\n      var iterable = this.blocks({\n        onlyLeaves: true,\n        onlyTypes: [type]\n      });\n      var array = Array.from(iterable, function (_ref45) {\n        var _ref46 = slicedToArray(_ref45, 1),\n            node = _ref46[0];\n\n        return node;\n      });\n      return array;\n    }\n  }, {\n    key: 'getFurthestOnlyChildAncestor',\n    value: function getFurthestOnlyChildAncestor(path) {\n      warning(false, 'As of slate@0.47, the `getFurthestOnlyChildAncestor` method is deprecated.');\n      var ancestors = this.getAncestors(path);\n      if (!ancestors) return null;\n      var furthest = ancestors.rest().reverse().takeUntil(function (p) {\n        return p.nodes.size > 1;\n      }).last();\n      return furthest || null;\n    }\n  }, {\n    key: 'getInlinesAsArray',\n    value: function getInlinesAsArray() {\n      warning(false, 'As of slate@0.47, the `getInlinesAsArray` method is deprecated.');\n      var array = Array.from(this.inlines({\n        onlyLeaves: true\n      }), function (_ref47) {\n        var _ref48 = slicedToArray(_ref47, 1),\n            node = _ref48[0];\n\n        return node;\n      });\n      return array;\n    }\n  }, {\n    key: 'getInlinesByTypeAsArray',\n    value: function getInlinesByTypeAsArray(type) {\n      warning(false, 'As of slate@0.47, the `getInlinesByTypeAsArray` method is deprecated.');\n      var array = Array.from(this.inlines({\n        onlyLeaves: true,\n        onlyTypes: [type]\n      }), function (_ref49) {\n        var _ref50 = slicedToArray(_ref49, 1),\n            node = _ref50[0];\n\n        return node;\n      });\n      return array;\n    }\n  }, {\n    key: 'getLeafInlinesAtRangeAsArray',\n    value: function getLeafInlinesAtRangeAsArray(range) {\n      var _this4 = this;\n\n      warning(false, 'As of slate@0.47, the `getLeafInlinesAtRangeAsArray` method is deprecated.');\n      range = this.resolveRange(range);\n      if (range.isUnset) return [];\n      var array = this.getTextsAtRangeAsArray(range).map(function (text) {\n        return _this4.getClosestInline(text.key);\n      }).filter(function (exists) {\n        return exists;\n      });\n      return array;\n    }\n  }, {\n    key: 'getOrderedMarks',\n    value: function getOrderedMarks() {\n      warning(false, 'As of slate@0.47, the `getOrderedMarks` method has been folded into `getMarks`, which will now return an ordered set.');\n      return this.getMarks();\n    }\n  }, {\n    key: 'getOrderedMarksAtRange',\n    value: function getOrderedMarksAtRange(range) {\n      warning(false, 'As of slate@0.47, the `getOrderedMarksAtRange` method has been folded into `getMarksAtRange`, which will now return an ordered set.');\n      return this.getMarksAtRange(range);\n    }\n  }, {\n    key: 'getOrderedMarksByType',\n    value: function getOrderedMarksByType(type) {\n      warning(false, 'As of slate@0.47, the `getOrderedMarksByType` method has been folded into `getMarksByType`, which will now return an ordered set.');\n      return this.getMarksByType(type);\n    }\n  }, {\n    key: 'getMarksByTypeAsArray',\n    value: function getMarksByTypeAsArray(type) {\n      warning(false, 'As of slate@0.47, the `getMarksByTypeAsArray` method is deprecated.');\n      var array = this.nodes.reduce(function (memo, node) {\n        return node.object === 'text' ? memo.concat(node.marks.filter(function (m) {\n          return m.type === type;\n        })) : memo.concat(node.getMarksByTypeAsArray(type));\n      }, []);\n      return array;\n    }\n  }, {\n    key: 'getMarksAsArray',\n    value: function getMarksAsArray() {\n      var _ref53;\n\n      warning(false, 'As of slate@0.47, the `getMarksAsArray` method is deprecated.');\n      var result = [];\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = this.texts()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var _ref51 = _step8.value;\n\n          var _ref52 = slicedToArray(_ref51, 1);\n\n          var node = _ref52[0];\n          result.push(node.marks.toArray());\n        } // PERF: use only one concat rather than multiple for speed.\n\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n\n      var array = (_ref53 = []).concat.apply(_ref53, result);\n\n      return array;\n    }\n  }, {\n    key: 'getRootInlinesAtRangeAsArray',\n    value: function getRootInlinesAtRangeAsArray(range) {\n      var _this5 = this;\n\n      warning(false, 'As of slate@0.47, the `getRootInlinesAtRangeAsArray` method is deprecated.');\n      range = this.resolveRange(range);\n      if (range.isUnset) return List();\n      var array = this.getTextsAtRangeAsArray(range).map(function (text) {\n        return _this5.getFurthestInline(text.key);\n      }).filter(function (exists) {\n        return exists;\n      });\n      return array;\n    }\n  }, {\n    key: 'getTextsAsArray',\n    value: function getTextsAsArray() {\n      warning(false, 'As of slate@0.47, the `getTextsAsArray` method is deprecated.');\n      var iterable = this.texts();\n      var array = Array.from(iterable, function (_ref54) {\n        var _ref55 = slicedToArray(_ref54, 1),\n            node = _ref55[0];\n\n        return node;\n      });\n      return array;\n    }\n  }, {\n    key: 'getTextsAtRangeAsArray',\n    value: function getTextsAtRangeAsArray(range) {\n      warning(false, 'As of slate@0.47, the `getTextsAtRangeAsArray` method is deprecated.');\n      var iterable = this.texts({\n        range: range\n      });\n      var array = Array.from(iterable, function (_ref56) {\n        var _ref57 = slicedToArray(_ref56, 1),\n            node = _ref57[0];\n\n        return node;\n      });\n      return array;\n    }\n  }, {\n    key: 'getMarksAtPosition',\n    value: function getMarksAtPosition(path, offset) {\n      warning(false, 'As of slate@0.47, the `getMarksAtPosition` method is deprecated.');\n      path = this.resolvePath(path);\n      var text = this.getDescendant(path);\n      var currentMarks = text.marks;\n\n      if (offset !== 0) {\n        return OrderedSet(currentMarks);\n      }\n\n      var closestBlock = this.getClosestBlock(path); // insert mark for empty block; the empty block are often created by split node or add marks in a range including empty blocks\n\n      if (closestBlock.text === '') {\n        return OrderedSet(currentMarks);\n      }\n\n      var _texts13 = this.texts({\n        path: path,\n        direction: 'backward'\n      }),\n          _texts14 = slicedToArray(_texts13, 1),\n          previous = _texts14[0];\n\n      if (!previous) {\n        return OrderedSet();\n      }\n\n      var _previous2 = slicedToArray(previous, 2),\n          previousText = _previous2[0],\n          previousPath = _previous2[1];\n\n      if (closestBlock.hasDescendant(previousPath)) {\n        return OrderedSet(previousText.marks);\n      }\n\n      return OrderedSet(currentMarks);\n    }\n  }, {\n    key: 'getNodesAtRange',\n    value: function getNodesAtRange(range) {\n      warning(false, 'As of slate@0.47, the `getNodesAtRange` method has been renamed to `getDescendantsAtRange`.');\n      var iterable = this.descendants({\n        range: range\n      });\n      var array = Array.from(iterable, function (_ref58) {\n        var _ref59 = slicedToArray(_ref58, 1),\n            node = _ref59[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n  }, {\n    key: 'isNodeInRange',\n    value: function isNodeInRange(path, range) {\n      warning(false, 'As of slate@0.47, the `isNodeInRange` method has been renamed to `isInRange`.');\n      return this.isInRange(path, range);\n    }\n  }, {\n    key: 'text',\n\n    /**\n     * Get the concatenated text of the node.\n     *\n     * @return {String}\n     */\n    get: function get$$1() {\n      return this.getText();\n    }\n  }]);\n  return ElementInterface;\n}();\n/**\n * Mix in assertion variants.\n */\n\n\nvar ASSERTS = ['Child', 'Depth', 'Descendant', 'Node', 'Parent', 'Path'];\n\nvar _loop$1 = function _loop(method) {\n  ElementInterface.prototype['assert' + method] = function (path) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var ret = this['get' + method].apply(this, [path].concat(args));\n\n    if (ret == null) {\n      throw new Error('`Node.assert' + method + '` could not find node with path or key: ' + path);\n    }\n\n    return ret;\n  };\n};\n\nvar _iteratorNormalCompletion9 = true;\nvar _didIteratorError9 = false;\nvar _iteratorError9 = undefined;\n\ntry {\n  for (var _iterator9 = ASSERTS[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n    var method$1 = _step9.value;\n\n    _loop$1(method$1);\n  }\n  /**\n   * Memoize read methods.\n   */\n\n} catch (err) {\n  _didIteratorError9 = true;\n  _iteratorError9 = err;\n} finally {\n  try {\n    if (!_iteratorNormalCompletion9 && _iterator9.return) {\n      _iterator9.return();\n    }\n  } finally {\n    if (_didIteratorError9) {\n      throw _iteratorError9;\n    }\n  }\n}\n\nmemoize(ElementInterface.prototype, ['getBlocksAsArray', 'getBlocksByTypeAsArray', 'getDecorations', 'getFragmentAtRange', 'getInlinesAsArray', 'getInlinesByTypeAsArray', 'getInsertMarksAtRange', 'getLeafBlocksAtRangeAsArray', 'getLeafBlocksAtRangeAsArray', 'getLeafInlinesAtRangeAsArray', 'getMarksAsArray', 'getMarksAtPosition', 'getMarksByTypeAsArray', 'getNextBlock', 'getNodesAtRange', 'getNodesToPathsMap', 'getOffset', 'getOffsetAtRange', 'getOrderedMarksBetweenPositions', 'getPreviousBlock', 'getRootBlocksAtRange', 'getRootInlinesAtRangeAsArray', 'getTextAtOffset', 'getTextDirection', 'getTextsAsArray', 'getTextsBetweenPathPositionsAsArray']);\n/**\n * Mix in the element interface.\n */\n\nmixin(ElementInterface, [Block, Document, Inline]);\n/**\n * The interface that `Decoration`, `Range` and `Selection` all implement, to make\n * working anchor and focus points easier.\n *\n * @type {Class}\n */\n\nvar RangeInterface = function () {\n  function RangeInterface() {\n    classCallCheck(this, RangeInterface);\n  }\n\n  createClass(RangeInterface, [{\n    key: 'flip',\n\n    /**\n     * Flip the range.\n     *\n     * @return {Range}\n     */\n    value: function flip() {\n      var range = this.setPoints([this.focus, this.anchor]);\n      return range;\n    }\n    /**\n     * Move the anchor and focus offsets forward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveForward',\n    value: function moveForward(n) {\n      return this.updatePoints(function (point) {\n        return point.moveForward(n);\n      });\n    }\n    /**\n     * Move the anchor and focus offsets backward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveBackward',\n    value: function moveBackward(n) {\n      return this.updatePoints(function (point) {\n        return point.moveBackward(n);\n      });\n    }\n    /**\n     * Move the anchor offset backward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorBackward',\n    value: function moveAnchorBackward(n) {\n      var range = this.setAnchor(this.anchor.moveBackward(n));\n      return range;\n    }\n    /**\n     * Move the anchor offset forward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorForward',\n    value: function moveAnchorForward(n) {\n      var range = this.setAnchor(this.anchor.moveForward(n));\n      return range;\n    }\n    /**\n     * Move the range's anchor point to a new `path` and `offset`.\n     *\n     * Optionally, the `path` can be a key string, or omitted entirely in which\n     * case it would be the offset number.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorTo',\n    value: function moveAnchorTo(path, offset) {\n      var range = this.setAnchor(this.anchor.moveTo(path, offset));\n      return range;\n    }\n    /**\n     * Move the range's anchor point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorToStartOfNode',\n    value: function moveAnchorToStartOfNode(node) {\n      var range = this.setAnchor(this.anchor.moveToStartOfNode(node));\n      return range;\n    }\n    /**\n     * Move the range's anchor point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorToEndOfNode',\n    value: function moveAnchorToEndOfNode(node) {\n      var range = this.setAnchor(this.anchor.moveToEndOfNode(node));\n      return range;\n    }\n    /**\n     * Move the end offset backward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveEndBackward',\n    value: function moveEndBackward(n) {\n      var range = this.setEnd(this.end.moveBackward(n));\n      return range;\n    }\n    /**\n     * Move the end offset forward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveEndForward',\n    value: function moveEndForward(n) {\n      var range = this.setEnd(this.end.moveForward(n));\n      return range;\n    }\n    /**\n     * Move the range's end point to a new `path` and `offset`.\n     *\n     * Optionally, the `path` can be a key string, or omitted entirely in which\n     * case it would be the offset number.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveEndTo',\n    value: function moveEndTo(path, offset) {\n      var range = this.setEnd(this.end.moveTo(path, offset));\n      return range;\n    }\n    /**\n     * Move the range's end point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveEndToStartOfNode',\n    value: function moveEndToStartOfNode(node) {\n      var range = this.setEnd(this.end.moveToStartOfNode(node));\n      return range;\n    }\n    /**\n     * Move the range's end point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveEndToEndOfNode',\n    value: function moveEndToEndOfNode(node) {\n      var range = this.setEnd(this.end.moveToEndOfNode(node));\n      return range;\n    }\n    /**\n     * Move the focus offset backward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusBackward',\n    value: function moveFocusBackward(n) {\n      var range = this.setFocus(this.focus.moveBackward(n));\n      return range;\n    }\n    /**\n     * Move the focus offset forward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusForward',\n    value: function moveFocusForward(n) {\n      var range = this.setFocus(this.focus.moveForward(n));\n      return range;\n    }\n    /**\n     * Move the range's focus point to a new `path` and `offset`.\n     *\n     * Optionally, the `path` can be a key string, or omitted entirely in which\n     * case it would be the offset number.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusTo',\n    value: function moveFocusTo(path, offset) {\n      var range = this.setFocus(this.focus.moveTo(path, offset));\n      return range;\n    }\n    /**\n     * Move the range's focus point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusToStartOfNode',\n    value: function moveFocusToStartOfNode(node) {\n      var range = this.setFocus(this.focus.moveToStartOfNode(node));\n      return range;\n    }\n    /**\n     * Move the range's focus point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusToEndOfNode',\n    value: function moveFocusToEndOfNode(node) {\n      var range = this.setFocus(this.focus.moveToEndOfNode(node));\n      return range;\n    }\n    /**\n     * Move the start offset backward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveStartBackward',\n    value: function moveStartBackward(n) {\n      var range = this.setStart(this.start.moveBackward(n));\n      return range;\n    }\n    /**\n     * Move the start offset forward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveStartForward',\n    value: function moveStartForward(n) {\n      var range = this.setStart(this.start.moveForward(n));\n      return range;\n    }\n    /**\n     * Move the range's start point to a new `path` and `offset`.\n     *\n     * Optionally, the `path` can be a key string, or omitted entirely in which\n     * case it would be the offset number.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveStartTo',\n    value: function moveStartTo(path, offset) {\n      var range = this.setStart(this.start.moveTo(path, offset));\n      return range;\n    }\n    /**\n     * Move the range's start point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveStartToStartOfNode',\n    value: function moveStartToStartOfNode(node) {\n      var range = this.setStart(this.start.moveToStartOfNode(node));\n      return range;\n    }\n    /**\n     * Move the range's start point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveStartToEndOfNode',\n    value: function moveStartToEndOfNode(node) {\n      var range = this.setStart(this.start.moveToEndOfNode(node));\n      return range;\n    }\n    /**\n     * Move range's points to a new `path` and `offset`.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveTo',\n    value: function moveTo(path, offset) {\n      return this.updatePoints(function (point) {\n        return point.moveTo(path, offset);\n      });\n    }\n    /**\n     * Move the focus point to the anchor point.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToAnchor',\n    value: function moveToAnchor() {\n      var range = this.setFocus(this.anchor);\n      return range;\n    }\n    /**\n     * Move the start point to the end point.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToEnd',\n    value: function moveToEnd() {\n      var range = this.setStart(this.end);\n      return range;\n    }\n    /**\n     * Move the range's points to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToEndOfNode',\n    value: function moveToEndOfNode(node) {\n      return this.updatePoints(function (point) {\n        return point.moveToEndOfNode(node);\n      });\n    }\n    /**\n     * Move the anchor point to the focus point.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToFocus',\n    value: function moveToFocus() {\n      var range = this.setAnchor(this.focus);\n      return range;\n    }\n    /**\n     * Move to the entire range of `start` and `end` nodes.\n     *\n     * @param {Node} start\n     * @param {Node} end (optional)\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToRangeOfNode',\n    value: function moveToRangeOfNode(start) {\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : start;\n      var range = this.setPoints([this.anchor.moveToStartOfNode(start), this.focus.moveToEndOfNode(end)]);\n      return range;\n    }\n    /**\n     * Move the end point to the start point.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToStart',\n    value: function moveToStart() {\n      var range = this.setEnd(this.start);\n      return range;\n    }\n    /**\n     * Move the range's points to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToStartOfNode',\n    value: function moveToStartOfNode(node) {\n      return this.updatePoints(function (point) {\n        return point.moveToStartOfNode(node);\n      });\n    }\n    /**\n     * Normalize the range, relative to a `node`, ensuring that the anchor\n     * and focus nodes of the range always refer to leaf text nodes.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(node) {\n      return this.updatePoints(function (point) {\n        return point.normalize(node);\n      });\n    }\n    /**\n     * Set the anchor point to a new `anchor`.\n     *\n     * @param {Point} anchor\n     * @return {Range}\n     */\n\n  }, {\n    key: 'setAnchor',\n    value: function setAnchor(anchor) {\n      var range = this.set('anchor', anchor);\n      return range;\n    }\n    /**\n     * Set the end point to a new `point`.\n     *\n     * @param {Point} point\n     * @return {Range}\n     */\n\n  }, {\n    key: 'setEnd',\n    value: function setEnd(point) {\n      var range = this.isBackward ? this.setAnchor(point) : this.setFocus(point);\n      return range;\n    }\n    /**\n     * Set the focus point to a new `focus`.\n     *\n     * @param {Point} focus\n     * @return {Range}\n     */\n\n  }, {\n    key: 'setFocus',\n    value: function setFocus(focus) {\n      var range = this.set('focus', focus);\n      return range;\n    }\n    /**\n     * Set the anchor and focus points to new `values`.\n     *\n     * @param {Array<Point>} values\n     * @return {Range}\n     */\n\n  }, {\n    key: 'setPoints',\n    value: function setPoints(values) {\n      var _values = slicedToArray(values, 2),\n          anchor = _values[0],\n          focus = _values[1];\n\n      var range = this.set('anchor', anchor).set('focus', focus);\n      return range;\n    }\n    /**\n     * Set the anchor and focus points with `updater` callback\n     *\n     * @param {Function} updater\n     * @return {Range}\n     */\n\n  }, {\n    key: 'updatePoints',\n    value: function updatePoints(updater) {\n      var anchor = this.anchor,\n          focus = this.focus;\n      anchor = updater(anchor);\n      focus = updater(focus);\n      return this.merge({\n        anchor: anchor,\n        focus: focus\n      });\n    }\n    /**\n     * Set the start point to a new `point`.\n     *\n     * @param {Point} point\n     * @return {Range}\n     */\n\n  }, {\n    key: 'setStart',\n    value: function setStart(point) {\n      var range = this.isBackward ? this.setFocus(point) : this.setAnchor(point);\n      return range;\n    }\n    /**\n     * Set new `properties` on the range.\n     *\n     * @param {Object|Range} properties\n     * @return {Range}\n     */\n\n  }, {\n    key: 'setProperties',\n    value: function setProperties(properties) {\n      properties = Range.createProperties(properties);\n      var _properties = properties,\n          anchor = _properties.anchor,\n          focus = _properties.focus,\n          props = objectWithoutProperties(_properties, ['anchor', 'focus']);\n\n      if (anchor) {\n        props.anchor = Point.create(anchor);\n      }\n\n      if (focus) {\n        props.focus = Point.create(focus);\n      }\n\n      var range = this.merge(props);\n      return range;\n    }\n    /**\n     * Return a JSON representation of the range.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        anchor: this.anchor.toJSON(options),\n        focus: this.focus.toJSON(options)\n      };\n      return object;\n    }\n    /**\n     * Return a `Range` instance from any range-like instance.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'toRange',\n    value: function toRange() {\n      var properties = Range.createProperties(this);\n      var range = Range.create(properties);\n      return range;\n    }\n    /**\n     * Unset the range.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'unset',\n    value: function unset() {\n      var range = this.updatePoints(function (p) {\n        return p.unset();\n      });\n      return range;\n    }\n  }, {\n    key: 'isCollapsed',\n\n    /**\n     * Check whether the range is collapsed.\n     *\n     * @return {Boolean}\n     */\n    get: function get$$1() {\n      return this.anchor === this.focus || this.anchor.key === this.focus.key && this.anchor.offset === this.focus.offset;\n    }\n    /**\n     * Check whether the range is expanded.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isExpanded',\n    get: function get$$1() {\n      return !this.isCollapsed;\n    }\n    /**\n     * Check whether the range is backward.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBackward',\n    get: function get$$1() {\n      var isUnset = this.isUnset,\n          anchor = this.anchor,\n          focus = this.focus;\n\n      if (isUnset) {\n        return null;\n      }\n\n      if (anchor.key === focus.key) {\n        return anchor.offset > focus.offset;\n      }\n\n      var isBackward = PathUtils.isBefore(focus.path, anchor.path);\n      return isBackward;\n    }\n    /**\n     * Check whether the range is forward.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isForward',\n    get: function get$$1() {\n      var isBackward = this.isBackward;\n      var isForward = isBackward == null ? null : !isBackward;\n      return isForward;\n    }\n    /**\n     * Check whether the range isn't set.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isUnset',\n    get: function get$$1() {\n      var anchor = this.anchor,\n          focus = this.focus;\n      var isUnset = anchor.isUnset || focus.isUnset;\n      return isUnset;\n    }\n    /**\n     * Check whether the range is set.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isSet',\n    get: function get$$1() {\n      return !this.isUnset;\n    }\n    /**\n     * Get the start point.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'start',\n    get: function get$$1() {\n      return this.isBackward ? this.focus : this.anchor;\n    }\n    /**\n     * Get the end point.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'end',\n    get: function get$$1() {\n      return this.isBackward ? this.anchor : this.focus;\n    }\n  }]);\n  return RangeInterface;\n}();\n/**\n * Mix in the range interface.\n *\n * @param {Record}\n */\n\n\nmixin(RangeInterface, [Annotation, Decoration, Range, Selection]);\nvar index = {\n  Annotation: Annotation,\n  Block: Block,\n  Change: Change,\n  Data: Data,\n  Decoration: Decoration,\n  Document: Document,\n  Editor: Editor,\n  Inline: Inline,\n  KeyUtils: KeyUtils,\n  Leaf: Leaf$1,\n  Mark: Mark,\n  Node: Node,\n  Operation: Operation,\n  PathUtils: PathUtils,\n  Point: Point,\n  Range: Range,\n  resetMemoization: resetMemoization,\n  Selection: Selection,\n  Text: Text,\n  TextUtils: TextUtils,\n  useMemoization: useMemoization,\n  Value: Value\n};\nexport default index;\nexport { Annotation, Block, Change, Data, Decoration, Document, Editor, Inline, KeyUtils, Leaf$1 as Leaf, Mark, Node, Operation, PathUtils, Point, Range, resetMemoization, Selection, Text, TextUtils, useMemoization, Value };","import { Block, Change, Data, Document, Inline, Leaf, Mark, Node, Range, Selection, Value, Text } from 'slate';\n/**\n * Create a prop type checker for Slate objects with `name` and `validate`.\n *\n * @param {String} name\n * @param {Function} validate\n * @return {Function}\n */\n\nfunction create(name, validate) {\n  function check(isRequired, props, propName, componentName, location) {\n    var value = props[propName];\n\n    if (value == null && !isRequired) {\n      return null;\n    }\n\n    if (value == null && isRequired) {\n      return new Error('The ' + location + ' `' + propName + '` is marked as required in `' + componentName + '`, but it was not supplied.');\n    }\n\n    if (validate(value)) {\n      return null;\n    }\n\n    return new Error('Invalid ' + location + ' `' + propName + '` supplied to `' + componentName + '`, expected a Slate `' + name + '` but received: ' + value);\n  }\n\n  function propType() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return check.apply(undefined, [false].concat(args));\n  }\n\n  propType.isRequired = function () {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return check.apply(undefined, [true].concat(args));\n  };\n\n  return propType;\n}\n/**\n * Prop type checkers.\n *\n * @type {Object}\n */\n\n\nvar Types = {\n  block: create('Block', function (v) {\n    return Block.isBlock(v);\n  }),\n  blocks: create('List<Block>', function (v) {\n    return Block.isBlockList(v);\n  }),\n  change: create('Change', function (v) {\n    return Change.isChange(v);\n  }),\n  data: create('Data', function (v) {\n    return Data.isData(v);\n  }),\n  document: create('Document', function (v) {\n    return Document.isDocument(v);\n  }),\n  inline: create('Inline', function (v) {\n    return Inline.isInline(v);\n  }),\n  inlines: create('Inline', function (v) {\n    return Inline.isInlineList(v);\n  }),\n  leaf: create('Leaf', function (v) {\n    return Leaf.isLeaf(v);\n  }),\n  leaves: create('List<Leaf>', function (v) {\n    return Leaf.isLeafList(v);\n  }),\n  mark: create('Mark', function (v) {\n    return Mark.isMark(v);\n  }),\n  marks: create('Set<Mark>', function (v) {\n    return Mark.isMarkSet(v);\n  }),\n  node: create('Node', function (v) {\n    return Node.isNode(v);\n  }),\n  nodes: create('List<Node>', function (v) {\n    return Node.isNodeList(v);\n  }),\n  range: create('Range', function (v) {\n    return Range.isRange(v);\n  }),\n  ranges: create('List<Range>', function (v) {\n    return Range.isRangeList(v);\n  }),\n  selection: create('Selection', function (v) {\n    return Selection.isSelection(v);\n  }),\n  value: create('Value', function (v) {\n    return Value.isValue(v);\n  }),\n  text: create('Text', function (v) {\n    return Text.isText(v);\n  }),\n  texts: create('List<Text>', function (v) {\n    return Text.isTextList(v);\n  })\n  /**\n   * Export.\n   *\n   * @type {Object}\n   */\n\n};\nexport default Types;","import isBrowser from 'is-in-browser';\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n/**\n * Browser matching rules.\n *\n * @type {Array}\n */\n\n\nvar BROWSER_RULES = [['edge', /Edge\\/([0-9\\._]+)/], ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/], ['firefox', /Firefox\\/([0-9\\.]+)(?:\\s|$)/], ['opera', /Opera\\/([0-9\\.]+)(?:\\s|$)/], ['opera', /OPR\\/([0-9\\.]+)(:?\\s|$)$/], ['ie', /Trident\\/7\\.0.*rv\\:([0-9\\.]+)\\).*Gecko$/], ['ie', /MSIE\\s([0-9\\.]+);.*Trident\\/[4-7].0/], ['ie', /MSIE\\s(7\\.0)/], ['android', /Android\\s([0-9\\.]+)/], ['safari', /Version\\/([0-9\\._]+).*Safari/]];\nvar browser = void 0;\n\nif (isBrowser) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = BROWSER_RULES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref = _step.value;\n\n      var _ref2 = slicedToArray(_ref, 2);\n\n      var name = _ref2[0];\n      var regexp = _ref2[1];\n\n      if (regexp.test(window.navigator.userAgent)) {\n        browser = name;\n        break;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n/**\n * Operating system matching rules.\n *\n * @type {Array}\n */\n\n\nvar OS_RULES = [['ios', /os ([\\.\\_\\d]+) like mac os/i], // must be before the macos rule\n['macos', /mac os x/i], ['android', /android/i], ['firefoxos', /mozilla\\/[a-z\\.\\_\\d]+ \\((?:mobile)|(?:tablet)/i], ['windows', /windows\\s*(?:nt)?\\s*([\\.\\_\\d]+)/i]];\nvar os = void 0;\n\nif (isBrowser) {\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = OS_RULES[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _ref3 = _step2.value;\n\n      var _ref4 = slicedToArray(_ref3, 2);\n\n      var _name = _ref4[0];\n      var _regexp = _ref4[1];\n\n      if (_regexp.test(window.navigator.userAgent)) {\n        os = _name;\n        break;\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n}\n/**\n * Feature matching rules.\n *\n * @type {Array}\n */\n\n\nvar FEATURE_RULES = [['inputeventslevel1', function (window) {\n  var event = window.InputEvent ? new window.InputEvent('input') : {};\n  var support = 'inputType' in event;\n  return support;\n}], ['inputeventslevel2', function (window) {\n  var element = window.document.createElement('div');\n  element.contentEditable = true;\n  var support = 'onbeforeinput' in element;\n  return support;\n}]];\nvar features = [];\n\nif (isBrowser) {\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = FEATURE_RULES[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var _ref5 = _step3.value;\n\n      var _ref6 = slicedToArray(_ref5, 2);\n\n      var _name2 = _ref6[0];\n      var test = _ref6[1];\n\n      if (test(window)) {\n        features.push(_name2);\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n}\n/**\n * Array of regular expression matchers and their API version\n *\n * @type {Array}\n */\n\n\nvar ANDROID_API_VERSIONS = [[/^9([.]0|)/, 28], [/^8[.]1/, 27], [/^8([.]0|)/, 26], [/^7[.]1/, 25], [/^7([.]0|)/, 24], [/^6([.]0|)/, 23], [/^5[.]1/, 22], [/^5([.]0|)/, 21], [/^4[.]4/, 20]];\n/**\n * get the Android API version from the userAgent\n *\n * @return {number} version\n */\n\nfunction getAndroidApiVersion() {\n  if (os !== 'android') return null;\n  var userAgent = window.navigator.userAgent;\n  var matchData = userAgent.match(/Android\\s([0-9\\.]+)/);\n  if (matchData == null) return null;\n  var versionString = matchData[1];\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = ANDROID_API_VERSIONS[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var _ref7 = _step4.value;\n\n      var _ref8 = slicedToArray(_ref7, 2);\n\n      var regex = _ref8[0];\n      var version = _ref8[1];\n      if (versionString.match(regex)) return version;\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  return null;\n}\n/**\n * Export.\n *\n * @type {Boolean}\n */\n\n\nvar IS_CHROME = browser === 'chrome';\nvar IS_OPERA = browser === 'opera';\nvar IS_FIREFOX = browser === 'firefox';\nvar IS_SAFARI = browser === 'safari';\nvar IS_IE = browser === 'ie';\nvar IS_EDGE = browser === 'edge';\nvar IS_ANDROID = os === 'android';\nvar IS_IOS = os === 'ios';\nvar IS_MAC = os === 'macos';\nvar IS_WINDOWS = os === 'windows';\nvar ANDROID_API_VERSION = getAndroidApiVersion();\nvar HAS_INPUT_EVENTS_LEVEL_1 = features.includes('inputeventslevel1');\nvar HAS_INPUT_EVENTS_LEVEL_2 = features.includes('inputeventslevel2') || IS_ANDROID && (ANDROID_API_VERSION === 28 || ANDROID_API_VERSION === null);\nexport { IS_CHROME, IS_OPERA, IS_FIREFOX, IS_SAFARI, IS_IE, IS_EDGE, IS_ANDROID, IS_IOS, IS_MAC, IS_WINDOWS, ANDROID_API_VERSION, HAS_INPUT_EVENTS_LEVEL_1, HAS_INPUT_EVENTS_LEVEL_2 };","import { Node, Value } from 'slate';\nimport { atob, btoa } from 'isomorphic-base64';\n/**\n * Encode a JSON `object` as base-64 `string`.\n *\n * @param {Object} object\n * @return {String}\n */\n\nfunction encode(object) {\n  var string = JSON.stringify(object);\n  var encoded = btoa(encodeURIComponent(string));\n  return encoded;\n}\n/**\n * Decode a base-64 `string` to a JSON `object`.\n *\n * @param {String} string\n * @return {Object}\n */\n\n\nfunction decode(string) {\n  var decoded = decodeURIComponent(atob(string));\n  var object = JSON.parse(decoded);\n  return object;\n}\n/**\n * Deserialize a Value `string`.\n *\n * @param {String} string\n * @return {Value}\n */\n\n\nfunction deserialize(string, options) {\n  var raw = decode(string);\n  var value = Value.fromJSON(raw, options);\n  return value;\n}\n/**\n * Deserialize a Node `string`.\n *\n * @param {String} string\n * @return {Node}\n */\n\n\nfunction deserializeNode(string, options) {\n  var raw = decode(string);\n  var node = Node.fromJSON(raw, options);\n  return node;\n}\n/**\n * Serialize a `value`.\n *\n * @param {Value} value\n * @return {String}\n */\n\n\nfunction serialize(value, options) {\n  var raw = value.toJSON(options);\n  var encoded = encode(raw);\n  return encoded;\n}\n/**\n * Serialize a `node`.\n *\n * @param {Node} node\n * @return {String}\n */\n\n\nfunction serializeNode(node, options) {\n  var raw = node.toJSON(options);\n  var encoded = encode(raw);\n  return encoded;\n}\n/**\n * Export.\n *\n * @type {Object}\n */\n\n\nvar index = {\n  deserialize: deserialize,\n  deserializeNode: deserializeNode,\n  serialize: serialize,\n  serializeNode: serializeNode\n};\nexport default index;","import { Block, Mark, Node, Value } from 'slate';\nimport { Set } from 'immutable';\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n/**\n * Deserialize a plain text `string` to a Slate value.\n *\n * @param {String} string\n * @param {Object} options\n *   @property {Boolean} toJSON\n *   @property {String|Object|Block} defaultBlock\n *   @property {Array|Set} defaultMarks\n * @return {Value}\n */\n\n\nfunction deserialize(string) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$defaultBlock = options.defaultBlock,\n      defaultBlock = _options$defaultBlock === undefined ? 'line' : _options$defaultBlock,\n      _options$defaultMarks = options.defaultMarks,\n      defaultMarks = _options$defaultMarks === undefined ? [] : _options$defaultMarks,\n      _options$delimiter = options.delimiter,\n      delimiter = _options$delimiter === undefined ? '\\n' : _options$delimiter,\n      _options$toJSON = options.toJSON,\n      toJSON = _options$toJSON === undefined ? false : _options$toJSON;\n\n  if (Set.isSet(defaultMarks)) {\n    defaultMarks = defaultMarks.toArray();\n  }\n\n  defaultBlock = Node.createProperties(defaultBlock);\n  defaultMarks = defaultMarks.map(Mark.createProperties);\n  var json = {\n    object: 'value',\n    document: {\n      object: 'document',\n      data: {},\n      nodes: string.split(delimiter).map(function (line) {\n        return _extends({}, defaultBlock, {\n          object: 'block',\n          data: {},\n          nodes: [{\n            object: 'text',\n            text: line,\n            marks: defaultMarks\n          }]\n        });\n      })\n    }\n  };\n  var ret = toJSON ? json : Value.fromJSON(json);\n  return ret;\n}\n/**\n * Serialize a Slate `value` to a plain text string.\n *\n * @param {Value} value\n * @return {String}\n */\n\n\nfunction serialize(value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return serializeNode(value.document, options);\n}\n/**\n * Serialize a `node` to plain text.\n *\n * @param {Node} node\n * @return {String}\n */\n\n\nfunction serializeNode(node) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$delimiter2 = options.delimiter,\n      delimiter = _options$delimiter2 === undefined ? '\\n' : _options$delimiter2;\n\n  if (node.object === 'document' || node.object === 'block' && Block.isBlockList(node.nodes)) {\n    return node.nodes.map(serializeNode).join(delimiter);\n  } else {\n    return node.text;\n  }\n}\n/**\n * Export.\n *\n * @type {Object}\n */\n\n\nvar index = {\n  deserialize: deserialize,\n  serialize: serialize\n};\nexport default index;","import { isKeyHotkey } from 'is-hotkey';\nimport { IS_IOS, IS_MAC } from 'slate-dev-environment';\n/**\n * Hotkey mappings for each platform.\n *\n * @type {Object}\n */\n\nvar HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  italic: 'mod+i',\n  splitBlock: 'shift?+enter',\n  undo: 'mod+z'\n};\nvar APPLE_HOTKEYS = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t'\n};\nvar WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: 'ctrl+y'\n  /**\n   * Hotkeys.\n   *\n   * @type {Object}\n   */\n\n};\nvar Hotkeys = {};\nvar IS_APPLE = IS_IOS || IS_MAC;\nvar IS_WINDOWS = !IS_APPLE;\nvar KEYS = [].concat(Object.keys(HOTKEYS)).concat(Object.keys(APPLE_HOTKEYS)).concat(Object.keys(WINDOWS_HOTKEYS));\nKEYS.forEach(function (key) {\n  var method = 'is' + key[0].toUpperCase() + key.slice(1);\n  if (Hotkeys[method]) return;\n  var generic = HOTKEYS[key];\n  var apple = APPLE_HOTKEYS[key];\n  var windows = WINDOWS_HOTKEYS[key];\n  var isGeneric = generic && isKeyHotkey(generic);\n  var isApple = apple && isKeyHotkey(apple);\n  var isWindows = windows && isKeyHotkey(windows);\n\n  Hotkeys[method] = function (event) {\n    if (isGeneric && isGeneric(event)) return true;\n    if (IS_APPLE && isApple && isApple(event)) return true;\n    if (IS_WINDOWS && isWindows && isWindows(event)) return true;\n    return false;\n  };\n});\nexport default Hotkeys;","import React from 'react';\nvar isProduction = \"development\" === 'production';\nvar prefix = 'Invariant failed';\n\nvar index = function index(condition, message) {\n  if (condition) {\n    return;\n  }\n\n  if (isProduction) {\n    throw new Error(prefix);\n  } else {\n    throw new Error(prefix + \": \" + (message || ''));\n  }\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar toConsumableArray = function toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n/*\n * Instance counter to enable unique marks for multiple Placeholder instances.\n */\n\n\nvar instanceCounter = 0;\n/**\n * A plugin that renders a React placeholder for a given Slate node.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction SlateReactPlaceholder() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var instanceId = instanceCounter++;\n  var placeholder = options.placeholder,\n      when = options.when,\n      _options$style = options.style,\n      style = _options$style === undefined ? {} : _options$style;\n  index(typeof placeholder === 'string', 'You must pass `SlateReactPlaceholder` an `options.placeholder` string.');\n  index(typeof when === 'string' || typeof when === 'function', 'You must pass `SlateReactPlaceholder` an `options.when` query.');\n  /**\n   * Decorate a match node with a placeholder mark when it fits the query.\n   *\n   * @param {Node} node\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Array}\n   */\n\n  function decorateNode(node, editor, next) {\n    if (!editor.query(when, node)) {\n      return next();\n    }\n\n    var others = next();\n\n    var _node$texts = node.texts(),\n        _node$texts2 = slicedToArray(_node$texts, 1),\n        first = _node$texts2[0];\n\n    var _node$texts3 = node.texts({\n      direction: 'backward'\n    }),\n        _node$texts4 = slicedToArray(_node$texts3, 1),\n        last = _node$texts4[0];\n\n    var _first = slicedToArray(first, 2),\n        firstNode = _first[0],\n        firstPath = _first[1];\n\n    var _last = slicedToArray(last, 2),\n        lastNode = _last[0],\n        lastPath = _last[1];\n\n    var decoration = {\n      type: 'placeholder',\n      data: {\n        key: instanceId\n      },\n      anchor: {\n        key: firstNode.key,\n        offset: 0,\n        path: firstPath\n      },\n      focus: {\n        key: lastNode.key,\n        offset: lastNode.text.length,\n        path: lastPath\n      }\n    };\n    return [].concat(toConsumableArray(others), [decoration]);\n  }\n  /**\n   * Render an inline placeholder for the placeholder mark.\n   *\n   * @param {Object} props\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Element}\n   */\n\n\n  function renderMark(props, editor, next) {\n    var children = props.children,\n        mark = props.mark;\n\n    if (mark.type === 'placeholder' && mark.data.get('key') === instanceId) {\n      var placeHolderStyle = _extends({\n        pointerEvents: 'none',\n        display: 'inline-block',\n        width: '0',\n        maxWidth: '100%',\n        whiteSpace: 'nowrap',\n        opacity: '0.333'\n      }, style);\n\n      return React.createElement('span', null, React.createElement('span', {\n        contentEditable: false,\n        style: placeHolderStyle\n      }, placeholder), children);\n    }\n\n    return next();\n  }\n  /**\n   * Return the plugin.\n   *\n   * @return {Object}\n   */\n\n\n  return {\n    decorateNode: decorateNode,\n    renderMark: renderMark\n  };\n}\n\nexport default SlateReactPlaceholder;","import React from 'react';\nimport Types from 'prop-types';\nimport SlateTypes from 'slate-prop-types';\nimport ImmutableTypes from 'react-immutable-proptypes';\nimport Debug from 'debug';\nimport warning from 'tiny-warning';\nimport { PathUtils, Value, Node, Editor } from 'slate';\nimport getWindow from 'get-window';\nimport isBackward from 'selection-is-backward';\nimport { IS_SAFARI, IS_IOS, IS_IE, IS_ANDROID, IS_FIREFOX, HAS_INPUT_EVENTS_LEVEL_2, ANDROID_API_VERSION, IS_EDGE } from 'slate-dev-environment';\nimport throttle from 'lodash/throttle';\nimport { List } from 'immutable';\nimport invariant from 'tiny-invariant';\nimport pick from 'lodash/pick';\nimport Base64 from 'slate-base64-serializer';\nimport Plain from 'slate-plain-serializer';\nimport Hotkeys from 'slate-hotkeys';\nimport PlaceholderPlugin from 'slate-react-placeholder';\nimport memoizeOne from 'memoize-one';\n/**\n * Event handlers used by Slate plugins.\n *\n * @type {Array}\n */\n\nvar EVENT_HANDLERS = ['onBeforeInput', 'onBlur', 'onClick', 'onContextMenu', 'onCompositionEnd', 'onCompositionStart', 'onCopy', 'onCut', 'onDragEnd', 'onDragEnter', 'onDragExit', 'onDragLeave', 'onDragOver', 'onDragStart', 'onDrop', 'onInput', 'onFocus', 'onKeyDown', 'onKeyUp', 'onMouseDown', 'onMouseUp', 'onPaste', 'onSelect'];\n/**\n * DOM data attribute strings that refer to Slate concepts.\n *\n * @type {String}\n */\n\nvar DATA_ATTRS = {\n  EDITOR: 'data-slate-editor',\n  FRAGMENT: 'data-slate-fragment',\n  KEY: 'data-key',\n  LEAF: 'data-slate-leaf',\n  LENGTH: 'data-slate-length',\n  OBJECT: 'data-slate-object',\n  OFFSET_KEY: 'data-offset-key',\n  SPACER: 'data-slate-spacer',\n  STRING: 'data-slate-string',\n  TEXT: 'data-slate-object',\n  VOID: 'data-slate-void',\n  ZERO_WIDTH: 'data-slate-zero-width'\n};\n/**\n * DOM selector strings that refer to Slate concepts.\n *\n * @type {String}\n */\n\nvar SELECTORS = {\n  BLOCK: '[' + DATA_ATTRS.OBJECT + '=\"block\"]',\n  EDITOR: '[' + DATA_ATTRS.EDITOR + ']',\n  INLINE: '[' + DATA_ATTRS.OBJECT + '=\"inline\"]',\n  KEY: '[' + DATA_ATTRS.KEY + ']',\n  LEAF: '[' + DATA_ATTRS.LEAF + ']',\n  OBJECT: '[' + DATA_ATTRS.OBJECT + ']',\n  STRING: '[' + DATA_ATTRS.STRING + ']',\n  TEXT: '[' + DATA_ATTRS.OBJECT + '=\"text\"]',\n  VOID: '[' + DATA_ATTRS.VOID + ']',\n  ZERO_WIDTH: '[' + DATA_ATTRS.ZERO_WIDTH + ']',\n  ANNOTATION: '[' + DATA_ATTRS.OBJECT + '=\"annotation\"]'\n};\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar defineProperty = function defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar toConsumableArray = function toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n/**\n * Offset key parser regex.\n *\n * @type {RegExp}\n */\n\n\nvar PARSER = /^([\\w-]+)(?::(\\d+))?$/;\n/**\n * Parse an offset key `string`.\n *\n * @param {String} string\n * @return {Object}\n */\n\nfunction parse(string) {\n  var matches = PARSER.exec(string);\n\n  if (!matches) {\n    throw new Error(\"Invalid offset key string \\\"\" + string + \"\\\".\");\n  }\n\n  var _matches = slicedToArray(matches, 3),\n      original = _matches[0],\n      key = _matches[1],\n      index = _matches[2]; // eslint-disable-line no-unused-vars\n\n\n  return {\n    key: key,\n    index: parseInt(index, 10)\n  };\n}\n/**\n * Stringify an offset key `object`.\n *\n * @param {Object} object\n *   @property {String} key\n *   @property {Number} index\n * @return {String}\n */\n\n\nfunction stringify(object) {\n  return object.key + \":\" + object.index;\n}\n/**\n * Export.\n *\n * @type {Object}\n */\n\n\nvar OffsetKey = {\n  parse: parse,\n  stringify: stringify\n};\n/**\n * Leaf strings with text in them.\n *\n * @type {Component}\n */\n\nvar TextString = function TextString(_ref) {\n  var _ref$text = _ref.text,\n      text = _ref$text === undefined ? '' : _ref$text,\n      _ref$isTrailing = _ref.isTrailing,\n      isTrailing = _ref$isTrailing === undefined ? false : _ref$isTrailing;\n  return React.createElement('span', defineProperty({}, DATA_ATTRS.STRING, true), text, isTrailing ? '\\n' : null);\n};\n/**\n * Leaf strings without text, render as zero-width strings.\n *\n * @type {Component}\n */\n\n\nvar ZeroWidthString = function ZeroWidthString(_ref3) {\n  var _ref4;\n\n  var _ref3$length = _ref3.length,\n      length = _ref3$length === undefined ? 0 : _ref3$length,\n      _ref3$isLineBreak = _ref3.isLineBreak,\n      isLineBreak = _ref3$isLineBreak === undefined ? false : _ref3$isLineBreak;\n  return React.createElement('span', (_ref4 = {}, defineProperty(_ref4, DATA_ATTRS.ZERO_WIDTH, isLineBreak ? 'n' : 'z'), defineProperty(_ref4, DATA_ATTRS.LENGTH, length), _ref4), \"\\uFEFF\", isLineBreak ? React.createElement('br', null) : null);\n};\n/**\n * Individual leaves in a text node with unique formatting.\n *\n * @type {Component}\n */\n\n\nvar Leaf = function Leaf(props) {\n  var _attrs;\n\n  var marks = props.marks,\n      annotations = props.annotations,\n      decorations = props.decorations,\n      node = props.node,\n      index = props.index,\n      offset = props.offset,\n      text = props.text,\n      editor = props.editor,\n      parent = props.parent,\n      block = props.block,\n      leaves = props.leaves;\n  var offsetKey = OffsetKey.stringify({\n    key: node.key,\n    index: index\n  });\n  var children = void 0;\n\n  if (editor.query('isVoid', parent)) {\n    // COMPAT: Render text inside void nodes with a zero-width space.\n    // So the node can contain selection but the text is not visible.\n    children = React.createElement(ZeroWidthString, {\n      length: parent.text.length\n    });\n  } else if (text === '' && parent.object === 'block' && parent.text === '' && parent.nodes.last() === node) {\n    // COMPAT: If this is the last text node in an empty block, render a zero-\n    // width space that will convert into a line break when copying and pasting\n    // to support expected plain text.\n    children = React.createElement(ZeroWidthString, {\n      isLineBreak: true\n    });\n  } else if (text === '') {\n    // COMPAT: If the text is empty, it's because it's on the edge of an inline\n    // node, so we render a zero-width space so that the selection can be\n    // inserted next to it still.\n    children = React.createElement(ZeroWidthString, null);\n  } else {\n    // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n    // so we need to add an extra trailing new lines to prevent that.\n    var lastText = block.getLastText();\n    var lastChar = text.charAt(text.length - 1);\n    var isLastText = node === lastText;\n    var isLastLeaf = index === leaves.size - 1;\n\n    if (isLastText && isLastLeaf && lastChar === '\\n') {\n      children = React.createElement(TextString, {\n        isTrailing: true,\n        text: text\n      });\n    } else {\n      children = React.createElement(TextString, {\n        text: text\n      });\n    }\n  }\n\n  var renderProps = {\n    editor: editor,\n    marks: marks,\n    annotations: annotations,\n    decorations: decorations,\n    node: node,\n    offset: offset,\n    text: text // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n    // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n    // contenteditable behaviors. (2019/05/08)\n\n  };\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = marks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var mark = _step.value;\n      var ret = editor.run('renderMark', _extends({}, renderProps, {\n        mark: mark,\n        children: children,\n        attributes: defineProperty({}, DATA_ATTRS.OBJECT, 'mark')\n      }));\n\n      if (ret) {\n        children = ret;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = decorations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var decoration = _step2.value;\n      var ret = editor.run('renderDecoration', _extends({}, renderProps, {\n        decoration: decoration,\n        children: children,\n        attributes: defineProperty({}, DATA_ATTRS.OBJECT, 'decoration')\n      }));\n\n      if (ret) {\n        children = ret;\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = annotations[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var annotation = _step3.value;\n      var ret = editor.run('renderAnnotation', _extends({}, renderProps, {\n        annotation: annotation,\n        children: children,\n        attributes: defineProperty({}, DATA_ATTRS.OBJECT, 'annotation')\n      }));\n\n      if (ret) {\n        children = ret;\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  var attrs = (_attrs = {}, defineProperty(_attrs, DATA_ATTRS.LEAF, true), defineProperty(_attrs, DATA_ATTRS.OFFSET_KEY, offsetKey), _attrs);\n  return React.createElement('span', attrs, children);\n};\n/**\n * Prop types.\n *\n * @type {Object}\n */\n\n\nLeaf.propTypes = {\n  annotations: ImmutableTypes.list.isRequired,\n  block: SlateTypes.block.isRequired,\n  decorations: ImmutableTypes.list.isRequired,\n  editor: Types.object.isRequired,\n  index: Types.number.isRequired,\n  leaves: Types.object.isRequired,\n  marks: SlateTypes.marks.isRequired,\n  node: SlateTypes.node.isRequired,\n  offset: Types.number.isRequired,\n  parent: SlateTypes.node.isRequired,\n  text: Types.string.isRequired\n  /**\n   * A memoized version of `Leaf` that updates less frequently.\n   *\n   * @type {Component}\n   */\n\n};\nvar MemoizedLeaf = React.memo(Leaf, function (prev, next) {\n  return next.index === prev.index && next.marks === prev.marks && next.parent === prev.parent && next.block === prev.block && next.annotations.equals(prev.annotations) && next.decorations.equals(prev.decorations) && // This is necessary for rerendering leaves when only\n  // content changes, e.g first leaf on search highlight.\n  next.text === prev.text;\n});\n/**\n * Text node.\n *\n * @type {Component}\n */\n\nvar Text = React.forwardRef(function (props, ref) {\n  var _ref;\n\n  var annotations = props.annotations,\n      block = props.block,\n      decorations = props.decorations,\n      node = props.node,\n      parent = props.parent,\n      editor = props.editor,\n      style = props.style;\n  var key = node.key;\n  var leaves = node.getLeaves(annotations, decorations);\n  var at = 0;\n  return React.createElement('span', _extends({\n    ref: ref,\n    style: style\n  }, (_ref = {}, defineProperty(_ref, DATA_ATTRS.OBJECT, node.object), defineProperty(_ref, DATA_ATTRS.KEY, key), _ref)), leaves.map(function (leaf, index) {\n    var text = leaf.text;\n    var offset = at;\n    at += text.length;\n    return React.createElement(MemoizedLeaf, {\n      key: node.key + '-' + index,\n      block: block,\n      editor: editor,\n      index: index,\n      annotations: leaf.annotations,\n      decorations: leaf.decorations,\n      marks: leaf.marks,\n      node: node,\n      offset: offset,\n      parent: parent,\n      leaves: leaves,\n      text: text\n    });\n  }));\n});\n/**\n * Prop types.\n *\n * @type {Object}\n */\n\nText.propTypes = {\n  annotations: ImmutableTypes.map.isRequired,\n  block: SlateTypes.block,\n  decorations: ImmutableTypes.list.isRequired,\n  editor: Types.object.isRequired,\n  node: SlateTypes.node.isRequired,\n  parent: SlateTypes.node.isRequired,\n  style: Types.object\n  /**\n   * A memoized version of `Text` that updates less frequently.\n   *\n   * @type {Component}\n   */\n\n};\nvar MemoizedText = React.memo(Text, function (prev, next) {\n  return (// PERF: There are cases where it will have\n    // changed, but it's properties will be exactly the same (eg. copy-paste)\n    // which this won't catch. But that's rare and not a drag on performance, so\n    // for simplicity we just let them through.\n    next.node === prev.node && // If the node parent is a block node, and it was the last child of the\n    // block, re-render to cleanup extra `\\n`.\n    next.parent.object === 'block' && prev.parent.nodes.last() === prev.node && next.parent.nodes.last() !== next.node && // The formatting hasn't changed.\n    next.annotations.equals(prev.annotations) && next.decorations.equals(prev.decorations)\n  );\n});\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = Debug('slate:void');\n/**\n * Void.\n *\n * @type {Component}\n */\n\nvar Void = function (_React$Component) {\n  inherits(Void, _React$Component);\n\n  function Void() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Void);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Void.__proto__ || Object.getPrototypeOf(Void)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps.call(_this), _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n\n  createClass(Void, [{\n    key: 'render',\n\n    /**\n     * Render.\n     *\n     * @return {Element}\n     */\n    value: function render() {\n      var _attrs;\n\n      var props = this.props;\n      var children = props.children,\n          node = props.node,\n          readOnly = props.readOnly;\n      var Tag = node.object === 'block' ? 'div' : 'span';\n      var style = {\n        height: '0',\n        color: 'transparent',\n        outline: 'none',\n        position: 'absolute'\n      };\n      var spacerAttrs = defineProperty({}, DATA_ATTRS.SPACER, true);\n      var spacer = React.createElement(Tag, _extends({\n        style: style\n      }, spacerAttrs), this.renderText());\n      var content = React.createElement(Tag, {\n        contentEditable: readOnly ? null : false\n      }, children);\n      this.debug('render', {\n        props: props\n      });\n      var attrs = (_attrs = {}, defineProperty(_attrs, DATA_ATTRS.VOID, true), defineProperty(_attrs, DATA_ATTRS.KEY, node.key), _attrs);\n      return React.createElement(Tag, _extends({\n        contentEditable: readOnly || node.object === 'block' ? null : false\n      }, attrs), readOnly ? null : spacer, content);\n    }\n    /**\n     * Render the void node's text node, which will catch the cursor when it the\n     * void node is navigated to with the arrow keys.\n     *\n     * Having this text node there means the browser continues to manage the\n     * selection natively, so it keeps track of the right offset when moving\n     * across the block.\n     *\n     * @return {Element}\n     */\n\n  }]);\n  return Void;\n}(React.Component);\n/**\n * Export.\n *\n * @type {Component}\n */\n\n\nVoid.propTypes = {\n  block: SlateTypes.block,\n  children: Types.any.isRequired,\n  editor: Types.object.isRequired,\n  node: SlateTypes.node.isRequired,\n  parent: SlateTypes.node.isRequired,\n  readOnly: Types.bool.isRequired\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this.debug = function (message) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    var node = _this2.props.node;\n    var key = node.key,\n        type = node.type;\n    var id = key + ' (' + type + ')';\n    debug.apply(undefined, [message, '' + id].concat(args));\n  };\n\n  this.renderText = function () {\n    var _props = _this2.props,\n        annotations = _props.annotations,\n        block = _props.block,\n        decorations = _props.decorations,\n        node = _props.node,\n        readOnly = _props.readOnly,\n        editor = _props.editor,\n        textRef = _props.textRef;\n    var child = node.getFirstText();\n    return React.createElement(MemoizedText, {\n      ref: textRef,\n      annotations: annotations,\n      block: node.object === 'block' ? node : block,\n      decorations: decorations,\n      editor: editor,\n      key: child.key,\n      node: child,\n      parent: node,\n      readOnly: readOnly\n    });\n  };\n};\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$1 = Debug('slate:node');\n/**\n * Node.\n *\n * @type {Component}\n */\n\nvar Node$1 = function (_React$Component) {\n  inherits(Node$$1, _React$Component);\n\n  function Node$$1() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Node$$1);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Node$$1.__proto__ || Object.getPrototypeOf(Node$$1)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps$1.call(_this), _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Temporary values.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * A ref for the contenteditable DOM node.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n\n  createClass(Node$$1, [{\n    key: 'shouldComponentUpdate',\n\n    /**\n     * Should the node update?\n     *\n     * @param {Object} nextProps\n     * @param {Object} value\n     * @return {Boolean}\n     */\n    value: function shouldComponentUpdate(nextProps) {\n      var props = this.props;\n      var editor = props.editor;\n      var shouldUpdate = editor.run('shouldNodeComponentUpdate', props, nextProps);\n      var n = nextProps;\n      var p = props; // If the `Component` has a custom logic to determine whether the component\n      // needs to be updated or not, return true if it returns true. If it returns\n      // false, we need to ignore it, because it shouldn't be allowed it.\n\n      if (shouldUpdate != null) {\n        warning(false, 'As of slate-react@0.22 the `shouldNodeComponentUpdate` middleware is deprecated. You can pass specific values down the tree using React\\'s built-in \"context\" construct instead.');\n\n        if (shouldUpdate) {\n          return true;\n        }\n\n        warning(shouldUpdate !== false, \"Returning false in `shouldNodeComponentUpdate` does not disable Slate's internal `shouldComponentUpdate` logic. If you want to prevent updates, use React's `shouldComponentUpdate` instead.\");\n      } // If the `readOnly` status has changed, re-render in case there is any\n      // user-land logic that depends on it, like nested editable contents.\n\n\n      if (n.readOnly !== p.readOnly) {\n        return true;\n      } // If the node has changed, update. PERF: There are cases where it will have\n      // changed, but it's properties will be exactly the same (eg. copy-paste)\n      // which this won't catch. But that's rare and not a drag on performance, so\n      // for simplicity we just let them through.\n\n\n      if (n.node !== p.node) {\n        return true;\n      } // If the selection value of the node or of some of its children has changed,\n      // re-render in case there is any user-land logic depends on it to render.\n      // if the node is selected update it, even if it was already selected: the\n      // selection value of some of its children could have been changed and they\n      // need to be rendered again.\n\n\n      if (!n.selection && p.selection || n.selection && !p.selection || n.selection && p.selection && !n.selection.equals(p.selection)) {\n        return true;\n      } // If the annotations have changed, update.\n\n\n      if (!n.annotations.equals(p.annotations)) {\n        return true;\n      } // If the decorations have changed, update.\n\n\n      if (!n.decorations.equals(p.decorations)) {\n        return true;\n      } // Otherwise, don't update.\n\n\n      return false;\n    }\n    /**\n     * Render.\n     *\n     * @return {Element}\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this,\n          _attributes;\n\n      this.debug('render', this);\n      var _props = this.props,\n          annotations = _props.annotations,\n          block = _props.block,\n          decorations = _props.decorations,\n          editor = _props.editor,\n          node = _props.node,\n          parent = _props.parent,\n          readOnly = _props.readOnly,\n          selection = _props.selection;\n      var newDecorations = node.getDecorations(editor);\n      var children = node.nodes.toArray().map(function (child, i) {\n        var Component = child.object === 'text' ? MemoizedText : Node$$1;\n        var sel = selection && getRelativeRange(node, i, selection);\n        var decs = newDecorations.map(function (d) {\n          return getRelativeRange(node, i, d);\n        }).filter(function (d) {\n          return d;\n        }).concat(decorations);\n        var anns = annotations.map(function (a) {\n          return getRelativeRange(node, i, a);\n        }).filter(function (a) {\n          return a;\n        });\n        return React.createElement(Component, {\n          block: node.object === 'block' ? node : block,\n          editor: editor,\n          annotations: anns,\n          decorations: decs,\n          selection: sel,\n          key: child.key,\n          node: child,\n          parent: node,\n          readOnly: readOnly // COMPAT: We use this map of refs to lookup a DOM node down the\n          // tree of components by path.\n          ,\n          ref: function ref(_ref2) {\n            if (_ref2) {\n              _this2.tmp.nodeRefs[i] = _ref2;\n            } else {\n              delete _this2.tmp.nodeRefs[i];\n            }\n          }\n        });\n      }); // Attributes that the developer must mix into the element in their\n      // custom node renderer component.\n\n      var attributes = (_attributes = {}, defineProperty(_attributes, DATA_ATTRS.OBJECT, node.object), defineProperty(_attributes, DATA_ATTRS.KEY, node.key), defineProperty(_attributes, 'ref', this.ref), _attributes); // If it's a block node with inline children, add the proper `dir` attribute\n      // for text direction.\n\n      if (node.isLeafBlock()) {\n        var direction = node.getTextDirection();\n        if (direction === 'rtl') attributes.dir = 'rtl';\n      }\n\n      var render = void 0;\n\n      if (node.object === 'block') {\n        render = 'renderBlock';\n      } else if (node.object === 'document') {\n        render = 'renderDocument';\n      } else if (node.object === 'inline') {\n        render = 'renderInline';\n      }\n\n      var element = editor.run(render, {\n        attributes: attributes,\n        children: children,\n        editor: editor,\n        isFocused: !!selection && selection.isFocused,\n        isSelected: !!selection,\n        node: node,\n        parent: parent,\n        readOnly: readOnly\n      });\n      return editor.isVoid(node) ? React.createElement(Void, _extends({}, this.props, {\n        textRef: function textRef(ref) {\n          if (ref) {\n            _this2.tmp.nodeRefs[0] = ref;\n          } else {\n            delete _this2.tmp.nodeRefs[0];\n          }\n        }\n      }), element) : element;\n    }\n  }]);\n  return Node$$1;\n}(React.Component);\n/**\n * Return a `range` relative to a child at `index`.\n *\n * @param {Range} range\n * @param {Number} index\n * @return {Range}\n */\n\n\nNode$1.propTypes = {\n  annotations: ImmutableTypes.map.isRequired,\n  block: SlateTypes.block,\n  decorations: ImmutableTypes.list.isRequired,\n  editor: Types.object.isRequired,\n  node: SlateTypes.node.isRequired,\n  parent: SlateTypes.node,\n  readOnly: Types.bool.isRequired,\n  selection: SlateTypes.selection\n};\n\nvar _initialiseProps$1 = function _initialiseProps() {\n  var _this3 = this;\n\n  this.tmp = {\n    nodeRefs: {}\n  };\n  this.ref = React.createRef();\n\n  this.debug = function (message) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    var node = _this3.props.node;\n    var key = node.key,\n        type = node.type;\n    debug$1.apply(undefined, [message, key + ' (' + type + ')'].concat(args));\n  };\n};\n\nfunction getRelativeRange(node, index, range) {\n  if (range.isUnset) {\n    return null;\n  }\n\n  var child = node.nodes.get(index);\n  var _range = range,\n      start = _range.start,\n      end = _range.end;\n  var _start = start,\n      startPath = _start.path;\n  var _end = end,\n      endPath = _end.path;\n  var startIndex = startPath.first();\n  var endIndex = endPath.first();\n\n  if (startIndex === index) {\n    start = start.setPath(startPath.rest());\n  } else if (startIndex < index && index <= endIndex) {\n    if (child.object === 'text') {\n      start = start.moveTo(PathUtils.create([index]), 0);\n    } else {\n      var _child$texts = child.texts(),\n          _child$texts2 = slicedToArray(_child$texts, 1),\n          first = _child$texts2[0];\n\n      var _first = slicedToArray(first, 2),\n          firstPath = _first[1];\n\n      start = start.moveTo(firstPath, 0);\n    }\n  } else {\n    start = null;\n  }\n\n  if (endIndex === index) {\n    end = end.setPath(endPath.rest());\n  } else if (startIndex <= index && index < endIndex) {\n    if (child.object === 'text') {\n      end = end.moveTo(PathUtils.create([index]), child.text.length);\n    } else {\n      var _child$texts3 = child.texts({\n        direction: 'backward'\n      }),\n          _child$texts4 = slicedToArray(_child$texts3, 1),\n          last = _child$texts4[0];\n\n      var _last = slicedToArray(last, 2),\n          lastNode = _last[0],\n          lastPath = _last[1];\n\n      end = end.moveTo(lastPath, lastNode.text.length);\n    }\n  } else {\n    end = null;\n  }\n\n  if (!start || !end) {\n    return null;\n  }\n\n  range = range.setStart(start);\n  range = range.setEnd(end);\n  return range;\n}\n/**\n * CSS overflow values that would cause scrolling.\n *\n * @type {Array}\n */\n\n\nvar OVERFLOWS = ['auto', 'overlay', 'scroll'];\n/**\n * Detect whether we are running IOS version 11\n */\n\nvar IS_IOS_11 = IS_IOS && !!window.navigator.userAgent.match(/os 11_/i);\n/**\n * Find the nearest parent with scrolling, or window.\n *\n * @param {el} Element\n */\n\nfunction findScrollContainer(el, window) {\n  var parent = el.parentNode;\n  var scroller = void 0;\n\n  while (!scroller) {\n    if (!parent.parentNode) break;\n    var style = window.getComputedStyle(parent);\n    var overflowY = style.overflowY;\n\n    if (OVERFLOWS.includes(overflowY)) {\n      scroller = parent;\n      break;\n    }\n\n    parent = parent.parentNode;\n  } // COMPAT: Because Chrome does not allow doucment.body.scrollTop, we're\n  // assuming that window.scrollTo() should be used if the scrollable element\n  // turns out to be document.body or document.documentElement. This will work\n  // unless body is intentionally set to scrollable by restricting its height\n  // (e.g. height: 100vh).\n\n\n  if (!scroller) {\n    return window.document.body;\n  }\n\n  return scroller;\n}\n/**\n * Scroll the current selection's focus point into view if needed.\n *\n * @param {Selection} selection\n */\n\n\nfunction scrollToSelection(selection) {\n  if (IS_IOS_11) return;\n  if (!selection.anchorNode) return;\n  var window = getWindow(selection.anchorNode);\n  var scroller = findScrollContainer(selection.anchorNode, window);\n  var isWindow = scroller === window.document.body || scroller === window.document.documentElement;\n  var backward = isBackward(selection);\n  var range = selection.getRangeAt(0).cloneRange();\n  range.collapse(backward);\n  var cursorRect = range.getBoundingClientRect(); // COMPAT: range.getBoundingClientRect() returns 0s in Safari when range is\n  // collapsed. Expanding the range by 1 is a relatively effective workaround\n  // for vertical scroll, although horizontal may be off by 1 character.\n  // https://bugs.webkit.org/show_bug.cgi?id=138949\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=435438\n\n  if (IS_SAFARI) {\n    if (range.collapsed && cursorRect.top === 0 && cursorRect.height === 0) {\n      if (range.startOffset === 0) {\n        range.setEnd(range.endContainer, 1);\n      } else {\n        range.setStart(range.startContainer, range.startOffset - 1);\n      }\n\n      cursorRect = range.getBoundingClientRect();\n\n      if (cursorRect.top === 0 && cursorRect.height === 0) {\n        if (range.getClientRects().length) {\n          cursorRect = range.getClientRects()[0];\n        }\n      }\n    }\n  }\n\n  var width = void 0;\n  var height = void 0;\n  var yOffset = void 0;\n  var xOffset = void 0;\n  var scrollerTop = 0;\n  var scrollerLeft = 0;\n  var scrollerBordersY = 0;\n  var scrollerBordersX = 0;\n  var scrollerPaddingTop = 0;\n  var scrollerPaddingBottom = 0;\n  var scrollerPaddingLeft = 0;\n  var scrollerPaddingRight = 0;\n\n  if (isWindow) {\n    var innerWidth = window.innerWidth,\n        innerHeight = window.innerHeight,\n        pageYOffset = window.pageYOffset,\n        pageXOffset = window.pageXOffset;\n    width = innerWidth;\n    height = innerHeight;\n    yOffset = pageYOffset;\n    xOffset = pageXOffset;\n  } else {\n    var offsetWidth = scroller.offsetWidth,\n        offsetHeight = scroller.offsetHeight,\n        scrollTop = scroller.scrollTop,\n        scrollLeft = scroller.scrollLeft;\n\n    var _window$getComputedSt = window.getComputedStyle(scroller),\n        borderTopWidth = _window$getComputedSt.borderTopWidth,\n        borderBottomWidth = _window$getComputedSt.borderBottomWidth,\n        borderLeftWidth = _window$getComputedSt.borderLeftWidth,\n        borderRightWidth = _window$getComputedSt.borderRightWidth,\n        paddingTop = _window$getComputedSt.paddingTop,\n        paddingBottom = _window$getComputedSt.paddingBottom,\n        paddingLeft = _window$getComputedSt.paddingLeft,\n        paddingRight = _window$getComputedSt.paddingRight;\n\n    var scrollerRect = scroller.getBoundingClientRect();\n    width = offsetWidth;\n    height = offsetHeight;\n    scrollerTop = scrollerRect.top + parseInt(borderTopWidth, 10);\n    scrollerLeft = scrollerRect.left + parseInt(borderLeftWidth, 10);\n    scrollerBordersY = parseInt(borderTopWidth, 10) + parseInt(borderBottomWidth, 10);\n    scrollerBordersX = parseInt(borderLeftWidth, 10) + parseInt(borderRightWidth, 10);\n    scrollerPaddingTop = parseInt(paddingTop, 10);\n    scrollerPaddingBottom = parseInt(paddingBottom, 10);\n    scrollerPaddingLeft = parseInt(paddingLeft, 10);\n    scrollerPaddingRight = parseInt(paddingRight, 10);\n    yOffset = scrollTop;\n    xOffset = scrollLeft;\n  }\n\n  var cursorTop = cursorRect.top + yOffset - scrollerTop;\n  var cursorLeft = cursorRect.left + xOffset - scrollerLeft;\n  var x = xOffset;\n  var y = yOffset;\n\n  if (cursorLeft < xOffset) {\n    // selection to the left of viewport\n    x = cursorLeft - scrollerPaddingLeft;\n  } else if (cursorLeft + cursorRect.width + scrollerBordersX > xOffset + width) {\n    // selection to the right of viewport\n    x = cursorLeft + scrollerBordersX + scrollerPaddingRight - width;\n  }\n\n  if (cursorTop < yOffset) {\n    // selection above viewport\n    y = cursorTop - scrollerPaddingTop;\n  } else if (cursorTop + cursorRect.height + scrollerBordersY > yOffset + height) {\n    // selection below viewport\n    y = cursorTop + scrollerBordersY + scrollerPaddingBottom + cursorRect.height - height;\n  }\n\n  if (isWindow) {\n    window.scrollTo(x, y);\n  } else {\n    scroller.scrollTop = y;\n    scroller.scrollLeft = x;\n  }\n}\n/**\n * Cross-browser remove all ranges from a `domSelection`.\n *\n * @param {Selection} domSelection\n */\n\n\nfunction removeAllRanges(domSelection) {\n  // COMPAT: In IE 11, if the selection contains nested tables, then\n  // `removeAllRanges` will throw an error.\n  if (IS_IE) {\n    var range = window.document.body.createTextRange();\n    range.collapse();\n    range.select();\n  } else {\n    domSelection.removeAllRanges();\n  }\n}\n\nvar FIREFOX_NODE_TYPE_ACCESS_ERROR = /Permission denied to access property \"nodeType\"/;\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug$2 = Debug('slate:content');\n/**\n * Separate debug to easily see when the DOM has updated either by render or\n * changing selection.\n *\n * @type {Function}\n */\n\ndebug$2.update = Debug('slate:update');\n/**\n * Content.\n *\n * @type {Component}\n */\n\nvar Content = function (_React$Component) {\n  inherits(Content, _React$Component);\n\n  function Content() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Content);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Content.__proto__ || Object.getPrototypeOf(Content)).call.apply(_ref, [this].concat(args))), _this), _this.tmp = {\n      isUpdatingSelection: false,\n      nodeRef: React.createRef(),\n      nodeRefs: {}\n      /**\n       * A ref for the contenteditable DOM node.\n       *\n       * @type {Object}\n       */\n\n    }, _this.ref = React.createRef(), _this.handlers = EVENT_HANDLERS.reduce(function (obj, handler) {\n      obj[handler] = function (event) {\n        return _this.onEvent(handler, event);\n      };\n\n      return obj;\n    }, {}), _this.updateSelection = function () {\n      var editor = _this.props.editor;\n      var value = editor.value;\n      var selection = value.selection;\n      var isBackward$$1 = selection.isBackward;\n      var window = getWindow(_this.ref.current);\n\n      var _native2 = window.getSelection();\n\n      var activeElement = window.document.activeElement;\n\n      if (debug$2.enabled) {\n        debug$2.update('updateSelection', {\n          selection: selection.toJSON()\n        });\n      } // COMPAT: In Firefox, there's a but where `getSelection` can return `null`.\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=827585 (2018/11/07)\n\n\n      if (!_native2) {\n        return;\n      }\n\n      var rangeCount = _native2.rangeCount,\n          anchorNode = _native2.anchorNode;\n      var updated = false; // If the Slate selection is blurred, but the DOM's active element is still\n      // the editor, we need to blur it.\n\n      if (selection.isBlurred && activeElement === _this.ref.current) {\n        _this.ref.current.blur();\n\n        updated = true;\n      } // If the Slate selection is unset, but the DOM selection has a range\n      // selected in the editor, we need to remove the range.\n\n\n      if (selection.isUnset && rangeCount && _this.isInEditor(anchorNode)) {\n        removeAllRanges(_native2);\n        updated = true;\n      } // If the Slate selection is focused, but the DOM's active element is not\n      // the editor, we need to focus it. We prevent scrolling because we handle\n      // scrolling to the correct selection.\n\n\n      if (selection.isFocused && activeElement !== _this.ref.current) {\n        _this.ref.current.focus({\n          preventScroll: true\n        });\n\n        updated = true;\n      } // Otherwise, figure out which DOM nodes should be selected...\n\n\n      if (selection.isFocused && selection.isSet) {\n        var current = !!rangeCount && _native2.getRangeAt(0);\n\n        var range = editor.findDOMRange(selection);\n\n        if (!range) {\n          warning(false, 'Unable to find a native DOM range from the current selection.');\n          return;\n        }\n\n        var startContainer = range.startContainer,\n            startOffset = range.startOffset,\n            endContainer = range.endContainer,\n            endOffset = range.endOffset; // If the new range matches the current selection, there is nothing to fix.\n        // COMPAT: The native `Range` object always has it's \"start\" first and \"end\"\n        // last in the DOM. It has no concept of \"backwards/forwards\", so we have\n        // to check both orientations here. (2017/10/31)\n\n        if (current) {\n          if (startContainer === current.startContainer && startOffset === current.startOffset && endContainer === current.endContainer && endOffset === current.endOffset || startContainer === current.endContainer && startOffset === current.endOffset && endContainer === current.startContainer && endOffset === current.startOffset) {\n            return;\n          }\n        } // Otherwise, set the `isUpdatingSelection` flag and update the selection.\n\n\n        updated = true;\n        _this.tmp.isUpdatingSelection = true;\n        removeAllRanges(_native2); // COMPAT: IE 11 does not support `setBaseAndExtent`. (2018/11/07)\n\n        if (_native2.setBaseAndExtent) {\n          // COMPAT: Since the DOM range has no concept of backwards/forwards\n          // we need to check and do the right thing here.\n          if (isBackward$$1) {\n            _native2.setBaseAndExtent(range.endContainer, range.endOffset, range.startContainer, range.startOffset);\n          } else {\n            _native2.setBaseAndExtent(range.startContainer, range.startOffset, range.endContainer, range.endOffset);\n          }\n        } else {\n          _native2.addRange(range);\n        } // Scroll to the selection, in case it's out of view.\n\n\n        scrollToSelection(_native2); // Then unset the `isUpdatingSelection` flag after a delay, to ensure that\n        // it is still set when selection-related events from updating it fire.\n\n        setTimeout(function () {\n          // COMPAT: In Firefox, it's not enough to create a range, you also need\n          // to focus the contenteditable element too. (2016/11/16)\n          if (IS_FIREFOX && _this.ref.current) {\n            _this.ref.current.focus();\n          }\n\n          _this.tmp.isUpdatingSelection = false;\n        });\n      }\n\n      if (updated && debug$2.enabled) {\n        debug$2('updateSelection', {\n          selection: selection,\n          native: _native2,\n          activeElement: activeElement\n        });\n        debug$2.update('updateSelection-applied', {\n          selection: selection\n        });\n      }\n    }, _this.isInEditor = function (target) {\n      var el = void 0;\n\n      try {\n        // COMPAT: In Firefox, sometimes the node can be comment which doesn't\n        // have .closest and it crashes.\n        if (target.nodeType === 8) {\n          return false;\n        } // COMPAT: Text nodes don't have `isContentEditable` property. So, when\n        // `target` is a text node use its parent node for check.\n\n\n        el = target.nodeType === 3 ? target.parentNode : target;\n      } catch (err) {\n        // COMPAT: In Firefox, `target.nodeType` will throw an error if target is\n        // originating from an internal \"restricted\" element (e.g. a stepper\n        // arrow on a number input)\n        // see github.com/ianstormtaylor/slate/issues/1819\n        if (IS_FIREFOX && FIREFOX_NODE_TYPE_ACCESS_ERROR.test(err.message)) {\n          return false;\n        }\n\n        throw err;\n      }\n\n      return el.isContentEditable && (el === _this.ref.current || el.closest(SELECTORS.EDITOR) === _this.ref.current);\n    }, _this.onNativeSelectionChange = throttle(function (event) {\n      if (_this.props.readOnly) return;\n      var window = getWindow(event.target);\n      var activeElement = window.document.activeElement;\n      if (activeElement !== _this.ref.current) return;\n\n      _this.props.onEvent('onSelect', event);\n    }, 100), _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n\n  createClass(Content, [{\n    key: 'componentDidCatch',\n\n    /**\n     * An error boundary. If there is a render error, we increment `errorKey`\n     * which is part of the container `key` which forces a re-render from\n     * scratch.\n     *\n     * @param {Error} error\n     * @param {String} info\n     */\n    value: function componentDidCatch(error, info) {\n      debug$2('componentDidCatch', {\n        error: error,\n        info: info\n      }); // The call to `setState` is required despite not setting a value.\n      // Without this call, React will not try to recreate the component tree.\n\n      this.setState({});\n    }\n    /**\n     * Temporary values.\n     *\n     * @type {Object}\n     */\n\n    /**\n     * Create a set of bound event handlers.\n     *\n     * @type {Object}\n     */\n\n  }, {\n    key: 'componentDidMount',\n\n    /**\n     * When the editor first mounts in the DOM we need to:\n     *\n     *   - Add native DOM event listeners.\n     *   - Update the selection, in case it starts focused.\n     */\n    value: function componentDidMount() {\n      var window = getWindow(this.ref.current);\n      window.document.addEventListener('selectionchange', this.onNativeSelectionChange); // COMPAT: Restrict scope of `beforeinput` to clients that support the\n      // Input Events Level 2 spec, since they are preventable events.\n\n      if (HAS_INPUT_EVENTS_LEVEL_2) {\n        this.ref.current.addEventListener('beforeinput', this.handlers.onBeforeInput);\n      }\n\n      this.updateSelection();\n    }\n    /**\n     * When unmounting, remove DOM event listeners.\n     */\n\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      var window = getWindow(this.ref.current);\n\n      if (window) {\n        window.document.removeEventListener('selectionchange', this.onNativeSelectionChange);\n      }\n\n      if (HAS_INPUT_EVENTS_LEVEL_2) {\n        this.ref.current.removeEventListener('beforeinput', this.handlers.onBeforeInput);\n      }\n    }\n    /**\n     * On update, update the selection.\n     */\n\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      debug$2.update('componentDidUpdate');\n      this.updateSelection();\n    }\n    /**\n     * Update the native DOM selection to reflect the internal model.\n     */\n\n    /**\n     * Check if an event `target` is fired from within the contenteditable\n     * element. This should be false for edits happening in non-contenteditable\n     * children, such as void nodes and other nested Slate editors.\n     *\n     * @param {Element} target\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'onEvent',\n\n    /**\n     * On `event` with `handler`.\n     *\n     * @param {String} handler\n     * @param {Event} event\n     */\n    value: function onEvent(handler, event) {\n      debug$2('onEvent', handler); // Ignore `onBlur`, `onFocus` and `onSelect` events generated\n      // programmatically while updating selection.\n\n      if (this.tmp.isUpdatingSelection && (handler === 'onSelect' || handler === 'onBlur' || handler === 'onFocus')) {\n        return;\n      } // COMPAT: There are situations where a select event will fire with a new\n      // native selection that resolves to the same internal position. In those\n      // cases we don't need to trigger any changes, since our internal model is\n      // already up to date, but we do want to update the native selection again\n      // to make sure it is in sync. (2017/10/16)\n      //\n      // ANDROID: The updateSelection causes issues in Android when you are\n      // at the end of a block. The selection ends up to the left of the inserted\n      // character instead of to the right. This behavior continues even if\n      // you enter more than one character. (2019/01/03)\n\n\n      if (!IS_ANDROID && handler === 'onSelect') {\n        var editor = this.props.editor;\n        var value = editor.value;\n        var selection = value.selection;\n        var window = getWindow(event.target);\n        var domSelection = window.getSelection();\n        var range = editor.findRange(domSelection);\n\n        if (range && range.equals(selection.toRange())) {\n          this.updateSelection();\n          return;\n        }\n      } // Don't handle drag and drop events coming from embedded editors.\n\n\n      if (handler === 'onDragEnd' || handler === 'onDragEnter' || handler === 'onDragExit' || handler === 'onDragLeave' || handler === 'onDragOver' || handler === 'onDragStart' || handler === 'onDrop') {\n        var closest = event.target.closest(SELECTORS.EDITOR);\n\n        if (closest !== this.ref.current) {\n          return;\n        }\n      } // Some events require being in editable in the editor, so if the event\n      // target isn't, ignore them.\n\n\n      if (handler === 'onBeforeInput' || handler === 'onBlur' || handler === 'onCompositionEnd' || handler === 'onCompositionStart' || handler === 'onCopy' || handler === 'onCut' || handler === 'onFocus' || handler === 'onInput' || handler === 'onKeyDown' || handler === 'onKeyUp' || handler === 'onPaste' || handler === 'onSelect') {\n        if (!this.isInEditor(event.target)) {\n          return;\n        }\n      }\n\n      this.props.onEvent(handler, event);\n    }\n    /**\n     * On native `selectionchange` event, trigger the `onSelect` handler. This is\n     * needed to account for React's `onSelect` being non-standard and not firing\n     * until after a selection has been released. This causes issues in situations\n     * where another change happens while a selection is being made.\n     *\n     * @param {Event} event\n     */\n\n  }, {\n    key: 'render',\n\n    /**\n     * Render the editor content.\n     *\n     * @return {Element}\n     */\n    value: function render() {\n      var _data;\n\n      var props = this.props,\n          handlers = this.handlers;\n      var id = props.id,\n          className = props.className,\n          readOnly = props.readOnly,\n          editor = props.editor,\n          tabIndex = props.tabIndex,\n          role = props.role,\n          tagName = props.tagName,\n          spellCheck = props.spellCheck;\n      var value = editor.value;\n      var Container = tagName;\n      var document = value.document,\n          selection = value.selection;\n\n      var style = _extends({\n        // Prevent the default outline styles.\n        outline: 'none',\n        // Preserve adjacent whitespace and new lines.\n        whiteSpace: 'pre-wrap',\n        // Allow words to break if they are too long.\n        wordWrap: 'break-word'\n      }, readOnly ? {} : {\n        WebkitUserModify: 'read-write-plaintext-only'\n      }, props.style);\n\n      debug$2('render', {\n        props: props\n      });\n      var data = (_data = {}, defineProperty(_data, DATA_ATTRS.EDITOR, true), defineProperty(_data, DATA_ATTRS.KEY, document.key), _data);\n      return React.createElement(Container, _extends({\n        key: this.props.contentKey\n      }, handlers, data, {\n        ref: this.ref,\n        contentEditable: readOnly ? null : true,\n        suppressContentEditableWarning: true,\n        id: id,\n        className: className,\n        autoCorrect: props.autoCorrect ? 'on' : 'off',\n        spellCheck: spellCheck,\n        style: style,\n        role: readOnly ? null : role || 'textbox',\n        tabIndex: tabIndex // COMPAT: The Grammarly Chrome extension works by changing the DOM out\n        // from under `contenteditable` elements, which leads to weird behaviors\n        // so we have to disable it like this. (2017/04/24)\n        ,\n        'data-gramm': false\n      }), React.createElement(Node$1, {\n        annotations: value.annotations,\n        block: null,\n        decorations: List(),\n        editor: editor,\n        node: document,\n        parent: null,\n        readOnly: readOnly,\n        selection: selection,\n        ref: this.tmp.nodeRef\n      }));\n    }\n  }]);\n  return Content;\n}(React.Component);\n/**\n * Export.\n *\n * @type {Component}\n */\n\n\nContent.propTypes = {\n  autoCorrect: Types.bool.isRequired,\n  className: Types.string,\n  contentKey: Types.number,\n  editor: Types.object.isRequired,\n  id: Types.string,\n  readOnly: Types.bool.isRequired,\n  role: Types.string,\n  spellCheck: Types.bool.isRequired,\n  style: Types.object,\n  tabIndex: Types.number,\n  tagName: Types.string\n};\nContent.defaultProps = {\n  style: {},\n  tagName: 'div'\n};\n/**\n * Props that can be defined by plugins.\n *\n * @type {Array}\n */\n\nvar PROPS = [].concat(toConsumableArray(EVENT_HANDLERS), ['commands', 'decorateNode', 'queries', 'renderAnnotation', 'renderBlock', 'renderDecoration', 'renderDocument', 'renderEditor', 'renderInline', 'renderMark', 'schema']);\n/**\n * The top-level editor props in a plugin.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction EditorPropsPlugin() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var plugin = PROPS.reduce(function (memo, prop) {\n    if (prop in options) memo[prop] = options[prop];\n    return memo;\n  }, {});\n  return plugin;\n}\n/**\n * The default rendering behavior for the React plugin.\n *\n * @return {Object}\n */\n\n\nfunction Rendering() {\n  return {\n    decorateNode: function decorateNode() {\n      return [];\n    },\n    renderAnnotation: function renderAnnotation(_ref) {\n      var attributes = _ref.attributes,\n          children = _ref.children;\n      return React.createElement('span', attributes, children);\n    },\n    renderBlock: function renderBlock(_ref2) {\n      var attributes = _ref2.attributes,\n          children = _ref2.children;\n      return React.createElement('div', _extends({}, attributes, {\n        style: {\n          position: 'relative'\n        }\n      }), children);\n    },\n    renderDecoration: function renderDecoration(_ref3) {\n      var attributes = _ref3.attributes,\n          children = _ref3.children;\n      return React.createElement('span', attributes, children);\n    },\n    renderDocument: function renderDocument(_ref4) {\n      var children = _ref4.children;\n      return children;\n    },\n    renderEditor: function renderEditor(_ref5) {\n      var children = _ref5.children;\n      return children;\n    },\n    renderInline: function renderInline(_ref6) {\n      var attributes = _ref6.attributes,\n          children = _ref6.children;\n      return React.createElement('span', _extends({}, attributes, {\n        style: {\n          position: 'relative'\n        }\n      }), children);\n    },\n    renderMark: function renderMark(_ref7) {\n      var attributes = _ref7.attributes,\n          children = _ref7.children;\n      return React.createElement('span', attributes, children);\n    }\n  };\n}\n/**\n * A set of queries for the React plugin.\n *\n * @return {Object}\n */\n\n\nfunction QueriesPlugin() {\n  /**\n   * Find the native DOM element for a node at `path`.\n   *\n   * @param {Editor} editor\n   * @param {Array|List} path\n   * @return {DOMNode|Null}\n   */\n  function findDOMNode(editor, path) {\n    path = PathUtils.create(path);\n    var content = editor.tmp.contentRef.current;\n\n    if (!path.size) {\n      return content.ref.current || null;\n    }\n\n    var search = function search(instance, p) {\n      if (!instance) {\n        return null;\n      }\n\n      if (!p.size) {\n        if (instance.ref) {\n          return instance.ref.current || null;\n        } else {\n          return instance || null;\n        }\n      }\n\n      var index = p.first();\n      var rest = p.rest();\n      var ref = instance.tmp.nodeRefs[index];\n      return search(ref, rest);\n    };\n\n    var document = content.tmp.nodeRef.current;\n    var el = search(document, path);\n    return el;\n  }\n  /**\n   * Find a native DOM selection point from a Slate `point`.\n   *\n   * @param {Editor} editor\n   * @param {Point} point\n   * @return {Object|Null}\n   */\n\n\n  function findDOMPoint(editor, point) {\n    var el = editor.findDOMNode(point.path);\n    var start = 0;\n\n    if (!el) {\n      return null;\n    } // For each leaf, we need to isolate its content, which means filtering to its\n    // direct text and zero-width spans. (We have to filter out any other siblings\n    // that may have been rendered alongside them.)\n\n\n    var texts = Array.from(el.querySelectorAll(SELECTORS.STRING + ', ' + SELECTORS.ZERO_WIDTH));\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = texts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var text = _step.value;\n        var node = text.childNodes[0];\n        var domLength = node.textContent.length;\n        var slateLength = domLength;\n\n        if (text.hasAttribute(DATA_ATTRS.LENGTH)) {\n          slateLength = parseInt(text.getAttribute(DATA_ATTRS.LENGTH), 10);\n        }\n\n        var end = start + slateLength;\n\n        if (point.offset <= end) {\n          var offset = Math.min(domLength, Math.max(0, point.offset - start));\n          return {\n            node: node,\n            offset: offset\n          };\n        }\n\n        start = end;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Find a native DOM range from a Slate `range`.\n   *\n   * @param {Editor} editor\n   * @param {Range} range\n   * @return {DOMRange|Null}\n   */\n\n\n  function findDOMRange(editor, range) {\n    var anchor = range.anchor,\n        focus = range.focus,\n        isBackward$$1 = range.isBackward,\n        isCollapsed = range.isCollapsed;\n    var domAnchor = editor.findDOMPoint(anchor);\n    var domFocus = isCollapsed ? domAnchor : editor.findDOMPoint(focus);\n\n    if (!domAnchor || !domFocus) {\n      return null;\n    }\n\n    var window = getWindow(domAnchor.node);\n    var r = window.document.createRange();\n    var start = isBackward$$1 ? domFocus : domAnchor;\n    var end = isBackward$$1 ? domAnchor : domFocus;\n    r.setStart(start.node, start.offset);\n    r.setEnd(end.node, end.offset);\n    return r;\n  }\n  /**\n   * Find a Slate node from a native DOM `element`.\n   *\n   * @param {Editor} editor\n   * @param {Element} element\n   * @return {List|Null}\n   */\n\n\n  function findNode(editor, element) {\n    var path = editor.findPath(element);\n\n    if (!path) {\n      return null;\n    }\n\n    var value = editor.value;\n    var document = value.document;\n    var node = document.getNode(path);\n    return node;\n  }\n  /**\n   * Get the target range from a DOM `event`.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @return {Range}\n   */\n\n\n  function findEventRange(editor, event) {\n    if (event.nativeEvent) {\n      event = event.nativeEvent;\n    }\n\n    var _event = event,\n        x = _event.clientX,\n        y = _event.clientY,\n        target = _event.target;\n    if (x == null || y == null) return null;\n    var value = editor.value;\n    var document = value.document;\n    var path = editor.findPath(event.target);\n    if (!path) return null;\n    var node = document.getNode(path); // If the drop target is inside a void node, move it into either the next or\n    // previous node, depending on which side the `x` and `y` coordinates are\n    // closest to.\n\n    if (editor.isVoid(node)) {\n      var rect = target.getBoundingClientRect();\n      var isPrevious = node.object === 'inline' ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n\n      var _range = document.createRange();\n\n      var iterable = isPrevious ? 'previousTexts' : 'nextTexts';\n      var move = isPrevious ? 'moveToEndOfNode' : 'moveToStartOfNode';\n      var entry = document[iterable](path);\n\n      if (entry) {\n        var _entry = slicedToArray(entry, 1),\n            n = _entry[0];\n\n        return _range[move](n);\n      }\n\n      return null;\n    } // Else resolve a range from the caret position where the drop occured.\n\n\n    var window = getWindow(target);\n\n    var _native3 = void 0; // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n\n\n    if (window.document.caretRangeFromPoint) {\n      _native3 = window.document.caretRangeFromPoint(x, y);\n    } else if (window.document.caretPositionFromPoint) {\n      var position = window.document.caretPositionFromPoint(x, y);\n      _native3 = window.document.createRange();\n\n      _native3.setStart(position.offsetNode, position.offset);\n\n      _native3.setEnd(position.offsetNode, position.offset);\n    } else if (window.document.body.createTextRange) {\n      // COMPAT: In IE, `caretRangeFromPoint` and\n      // `caretPositionFromPoint` don't exist. (2018/07/11)\n      _native3 = window.document.body.createTextRange();\n\n      try {\n        _native3.moveToPoint(x, y);\n      } catch (error) {\n        // IE11 will raise an `unspecified error` if `moveToPoint` is\n        // called during a dropEvent.\n        return null;\n      }\n    } // Resolve a Slate range from the DOM range.\n\n\n    var range = editor.findRange(_native3);\n    return range;\n  }\n  /**\n   * Find the path of a native DOM `element` by searching React refs.\n   *\n   * @param {Editor} editor\n   * @param {Element} element\n   * @return {List|Null}\n   */\n\n\n  function findPath(editor, element) {\n    var content = editor.tmp.contentRef.current;\n\n    if (element === content.ref.current) {\n      return PathUtils.create([]);\n    }\n\n    var search = function search(instance, p) {\n      if (element === instance) {\n        return p;\n      }\n\n      if (!instance.ref) {\n        return null;\n      }\n\n      if (element === instance.ref.current) {\n        return p;\n      } // If there's no `tmp` then we're at a leaf node without success.\n\n\n      if (!instance.tmp) {\n        return null;\n      }\n\n      var nodeRefs = instance.tmp.nodeRefs;\n      var keys = Object.keys(nodeRefs);\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var i = _step2.value;\n          var ref = nodeRefs[i];\n          var n = parseInt(i, 10);\n\n          var _path = search(ref, [].concat(toConsumableArray(p), [n]));\n\n          if (_path) {\n            return _path;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return null;\n    };\n\n    var document = content.tmp.nodeRef.current;\n    var path = search(document, []);\n\n    if (!path) {\n      return null;\n    }\n\n    return PathUtils.create(path);\n  }\n  /**\n   * Find a Slate point from a DOM selection's `nativeNode` and `nativeOffset`.\n   *\n   * @param {Editor} editor\n   * @param {Element} nativeNode\n   * @param {Number} nativeOffset\n   * @return {Point}\n   */\n\n\n  function findPoint(editor, nativeNode, nativeOffset) {\n    var _normalizeNodeAndOffs = normalizeNodeAndOffset(nativeNode, nativeOffset),\n        nearestNode = _normalizeNodeAndOffs.node,\n        nearestOffset = _normalizeNodeAndOffs.offset;\n\n    var window = getWindow(nativeNode);\n    var parentNode = nearestNode.parentNode;\n    var leafNode = parentNode.closest(SELECTORS.LEAF);\n    var textNode = void 0;\n    var offset = void 0;\n    var node = void 0; // Calculate how far into the text node the `nearestNode` is, so that we can\n    // determine what the offset relative to the text node is.\n\n    if (leafNode) {\n      textNode = leafNode.closest(SELECTORS.TEXT);\n      var range = window.document.createRange();\n      range.setStart(textNode, 0);\n      range.setEnd(nearestNode, nearestOffset);\n      var contents = range.cloneContents();\n      var utilityNodes = contents.querySelectorAll([SELECTORS.ZERO_WIDTH, SELECTORS.ANNOTATION + ' *:not(' + SELECTORS.STRING + ')']);\n      Array.from(utilityNodes).forEach(function (el) {\n        el.parentNode.removeChild(el);\n      }); // COMPAT: Edge has a bug where Range.prototype.toString() will convert \\n\n      // into \\r\\n. The bug causes a loop when slate-react attempts to reposition\n      // its cursor to match the native position. Use textContent.length instead.\n      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n\n      offset = contents.textContent.length;\n      node = textNode;\n    } else {\n      // For void nodes, the element with the offset key will be a cousin, not an\n      // ancestor, so find it by going down from the nearest void parent.\n      var voidNode = parentNode.closest(SELECTORS.VOID);\n\n      if (!voidNode) {\n        return null;\n      }\n\n      leafNode = voidNode.querySelector(SELECTORS.LEAF);\n\n      if (!leafNode) {\n        return null;\n      }\n\n      textNode = leafNode.closest(SELECTORS.TEXT);\n      node = leafNode;\n      offset = node.textContent.length;\n    } // COMPAT: If the parent node is a Slate zero-width space, this is because the\n    // text node should have no characters. However, during IME composition the\n    // ASCII characters will be prepended to the zero-width space, so subtract 1\n    // from the offset to account for the zero-width space character.\n\n\n    if (offset === node.textContent.length && parentNode.hasAttribute(DATA_ATTRS.ZERO_WIDTH)) {\n      offset--;\n    } // COMPAT: If someone is clicking from one Slate editor into another, the\n    // select event fires twice, once for the old editor's `element` first, and\n    // then afterwards for the correct `element`. (2017/03/03)\n\n\n    var path = editor.findPath(textNode);\n\n    if (!path) {\n      return null;\n    }\n\n    var value = editor.value;\n    var document = value.document;\n    var point = document.createPoint({\n      path: path,\n      offset: offset\n    });\n    return point;\n  }\n  /**\n   * Find a Slate range from a DOM range or selection.\n   *\n   * @param {Editor} editor\n   * @param {Selection} domRange\n   * @return {Range}\n   */\n\n\n  function findRange(editor, domRange) {\n    var el = domRange.anchorNode || domRange.startContainer;\n\n    if (!el) {\n      return null;\n    }\n\n    var window = getWindow(el); // If the `domRange` object is a DOM `Range` or `StaticRange` object, change it\n    // into something that looks like a DOM `Selection` instead.\n\n    if (domRange instanceof window.Range || window.StaticRange && domRange instanceof window.StaticRange) {\n      domRange = {\n        anchorNode: domRange.startContainer,\n        anchorOffset: domRange.startOffset,\n        focusNode: domRange.endContainer,\n        focusOffset: domRange.endOffset\n      };\n    }\n\n    var _domRange = domRange,\n        anchorNode = _domRange.anchorNode,\n        anchorOffset = _domRange.anchorOffset,\n        focusNode = _domRange.focusNode,\n        focusOffset = _domRange.focusOffset,\n        isCollapsed = _domRange.isCollapsed;\n    var value = editor.value;\n    var anchor = editor.findPoint(anchorNode, anchorOffset);\n    var focus = isCollapsed ? anchor : editor.findPoint(focusNode, focusOffset);\n\n    if (!anchor || !focus) {\n      return null;\n    }\n\n    var document = value.document;\n    var range = document.createRange({\n      anchor: anchor,\n      focus: focus\n    });\n    return range;\n  }\n  /**\n   * Find a Slate selection from a DOM selection.\n   *\n   * @param {Editor} editor\n   * @param {Selection} domSelection\n   * @return {Range}\n   */\n\n\n  function findSelection(editor, domSelection) {\n    var value = editor.value;\n    var document = value.document; // If there are no ranges, the editor was blurred natively.\n\n    if (!domSelection.rangeCount) {\n      return null;\n    } // Otherwise, determine the Slate selection from the native one.\n\n\n    var range = editor.findRange(domSelection);\n\n    if (!range) {\n      return null;\n    }\n\n    var _range2 = range,\n        anchor = _range2.anchor,\n        focus = _range2.focus;\n    var anchorText = document.getNode(anchor.path);\n    var focusText = document.getNode(focus.path);\n    var anchorInline = document.getClosestInline(anchor.path);\n    var focusInline = document.getClosestInline(focus.path);\n    var focusBlock = document.getClosestBlock(focus.path);\n    var anchorBlock = document.getClosestBlock(anchor.path); // COMPAT: If the anchor point is at the start of a non-void, and the\n    // focus point is inside a void node with an offset that isn't `0`, set\n    // the focus offset to `0`. This is due to void nodes <span>'s being\n    // positioned off screen, resulting in the offset always being greater\n    // than `0`. Since we can't know what it really should be, and since an\n    // offset of `0` is less destructive because it creates a hanging\n    // selection, go with `0`. (2017/09/07)\n\n    if (anchorBlock && !editor.isVoid(anchorBlock) && anchor.offset === 0 && focusBlock && editor.isVoid(focusBlock) && focus.offset !== 0) {\n      range = range.setFocus(focus.setOffset(0));\n    } // COMPAT: If the selection is at the end of a non-void inline node, and\n    // there is a node after it, put it in the node after instead. This\n    // standardizes the behavior, since it's indistinguishable to the user.\n\n\n    if (anchorInline && !editor.isVoid(anchorInline) && anchor.offset === anchorText.text.length) {\n      var block = document.getClosestBlock(anchor.path);\n\n      var _block$texts = block.texts({\n        path: anchor.path\n      }),\n          _block$texts2 = slicedToArray(_block$texts, 1),\n          next = _block$texts2[0];\n\n      if (next) {\n        var _next = slicedToArray(next, 2),\n            nextPath = _next[1];\n\n        range = range.moveAnchorTo(nextPath, 0);\n      }\n    }\n\n    if (focusInline && !editor.isVoid(focusInline) && focus.offset === focusText.text.length) {\n      var _block = document.getClosestBlock(focus.path);\n\n      var _block$texts3 = _block.texts({\n        path: focus.path\n      }),\n          _block$texts4 = slicedToArray(_block$texts3, 1),\n          _next2 = _block$texts4[0];\n\n      if (_next2) {\n        var _next3 = slicedToArray(_next2, 2),\n            _nextPath = _next3[1];\n\n        range = range.moveFocusTo(_nextPath, 0);\n      }\n    }\n\n    var selection = document.createSelection(range); // COMPAT: Ensure that the `isFocused` argument is set.\n\n    selection = selection.setIsFocused(true); // COMPAT: Preserve the marks, since we have no way of knowing what the DOM\n    // selection's marks were. They will be cleared automatically by the\n    // `select` command if the selection moves.\n\n    selection = selection.set('marks', value.selection.marks);\n    return selection;\n  }\n\n  return {\n    queries: {\n      findDOMNode: findDOMNode,\n      findDOMPoint: findDOMPoint,\n      findDOMRange: findDOMRange,\n      findEventRange: findEventRange,\n      findNode: findNode,\n      findPath: findPath,\n      findPoint: findPoint,\n      findRange: findRange,\n      findSelection: findSelection\n    }\n  };\n}\n/**\n * From a DOM selection's `node` and `offset`, normalize so that it always\n * refers to a text node.\n *\n * @param {Element} node\n * @param {Number} offset\n * @return {Object}\n */\n\n\nfunction normalizeNodeAndOffset(node, offset) {\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (node.nodeType === 1 && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var direction = isLast ? 'backward' : 'forward';\n    var index = isLast ? offset - 1 : offset;\n    node = getEditableChild(node, index, direction); // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n\n    while (node.nodeType === 1 && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, direction);\n    } // Determine the new offset inside the text node.\n\n\n    offset = isLast ? node.textContent.length : 0;\n  } // Return the node and offset.\n\n\n  return {\n    node: node,\n    offset: offset\n  };\n}\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n *\n * @param {Element} parent\n * @param {Number} index\n * @param {String} direction ('forward' or 'backward')\n * @return {Element|Null}\n */\n\n\nfunction getEditableChild(parent, index, direction) {\n  var childNodes = parent.childNodes;\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false; // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n\n  while (child.nodeType === 8 || child.nodeType === 1 && child.childNodes.length === 0 || child.nodeType === 1 && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) break;\n\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n\n    child = childNodes[i];\n    if (direction === 'forward') i++;\n    if (direction === 'backward') i--;\n  }\n\n  return child || null;\n}\n/**\n * Fixes a selection within the DOM when the cursor is in Slate's special\n * zero-width block. Slate handles empty blocks in a special manner and the\n * cursor can end up either before or after the non-breaking space. This\n * causes different behavior in Android and so we make sure the seleciton is\n * always before the zero-width space.\n *\n * @param {Window} window\n */\n\n\nfunction fixSelectionInZeroWidthBlock(window) {\n  var domSelection = window.getSelection();\n  var anchorNode = domSelection.anchorNode;\n  var dataset = anchorNode.parentElement.dataset;\n  var isZeroWidth = dataset ? dataset.slateZeroWidth === 'n' : false; // We are doing three checks to see if we need to move the cursor.\n  // Is this a zero-width slate span?\n  // Is the current cursor position not at the start of it?\n  // Is there more than one character (i.e. the zero-width space char) in here?\n\n  if (isZeroWidth && anchorNode.textContent.length === 1 && domSelection.anchorOffset !== 0) {\n    var range = window.document.createRange();\n    range.setStart(anchorNode, 0);\n    range.setEnd(anchorNode, 0);\n    domSelection.removeAllRanges();\n    domSelection.addRange(range);\n  }\n}\n/**\n * Find a Slate point from a DOM selection's `nativeNode` and `nativeOffset`.\n *\n * @param {Element} nativeNode\n * @param {Number} nativeOffset\n * @param {Editor} editor\n * @return {Point}\n */\n\n\nfunction findPoint(nativeNode, nativeOffset, editor) {\n  warning(false, 'As of slate-react@0.22 the `findPoint(node, offset)` helper is deprecated in favor of `editor.findPoint(node, offset)`.');\n  invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `findPoint` utility takes an `editor` instead of a `value`.');\n\n  var _normalizeNodeAndOffs = normalizeNodeAndOffset$1(nativeNode, nativeOffset),\n      nearestNode = _normalizeNodeAndOffs.node,\n      nearestOffset = _normalizeNodeAndOffs.offset;\n\n  var window = getWindow(nativeNode);\n  var parentNode = nearestNode.parentNode;\n  var rangeNode = parentNode.closest(SELECTORS.LEAF);\n  var offset = void 0;\n  var node = void 0; // Calculate how far into the text node the `nearestNode` is, so that we can\n  // determine what the offset relative to the text node is.\n\n  if (rangeNode) {\n    var range = window.document.createRange();\n    var textNode = rangeNode.closest(SELECTORS.TEXT);\n    range.setStart(textNode, 0);\n    range.setEnd(nearestNode, nearestOffset);\n    node = textNode; // COMPAT: Edge has a bug where Range.prototype.toString() will convert \\n\n    // into \\r\\n. The bug causes a loop when slate-react attempts to reposition\n    // its cursor to match the native position. Use textContent.length instead.\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n\n    offset = range.cloneContents().textContent.length;\n  } else {\n    // For void nodes, the element with the offset key will be a cousin, not an\n    // ancestor, so find it by going down from the nearest void parent.\n    var voidNode = parentNode.closest(SELECTORS.VOID);\n    if (!voidNode) return null;\n    rangeNode = voidNode.querySelector(SELECTORS.LEAF);\n    if (!rangeNode) return null;\n    node = rangeNode;\n    offset = node.textContent.length;\n  } // COMPAT: If the parent node is a Slate zero-width space, this is because the\n  // text node should have no characters. However, during IME composition the\n  // ASCII characters will be prepended to the zero-width space, so subtract 1\n  // from the offset to account for the zero-width space character.\n\n\n  if (offset === node.textContent.length && parentNode.hasAttribute(DATA_ATTRS.ZERO_WIDTH)) {\n    offset--;\n  } // Get the string value of the offset key attribute.\n\n\n  var offsetKey = rangeNode.getAttribute(DATA_ATTRS.OFFSET_KEY);\n  if (!offsetKey) return null;\n\n  var _OffsetKey$parse = OffsetKey.parse(offsetKey),\n      key = _OffsetKey$parse.key; // COMPAT: If someone is clicking from one Slate editor into another, the\n  // select event fires twice, once for the old editor's `element` first, and\n  // then afterwards for the correct `element`. (2017/03/03)\n\n\n  var value = editor.value;\n  if (!value.document.hasDescendant(key)) return null;\n  var point = value.document.createPoint({\n    key: key,\n    offset: offset\n  });\n  return point;\n}\n/**\n * From a DOM selection's `node` and `offset`, normalize so that it always\n * refers to a text node.\n *\n * @param {Element} node\n * @param {Number} offset\n * @return {Object}\n */\n\n\nfunction normalizeNodeAndOffset$1(node, offset) {\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (node.nodeType === 1 && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var direction = isLast ? 'backward' : 'forward';\n    var index = isLast ? offset - 1 : offset;\n    node = getEditableChild$1(node, index, direction); // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n\n    while (node.nodeType === 1 && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild$1(node, i, direction);\n    } // Determine the new offset inside the text node.\n\n\n    offset = isLast ? node.textContent.length : 0;\n  } // Return the node and offset.\n\n\n  return {\n    node: node,\n    offset: offset\n  };\n}\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n *\n * @param {Element} parent\n * @param {Number} index\n * @param {String} direction ('forward' or 'backward')\n * @return {Element|Null}\n */\n\n\nfunction getEditableChild$1(parent, index, direction) {\n  var childNodes = parent.childNodes;\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false; // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n\n  while (child.nodeType === 8 || child.nodeType === 1 && child.childNodes.length === 0 || child.nodeType === 1 && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) break;\n\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n\n    child = childNodes[i];\n    if (direction === 'forward') i++;\n    if (direction === 'backward') i--;\n  }\n\n  return child || null;\n}\n/**\n * Find a Slate range from a DOM `native` selection.\n *\n * @param {Selection} native\n * @param {Editor} editor\n * @return {Range}\n */\n\n\nfunction findRange(_native4, editor) {\n  warning(false, 'As of slate-react@0.22 the `findRange(selection)` helper is deprecated in favor of `editor.findRange(selection)`.');\n  invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.');\n  var el = _native4.anchorNode || _native4.startContainer;\n  if (!el) return null;\n  var window = getWindow(el); // If the `native` object is a DOM `Range` or `StaticRange` object, change it\n  // into something that looks like a DOM `Selection` instead.\n\n  if (_native4 instanceof window.Range || window.StaticRange && _native4 instanceof window.StaticRange) {\n    _native4 = {\n      anchorNode: _native4.startContainer,\n      anchorOffset: _native4.startOffset,\n      focusNode: _native4.endContainer,\n      focusOffset: _native4.endOffset\n    };\n  }\n\n  var _native = _native4,\n      anchorNode = _native.anchorNode,\n      anchorOffset = _native.anchorOffset,\n      focusNode = _native.focusNode,\n      focusOffset = _native.focusOffset,\n      isCollapsed = _native.isCollapsed;\n  var value = editor.value;\n  var anchor = findPoint(anchorNode, anchorOffset, editor);\n  var focus = isCollapsed ? anchor : findPoint(focusNode, focusOffset, editor);\n  if (!anchor || !focus) return null;\n  var document = value.document;\n  var range = document.createRange({\n    anchor: anchor,\n    focus: focus\n  });\n  return range;\n}\n\nfunction getSelectionFromDOM(window, editor, domSelection) {\n  warning(false, 'As of slate-react@0.22 the `getSelectionFromDOM(window, editor, domSelection)` helper is deprecated in favor of `editor.findSelection(domSelection)`.');\n  var value = editor.value;\n  var document = value.document; // If there are no ranges, the editor was blurred natively.\n\n  if (!domSelection.rangeCount) {\n    editor.blur();\n    return;\n  } // Otherwise, determine the Slate selection from the native one.\n\n\n  var range = findRange(domSelection, editor);\n\n  if (!range) {\n    return;\n  }\n\n  var _range = range,\n      anchor = _range.anchor,\n      focus = _range.focus;\n  var anchorText = document.getNode(anchor.path);\n  var focusText = document.getNode(focus.path);\n  var anchorInline = document.getClosestInline(anchor.path);\n  var focusInline = document.getClosestInline(focus.path);\n  var focusBlock = document.getClosestBlock(focus.path);\n  var anchorBlock = document.getClosestBlock(anchor.path); // COMPAT: If the anchor point is at the start of a non-void, and the\n  // focus point is inside a void node with an offset that isn't `0`, set\n  // the focus offset to `0`. This is due to void nodes <span>'s being\n  // positioned off screen, resulting in the offset always being greater\n  // than `0`. Since we can't know what it really should be, and since an\n  // offset of `0` is less destructive because it creates a hanging\n  // selection, go with `0`. (2017/09/07)\n\n  if (anchorBlock && !editor.isVoid(anchorBlock) && anchor.offset === 0 && focusBlock && editor.isVoid(focusBlock) && focus.offset !== 0) {\n    range = range.setFocus(focus.setOffset(0));\n  } // COMPAT: If the selection is at the end of a non-void inline node, and\n  // there is a node after it, put it in the node after instead. This\n  // standardizes the behavior, since it's indistinguishable to the user.\n\n\n  if (anchorInline && !editor.isVoid(anchorInline) && anchor.offset === anchorText.text.length) {\n    var block = document.getClosestBlock(anchor.path);\n\n    var _block$texts = block.texts({\n      path: anchor.path\n    }),\n        _block$texts2 = slicedToArray(_block$texts, 1),\n        next = _block$texts2[0];\n\n    if (next) {\n      var _next = slicedToArray(next, 2),\n          nextPath = _next[1];\n\n      range = range.moveAnchorTo(nextPath, 0);\n    }\n  }\n\n  if (focusInline && !editor.isVoid(focusInline) && focus.offset === focusText.text.length) {\n    var _block = document.getClosestBlock(focus.path);\n\n    var _block$texts3 = _block.texts({\n      path: focus.path\n    }),\n        _block$texts4 = slicedToArray(_block$texts3, 1),\n        _next2 = _block$texts4[0];\n\n    if (_next2) {\n      var _next3 = slicedToArray(_next2, 2),\n          _nextPath = _next3[1];\n\n      range = range.moveFocusTo(_nextPath, 0);\n    }\n  }\n\n  var selection = document.createSelection(range);\n  selection = selection.setIsFocused(true); // Preserve active marks from the current selection.\n  // They will be cleared by `editor.select` if the selection actually moved.\n\n  selection = selection.set('marks', value.selection.marks);\n  return selection;\n}\n/**\n * setTextFromDomNode lets us take a domNode and reconcile the text in the\n * editor's Document such that it reflects the text in the DOM. This is the\n * opposite of what the Editor usually does which takes the Editor's Document\n * and React modifies the DOM to match. The purpose of this method is for\n * composition changes where we don't know what changes the user made by\n * looking at events. Instead we wait until the DOM is in a safe state, we\n * read from it, and update the Editor's Document.\n *\n * @param {Window} window\n * @param {Editor} editor\n * @param {Node} domNode\n */\n\n\nfunction setTextFromDomNode(window, editor, domNode) {\n  var point = findPoint(domNode, 0, editor);\n  if (!point) return; // Get the text node and leaf in question.\n\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var node = document.getDescendant(point.path);\n  var block = document.getClosestBlock(point.path);\n  var leaves = node.getLeaves();\n  var lastText = block.getLastText();\n  var lastLeaf = leaves.last();\n  var start = 0;\n  var end = 0;\n  var leaf = leaves.find(function (r) {\n    start = end;\n    end += r.text.length;\n    if (end > point.offset) return true;\n  }) || lastLeaf; // Get the text information.\n\n  var text = leaf.text;\n  var textContent = domNode.textContent;\n  var isLastText = node === lastText;\n  var isLastLeaf = leaf === lastLeaf;\n  var lastChar = textContent.charAt(textContent.length - 1); // COMPAT: If this is the last leaf, and the DOM text ends in a new line,\n  // we will have added another new line in <Leaf>'s render method to account\n  // for browsers collapsing a single trailing new lines, so remove it.\n\n  if (isLastText && isLastLeaf && lastChar === '\\n') {\n    textContent = textContent.slice(0, -1);\n  } // If the text is no different, abort.\n\n\n  if (textContent === text) return; // Determine what the selection should be after changing the text.\n  // const delta = textContent.length - text.length\n  // const corrected = selection.moveToEnd().moveForward(delta)\n\n  var entire = selection.moveAnchorTo(point.path, start).moveFocusTo(point.path, end);\n  entire = document.resolveRange(entire); // Change the current value to have the leaf's text replaced.\n\n  editor.insertTextAtRange(entire, textContent, leaf.marks);\n}\n/**\n * In Android API 26 and 27 we can tell if the input key was pressed by\n * waiting for the `beforeInput` event and seeing that the last character\n * of its `data` property is char code `10`.\n *\n * Note that at this point it is too late to prevent the event from affecting\n * the DOM so we use other methods to clean the DOM up after we have detected\n * the input.\n *\n * @param  {String} data\n * @return {Boolean}\n */\n\n\nfunction isInputDataEnter(data) {\n  if (data == null) return false;\n  var lastChar = data[data.length - 1];\n  var charCode = lastChar.charCodeAt(0);\n  return charCode === 10;\n}\n/**\n * In Android sometimes the only way to tell what the user is trying to do\n * is to look at an event's `data` property and see if the last characters\n * matches a character. This method helps us make that determination.\n *\n * @param {String} data\n * @param {[String]} chars\n * @return {Boolean}\n */\n\n\nfunction isInputDataLastChar(data, chars) {\n  if (!Array.isArray(chars)) throw new Error(\"chars must be an array of one character strings\");\n  if (data == null) return false;\n  var lastChar = data[data.length - 1];\n  return chars.includes(lastChar);\n}\n/**\n * Is the given node a text node?\n *\n * @param {node} node\n * @param {Window} window\n * @return {Boolean}\n */\n\n\nfunction isTextNode(node, window) {\n  return node.nodeType === window.Node.TEXT_NODE;\n}\n/**\n * Takes a node and returns a snapshot of the node.\n *\n * @param {node} node\n * @param {Window} window\n * @return {object} element snapshot\n */\n\n\nfunction getElementSnapshot(node, window) {\n  var snapshot = {};\n  snapshot.node = node;\n\n  if (isTextNode(node, window)) {\n    snapshot.text = node.textContent;\n  }\n\n  snapshot.children = Array.from(node.childNodes).map(function (childNode) {\n    return getElementSnapshot(childNode, window);\n  });\n  return snapshot;\n}\n/**\n * Takes an array of elements and returns a snapshot\n *\n * @param {elements[]} elements\n * @param {Window} window\n * @return {object} snapshot\n */\n\n\nfunction getSnapshot(elements, window) {\n  if (!elements.length) throw new Error('elements must be an Array');\n  var lastElement = elements[elements.length - 1];\n  var snapshot = {\n    elements: elements.map(function (element) {\n      return getElementSnapshot(element, window);\n    }),\n    parent: lastElement.parentElement,\n    next: lastElement.nextElementSibling\n  };\n  return snapshot;\n}\n/**\n * Takes an element snapshot and applies it to the element in the DOM.\n * Basically, it fixes the DOM to the point in time that the snapshot was\n * taken. This will put the DOM back in sync with React.\n *\n * @param {Object} snapshot\n * @param {Window} window\n */\n\n\nfunction applyElementSnapshot(snapshot, window) {\n  var el = snapshot.node;\n\n  if (isTextNode(el, window)) {\n    // Update text if it is different\n    if (el.textContent !== snapshot.text) {\n      el.textContent = snapshot.text;\n    }\n  }\n\n  snapshot.children.forEach(function (childSnapshot) {\n    applyElementSnapshot(childSnapshot, window);\n    el.appendChild(childSnapshot.node);\n  }); // remove children that shouldn't be there\n\n  var snapLength = snapshot.children.length;\n\n  while (el.childNodes.length > snapLength) {\n    el.removeChild(el.childNodes[0]);\n  } // remove any clones from the DOM. This can happen when a block is split.\n\n\n  var dataset = el.dataset;\n  if (!dataset) return; // if there's no dataset, don't remove it\n\n  var key = dataset.key;\n  if (!key) return; // if there's no `data-key`, don't remove it\n\n  var dups = new window.Set(Array.from(window.document.querySelectorAll('[' + DATA_ATTRS.KEY + '=\"' + key + '\"]')));\n  dups.delete(el);\n  dups.forEach(function (dup) {\n    return dup.parentElement.removeChild(dup);\n  });\n}\n/**\n * Takes a snapshot and applies it to the DOM. Rearranges both the contents\n * of the elements in the snapshot as well as putting the elements back into\n * position relative to each other and also makes sure the last element is\n * before the same element as it was when the snapshot was taken.\n *\n * @param {snapshot} snapshot\n * @param {Window} window\n */\n\n\nfunction applySnapshot(snapshot, window) {\n  var elements = snapshot.elements,\n      next = snapshot.next,\n      parent = snapshot.parent;\n  elements.forEach(function (element) {\n    return applyElementSnapshot(element, window);\n  });\n  var lastElement = elements[elements.length - 1].node;\n\n  if (snapshot.next) {\n    parent.insertBefore(lastElement, next);\n  } else {\n    parent.appendChild(lastElement);\n  }\n\n  var prevElement = lastElement;\n\n  for (var i = elements.length - 2; i >= 0; i--) {\n    var element = elements[i].node;\n    parent.insertBefore(element, prevElement);\n    prevElement = element;\n  }\n}\n/**\n * A snapshot of one or more elements.\n */\n\n\nvar ElementSnapshot = function () {\n  /**\n   * constructor\n   * @param {elements[]} elements - array of element to snapshot. Must be in order.\n   * @param {object} data - any arbitrary data you want to store with the snapshot\n   */\n  function ElementSnapshot(elements, data) {\n    classCallCheck(this, ElementSnapshot);\n    this.window = getWindow(elements[0]);\n    this.snapshot = getSnapshot(elements, this.window);\n    this.data = data;\n  }\n  /**\n   * apply the current snapshot to the DOM.\n   */\n\n\n  createClass(ElementSnapshot, [{\n    key: 'apply',\n    value: function apply() {\n      applySnapshot(this.snapshot, this.window);\n    }\n    /**\n     * get the data you passed into the constructor.\n     *\n     * @return {object} data\n     */\n\n  }, {\n    key: 'getData',\n    value: function getData() {\n      return this.data;\n    }\n  }]);\n  return ElementSnapshot;\n}();\n/**\n * Returns the closest element that matches the selector.\n * Unlike the native `Element.closest` method, this doesn't require the\n * starting node to be an Element.\n *\n * @param  {Node} node to start at\n * @param  {String} css selector to match\n * @return {Element} the closest matching element\n */\n\n\nfunction closest(node, selector) {\n  var win = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window;\n\n  if (node.nodeType === win.Node.TEXT_NODE) {\n    node = node.parentNode;\n  }\n\n  return node.closest(selector);\n}\n/**\n * A DomSnapshot remembers the state of elements at a given point in time\n * and also remembers the state of the Editor at that time as well.\n * The state can be applied to the DOM at a time in the future.\n */\n\n\nvar DomSnapshot = function () {\n  /**\n   * Constructor.\n   *\n   * @param {Window} window\n   * @param {Editor} editor\n   * @param {Boolean} options.before - should we remember the element before the one passed in\n   */\n  function DomSnapshot(window, editor) {\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref$before = _ref.before,\n        before = _ref$before === undefined ? false : _ref$before;\n\n    classCallCheck(this, DomSnapshot);\n    var domSelection = window.getSelection();\n    var anchorNode = domSelection.anchorNode;\n    var subrootEl = closest(anchorNode, SELECTORS.EDITOR + ' > *');\n    var elements = [subrootEl]; // The before option is for when we need to take a snapshot of the current\n    // subroot and the element before when the user hits the backspace key.\n\n    if (before) {\n      var previousElementSibling = subrootEl.previousElementSibling;\n\n      if (previousElementSibling) {\n        elements.unshift(previousElementSibling);\n      }\n    }\n\n    this.snapshot = new ElementSnapshot(elements);\n    this.selection = getSelectionFromDOM(window, editor, domSelection);\n  }\n  /**\n   * Apply the snapshot to the DOM and set the selection in the Editor.\n   *\n   * @param {Editor} editor\n   */\n\n\n  createClass(DomSnapshot, [{\n    key: 'apply',\n    value: function apply(editor) {\n      var snapshot = this.snapshot,\n          selection = this.selection;\n      snapshot.apply();\n      editor.moveTo(selection.anchor.path, selection.anchor.offset);\n    }\n  }]);\n  return DomSnapshot;\n}();\n/**\n * A function that does nothing\n * @return {Function}\n */\n\n\nfunction noop() {}\n/**\n * Creates an executor like a `resolver` or a `deleter` that handles\n * delayed execution of a method using a `requestAnimationFrame` or `setTimeout`.\n *\n * Unlike a `requestAnimationFrame`, after a method is cancelled, it can be\n * resumed. You can also optionally add a `timeout` after which time the\n * executor is automatically cancelled.\n */\n\n\nvar Executor =\n/**\n * Executor\n * @param {window} window\n * @param {Function} fn - the function to execute when done\n * @param {Object} options\n */\nfunction Executor(window, fn) {\n  var _this = this;\n\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  classCallCheck(this, Executor);\n\n  this.__call__ = function () {\n    // I don't clear the timeout since it will be noop'ed anyways. Less code.\n    _this.fn();\n\n    _this.preventFurtherCalls(); // Ensure you can only call the function once\n\n  };\n\n  this.preventFurtherCalls = function () {\n    _this.fn = noop;\n  };\n\n  this.resume = function (ms) {\n    // in case resume is called more than once, we don't want old timers\n    // from executing because the `timeoutId` or `callbackId` is overwritten.\n    _this.cancel();\n\n    if (ms) {\n      _this.mode = 'timeout';\n      _this.timeoutId = _this.window.setTimeout(_this.__call__, ms);\n    } else {\n      _this.mode = 'animationFrame';\n      _this.callbackId = _this.window.requestAnimationFrame(_this.__call__);\n    }\n  };\n\n  this.cancel = function () {\n    if (_this.mode === 'timeout') {\n      _this.window.clearTimeout(_this.timeoutId);\n    } else {\n      _this.window.cancelAnimationFrame(_this.callbackId);\n    }\n\n    if (_this.onCancel) _this.onCancel();\n  };\n\n  this.__setTimeout__ = function (timeout) {\n    if (timeout == null) return;\n\n    _this.window.setTimeout(function () {\n      _this.cancel();\n\n      _this.preventFurtherCalls();\n    }, timeout);\n  };\n\n  this.fn = fn;\n  this.window = window;\n  this.resume();\n  this.onCancel = options.onCancel;\n\n  this.__setTimeout__(options.timeout);\n};\n\nvar debug$3 = Debug('slate:android');\ndebug$3.reconcile = Debug('slate:reconcile');\ndebug$3('ANDROID_API_VERSION', {\n  ANDROID_API_VERSION: ANDROID_API_VERSION\n});\n/**\n * Define variables related to composition state.\n */\n\nvar NONE = 0;\nvar COMPOSING = 1;\n\nfunction AndroidPlugin() {\n  /**\n   * The current state of composition.\n   *\n   * @type {NONE|COMPOSING|WAITING}\n   */\n  var status = NONE;\n  /**\n   * The set of nodes that we need to process when we next reconcile.\n   * Usually this is soon after the `onCompositionEnd` event.\n   *\n   * @type {Set} set containing Node objects\n   */\n\n  var nodes = new window.Set();\n  /**\n   * Keep a snapshot after a composition end for API 26/27. If a `beforeInput`\n   * gets called with data that ends in an ENTER then we need to use this\n   * snapshot to revert the DOM so that React doesn't get out of sync with the\n   * DOM. We also need to cancel the `reconcile` operation as it interferes in\n   * certain scenarios like hitting 'enter' at the end of a word.\n   *\n   * @type {DomSnapshot} [compositionEndSnapshot]\n    */\n\n  var compositionEndSnapshot = null;\n  /**\n   * When there is a `compositionEnd` we ened to reconcile Slate's Document\n   * with the DOM. The `reconciler` is an instance of `Executor` that does\n   * this for us. It is created on every `compositionEnd` and executes on the\n   * next `requestAnimationFrame`. The `Executor` can be cancelled and resumed\n   * which some methods do.\n   *\n   * @type {Executor}\n   */\n\n  var reconciler = null;\n  /**\n   * A snapshot that gets taken when there is a `keydown` event in API26/27.\n   * If an `input` gets called with `inputType` of `deleteContentBackward`\n   * we need to undo the delete that Android does to keep React in sync with\n   * the DOM.\n   *\n   * @type {DomSnapshot}\n   */\n\n  var keyDownSnapshot = null;\n  /**\n   * The deleter is an instace of `Executor` that will execute a delete\n   * operation on the next `requestAnimationFrame`. It has to wait because\n   * we need Android to finish all of its DOM operations to do with deletion\n   * before we revert them to a Snapshot. After reverting, we then execute\n   * Slate's version of delete.\n   *\n   * @type {Executor}\n   */\n\n  var deleter = null;\n  /**\n   * Because Slate implements its own event handler for `beforeInput` in\n   * addition to React's version, we actually get two. If we cancel the\n   * first native version, the React one will still fire. We set this to\n   * `true` if we don't want that to happen. Remember that when we prevent it,\n   * we need to tell React to `preventDefault` so the event doesn't continue\n   * through React's event system.\n   *\n   * type {Boolean}\n   */\n\n  var preventNextBeforeInput = false;\n  /**\n   * When a composition ends, in some API versions we may need to know what we\n   * have learned so far about the composition and what we want to do because of\n   * some actions that may come later.\n   *\n   * For example in API 26/27, if we get a `beforeInput` that tells us that the\n   * input was a `.`, then we want the reconcile to happen even if there are\n   * `onInput:delete` events that follow. In this case, we would set\n   * `compositionEndAction` to `period`. During the `onInput` we would check if\n   * the `compositionEndAction` says `period` and if so we would not start the\n   * `delete` action.\n   *\n   * @type {(String|null)}\n   */\n\n  var compositionEndAction = null;\n  /**\n   * Looks at the `nodes` we have collected, usually the things we have edited\n   * during the course of a composition, and then updates Slate's internal\n   * Document based on the text values in these DOM nodes and also updates\n   * Slate's Selection based on the current cursor position in the Editor.\n   *\n   * @param {Window} window\n   * @param {Editor} editor\n   * @param {String} options.from - where reconcile was called from for debug\n   */\n\n  function reconcile(window, editor, _ref) {\n    var from = _ref.from;\n    debug$3.reconcile({\n      from: from\n    });\n    var domSelection = window.getSelection();\n    var selection = getSelectionFromDOM(window, editor, domSelection);\n    nodes.forEach(function (node) {\n      setTextFromDomNode(window, editor, node);\n    });\n    editor.select(selection);\n    nodes.clear();\n  }\n  /**\n   * On before input.\n   *\n   * Check `components/content` because some versions of Android attach a\n   * native `beforeinput` event on the Editor. In this case, you might need\n   * to distinguish whether the event coming through is the native or React\n   * version of the event. Also, if you cancel the native version that does\n   * not necessarily mean that the React version is cancelled.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onBeforeInput(event, editor, next) {\n    var isNative = !event.nativeEvent;\n    debug$3('onBeforeInput', {\n      isNative: isNative,\n      event: event,\n      status: status,\n      e: pick(event, ['data', 'inputType', 'isComposing', 'nativeEvent'])\n    });\n    var window = getWindow(event.target);\n\n    if (preventNextBeforeInput) {\n      event.preventDefault();\n      preventNextBeforeInput = false;\n      return;\n    }\n\n    switch (ANDROID_API_VERSION) {\n      case 25:\n        // prevent onBeforeInput to allow selecting an alternate suggest to\n        // work.\n        break;\n\n      case 26:\n      case 27:\n        if (deleter) {\n          deleter.cancel();\n          reconciler.resume();\n        } // This analyses Android's native `beforeInput` which Slate adds\n        // on in the `Content` component. It only fires if the cursor is at\n        // the end of a block. Otherwise, the code below checks.\n\n\n        if (isNative) {\n          if (event.inputType === 'insertParagraph' || event.inputType === 'insertLineBreak') {\n            debug$3('onBeforeInput:enter:native', {});\n            var domSelection = window.getSelection();\n            var selection = getSelectionFromDOM(window, editor, domSelection);\n            preventNextBeforeInput = true;\n            event.preventDefault();\n            editor.moveTo(selection.anchor.path, selection.anchor.offset);\n            editor.splitBlock();\n          }\n        } else {\n          if (isInputDataLastChar(event.data, ['.'])) {\n            debug$3('onBeforeInput:period');\n            reconciler.cancel();\n            compositionEndAction = 'period';\n            return;\n          } // This looks at the beforeInput event's data property and sees if it\n          // ends in a linefeed which is character code 10. This appears to be\n          // the only way to detect that enter has been pressed except at end\n          // of line where it doesn't work.\n\n\n          var isEnter = isInputDataEnter(event.data);\n\n          if (isEnter) {\n            if (reconciler) reconciler.cancel();\n            window.requestAnimationFrame(function () {\n              debug$3('onBeforeInput:enter:react', {});\n              compositionEndSnapshot.apply(editor);\n              editor.splitBlock();\n            });\n          }\n        }\n\n        break;\n\n      case 28:\n        // If a `beforeInput` event fires after an `input:deleteContentBackward`\n        // event, it appears to be a good indicator that it is some sort of\n        // special combined Android event. If this is the case, then we don't\n        // want to have a deletion to happen, we just want to wait until Android\n        // has done its thing and then at the end we just want to reconcile.\n        if (deleter) {\n          deleter.cancel();\n          reconciler.resume();\n        }\n\n        break;\n\n      default:\n        if (status !== COMPOSING) next();\n    }\n  }\n  /**\n   * On Composition end. By default, when a `compositionEnd` event happens,\n   * we start a reconciler. The reconciler will update Slate's Document using\n   * the DOM as the source of truth. In some cases, the reconciler needs to\n   * be cancelled and can also be resumed. For example, when a delete\n   * immediately followed a `compositionEnd`, we don't want to reconcile.\n   * Instead, we want the `delete` to take precedence.\n   *\n   * @param  {Event} event\n   * @param  {Editor} editor\n   * @param  {Function} next\n   */\n\n\n  function onCompositionEnd(event, editor, next) {\n    debug$3('onCompositionEnd', {\n      event: event\n    });\n    var window = getWindow(event.target);\n    var domSelection = window.getSelection();\n    var anchorNode = domSelection.anchorNode;\n\n    switch (ANDROID_API_VERSION) {\n      case 26:\n      case 27:\n        compositionEndSnapshot = new DomSnapshot(window, editor); // fixes a bug in Android API 26 & 27 where a `compositionEnd` is triggered\n        // without the corresponding `compositionStart` event when clicking a\n        // suggestion.\n        //\n        // If we don't add this, the `onBeforeInput` is triggered and passes\n        // through to the `before` plugin.\n\n        status = COMPOSING;\n        break;\n    }\n\n    compositionEndAction = 'reconcile';\n    nodes.add(anchorNode);\n    reconciler = new Executor(window, function () {\n      status = NONE;\n      reconcile(window, editor, {\n        from: 'onCompositionEnd:reconciler'\n      });\n      compositionEndAction = null;\n    });\n  }\n  /**\n   * On composition start.\n   *\n   * @param  {Event} event\n   * @param  {Editor} editor\n   * @param  {Function} next\n   */\n\n\n  function onCompositionStart(event, editor, next) {\n    debug$3('onCompositionStart', {\n      event: event\n    });\n    status = COMPOSING;\n    nodes.clear();\n  }\n  /**\n   * On composition update.\n   *\n   * @param  {Event} event\n   * @param  {Editor} editor\n   * @param  {Function} next\n   */\n\n\n  function onCompositionUpdate(event, editor, next) {\n    debug$3('onCompositionUpdate', {\n      event: event\n    });\n  }\n  /**\n   * On input.\n   *\n   * @param  {Event} event\n   * @param  {Editor} editor\n   * @param  {Function} next\n   */\n\n\n  function onInput(event, editor, next) {\n    debug$3('onInput', {\n      event: event,\n      status: status,\n      e: pick(event, ['data', 'nativeEvent', 'inputType', 'isComposing'])\n    });\n\n    switch (ANDROID_API_VERSION) {\n      case 24:\n      case 25:\n        break;\n\n      case 26:\n      case 27:\n      case 28:\n        var nativeEvent = event.nativeEvent;\n\n        if (ANDROID_API_VERSION === 28) {\n          // NOTE API 28:\n          // When a user hits space and then backspace in `middle` we end up\n          // with `midle`.\n          //\n          // This is because when the user hits space, the composition is not\n          // ended because `compositionEnd` is not called yet. When backspace is\n          // hit, the `compositionEnd` is called. We need to revert the DOM but\n          // the reconciler has not had a chance to run from the\n          // `compositionEnd` because it is set to run on the next\n          // `requestAnimationFrame`. When the backspace is carried out on the\n          // Slate Value, Slate doesn't know about the space yet so the\n          // backspace is carried out without the space cuasing us to lose a\n          // character.\n          //\n          // This fix forces Android to reconcile immediately after hitting\n          // the space.\n          //\n          // NOTE API 27:\n          // It is confirmed that this bug does not present itself on API27.\n          // A space fires a `compositionEnd` (as well as other events including\n          // an input that is a delete) so the reconciliation happens.\n          //\n          if (nativeEvent.inputType === 'insertText' && nativeEvent.data === ' ') {\n            if (reconciler) reconciler.cancel();\n            if (deleter) deleter.cancel();\n            reconcile(window, editor, {\n              from: 'onInput:space'\n            });\n            return;\n          }\n        }\n\n        if (ANDROID_API_VERSION === 26 || ANDROID_API_VERSION === 27) {\n          if (compositionEndAction === 'period') {\n            debug$3('onInput:period:abort'); // This means that there was a `beforeInput` that indicated the\n            // period was pressed. When a period is pressed, you get a bunch\n            // of delete actions mixed in. We want to ignore those. At this\n            // point, we add the current node to the list of things we need to\n            // resolve at the next compositionEnd. We know that a new\n            // composition will start right after this event so it is safe to\n            // do this.\n\n            var _window$getSelection = window.getSelection(),\n                anchorNode = _window$getSelection.anchorNode;\n\n            nodes.add(anchorNode);\n            return;\n          }\n        }\n\n        if (nativeEvent.inputType === 'deleteContentBackward') {\n          debug$3('onInput:delete', {\n            keyDownSnapshot: keyDownSnapshot\n          });\n\n          var _window = getWindow(event.target);\n\n          if (reconciler) reconciler.cancel();\n          if (deleter) deleter.cancel();\n          deleter = new Executor(_window, function () {\n            debug$3('onInput:delete:callback', {\n              keyDownSnapshot: keyDownSnapshot\n            });\n            keyDownSnapshot.apply(editor);\n            editor.deleteBackward();\n            deleter = null;\n          }, {\n            onCancel: function onCancel() {\n              deleter = null;\n            }\n          });\n          return;\n        }\n\n        if (status === COMPOSING) {\n          var _window$getSelection2 = window.getSelection(),\n              _anchorNode = _window$getSelection2.anchorNode;\n\n          nodes.add(_anchorNode);\n          return;\n        } // Some keys like '.' are input without compositions. This happens\n        // in API28. It might be happening in API 27 as well. Check by typing\n        // `It me. No.` On a blank line.\n\n\n        if (ANDROID_API_VERSION === 28) {\n          debug$3('onInput:fallback');\n\n          var _window$getSelection3 = window.getSelection(),\n              _anchorNode2 = _window$getSelection3.anchorNode;\n\n          nodes.add(_anchorNode2);\n          window.requestAnimationFrame(function () {\n            debug$3('onInput:fallback:callback');\n            reconcile(window, editor, {\n              from: 'onInput:fallback'\n            });\n          });\n          return;\n        }\n\n        break;\n\n      default:\n        if (status === COMPOSING) return;\n        next();\n    }\n  }\n  /**\n   * On key down.\n   *\n   * @param  {Event} event\n   * @param  {Editor} editor\n   * @param  {Function} next\n   */\n\n\n  function onKeyDown(event, editor, next) {\n    debug$3('onKeyDown', {\n      event: event,\n      status: status,\n      e: pick(event, ['char', 'charCode', 'code', 'key', 'keyCode', 'keyIdentifier', 'keyLocation', 'location', 'nativeEvent', 'which'])\n    });\n    var window = getWindow(event.target);\n\n    switch (ANDROID_API_VERSION) {\n      // 1. We want to allow enter keydown to allows go through\n      // 2. We want to deny keydown, I think, when it fires before the composition\n      //    or something. Need to remember what it was.\n      case 25:\n        // in API25 prevent other keys to fix clicking a word and then\n        // selecting an alternate suggestion.\n        //\n        // NOTE:\n        // The `setSelectionFromDom` is to allow hitting `Enter` to work\n        // because the selection needs to be in the right place; however,\n        // for now we've removed the cancelling of `onSelect` and everything\n        // appears to be working. Not sure why we removed `onSelect` though\n        // in API25.\n        if (event.key === 'Enter') {\n          // const window = getWindow(event.target)\n          // const selection = window.getSelection()\n          // setSelectionFromDom(window, editor, selection)\n          next();\n        }\n\n        break;\n\n      case 26:\n      case 27:\n        if (event.key === 'Enter') {\n          debug$3('onKeyDown:enter', {});\n\n          if (deleter) {\n            // If a `deleter` exists which means there was an onInput with\n            // `deleteContentBackward` that hasn't fired yet, then we know\n            // this is one of the cases where we have to revert to before\n            // the split.\n            deleter.cancel();\n            event.preventDefault();\n            window.requestAnimationFrame(function () {\n              debug$3('onKeyDown:enter:callback');\n              compositionEndSnapshot.apply(editor);\n              editor.splitBlock();\n            });\n          } else {\n            event.preventDefault(); // If there is no deleter, all we have to do is prevent the\n            // action before applying or splitBlock. In this scenario, we\n            // have to grab the selection from the DOM.\n\n            var domSelection = window.getSelection();\n            var selection = getSelectionFromDOM(window, editor, domSelection);\n            editor.moveTo(selection.anchor.path, selection.anchor.offset);\n            editor.splitBlock();\n          }\n\n          return;\n        } // We need to take a snapshot of the current selection and the\n        // element before when the user hits the backspace key. This is because\n        // we only know if the user hit backspace if the `onInput` event that\n        // follows has an `inputType` of `deleteContentBackward`. At that time\n        // it's too late to stop the event.\n\n\n        keyDownSnapshot = new DomSnapshot(window, editor, {\n          before: true\n        }); // If we let 'Enter' through it breaks handling of hitting\n        // enter at the beginning of a word so we need to stop it.\n\n        break;\n\n      case 28:\n        {\n          if (event.key === 'Enter') {\n            debug$3('onKeyDown:enter');\n            event.preventDefault();\n            if (reconciler) reconciler.cancel();\n            if (deleter) deleter.cancel();\n            window.requestAnimationFrame(function () {\n              reconcile(window, editor, {\n                from: 'onKeyDown:enter'\n              });\n              editor.splitBlock();\n            });\n            return;\n          } // We need to take a snapshot of the current selection and the\n          // element before when the user hits the backspace key. This is because\n          // we only know if the user hit backspace if the `onInput` event that\n          // follows has an `inputType` of `deleteContentBackward`. At that time\n          // it's too late to stop the event.\n\n\n          keyDownSnapshot = new DomSnapshot(window, editor, {\n            before: true\n          });\n          debug$3('onKeyDown:snapshot', {\n            keyDownSnapshot: keyDownSnapshot\n          });\n        } // If we let 'Enter' through it breaks handling of hitting\n        // enter at the beginning of a word so we need to stop it.\n\n        break;\n\n      default:\n        if (status !== COMPOSING) {\n          next();\n        }\n\n    }\n  }\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onSelect(event, editor, next) {\n    debug$3('onSelect', {\n      event: event,\n      status: status\n    });\n\n    switch (ANDROID_API_VERSION) {\n      // We don't want to have the selection move around in an onSelect because\n      // it happens after we press `enter` in the same transaction. This\n      // causes the cursor position to not be properly placed.\n      case 26:\n      case 27:\n      case 28:\n        var _window2 = getWindow(event.target);\n\n        fixSelectionInZeroWidthBlock(_window2);\n        break;\n\n      default:\n        break;\n    }\n  }\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n\n  return {\n    onBeforeInput: onBeforeInput,\n    onCompositionEnd: onCompositionEnd,\n    onCompositionStart: onCompositionStart,\n    onCompositionUpdate: onCompositionUpdate,\n    onInput: onInput,\n    onKeyDown: onKeyDown,\n    onSelect: onSelect\n  };\n}\n/**\n * The transfer types that Slate recognizes.\n *\n * @type {Object}\n */\n\n\nvar TRANSFER_TYPES = {\n  FRAGMENT: 'application/x-slate-fragment',\n  HTML: 'text/html',\n  NODE: 'application/x-slate-node',\n  RICH: 'text/rtf',\n  TEXT: 'text/plain'\n};\n/**\n * Find the DOM node for a `key`.\n *\n * @param {String|Node} key\n * @param {Window} win (optional)\n * @return {Element}\n */\n\nfunction findDOMNode(key) {\n  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n  warning(false, 'As of slate-react@0.22 the `findDOMNode(key)` helper is deprecated in favor of `editor.findDOMNode(path)`.');\n\n  if (Node.isNode(key)) {\n    key = key.key;\n  }\n\n  var el = win.document.querySelector('[' + DATA_ATTRS.KEY + '=\"' + key + '\"]');\n\n  if (!el) {\n    throw new Error('Unable to find a DOM node for \"' + key + '\". This is often because of forgetting to add `props.attributes` to a custom component.');\n  }\n\n  return el;\n}\n\nvar FRAGMENT = TRANSFER_TYPES.FRAGMENT;\nvar HTML = TRANSFER_TYPES.HTML;\nvar TEXT = TRANSFER_TYPES.TEXT;\n/**\n * Prepares a Slate document fragment to be copied to the clipboard.\n *\n * @param {Event} event\n * @param {Editor} editor\n */\n\nfunction cloneFragment(event, editor) {\n  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {\n    return undefined;\n  };\n  invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `cloneFragment` utility takes an `editor` instead of a `value`.');\n  var window = getWindow(event.target);\n\n  var _native5 = window.getSelection();\n\n  var value = editor.value;\n  var document = value.document,\n      fragment = value.fragment,\n      selection = value.selection;\n  var start = selection.start,\n      end = selection.end;\n  var startVoid = document.getClosestVoid(start.path, editor);\n  var endVoid = document.getClosestVoid(end.path, editor); // If the selection is collapsed, and it isn't inside a void node, abort.\n\n  if (_native5.isCollapsed && !startVoid) return; // Create a fake selection so that we can add a Base64-encoded copy of the\n  // fragment to the HTML, to decode on future pastes.\n\n  var encoded = Base64.serializeNode(fragment);\n\n  var range = _native5.getRangeAt(0);\n\n  var contents = range.cloneContents();\n  var attach = contents.childNodes[0]; // Make sure attach is a non-empty node, since empty nodes will not get copied\n\n  contents.childNodes.forEach(function (node) {\n    if (node.textContent && node.textContent.trim() !== '') {\n      attach = node;\n    }\n  }); // COMPAT: If the end node is a void node, we need to move the end of the\n  // range from the void node's spacer span, to the end of the void node's\n  // content, since the spacer is before void's content in the DOM.\n\n  if (endVoid) {\n    var r = range.cloneRange();\n    var node = findDOMNode(endVoid, window);\n    r.setEndAfter(node);\n    contents = r.cloneContents();\n  } // COMPAT: If the start node is a void node, we need to attach the encoded\n  // fragment to the void node's content node instead of the spacer, because\n  // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n  // most browsers. (2018/04/27)\n\n\n  if (startVoid) {\n    attach = contents.childNodes[0].childNodes[1].firstChild;\n  } // Remove any zero-width space spans from the cloned DOM so that they don't\n  // show up elsewhere when pasted.\n\n\n  [].slice.call(contents.querySelectorAll(SELECTORS.ZERO_WIDTH)).forEach(function (zw) {\n    var isNewline = zw.getAttribute(DATA_ATTRS.ZERO_WIDTH) === 'n';\n    zw.textContent = isNewline ? '\\n' : '';\n  }); // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n  // in the HTML, and can be used for intra-Slate pasting. If it's a text\n  // node, wrap it in a `<span>` so we have something to set an attribute on.\n\n  if (attach.nodeType === 3) {\n    var span = window.document.createElement('span'); // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n    // then leading and trailing spaces will be ignored. (2017/09/21)\n\n    span.style.whiteSpace = 'pre';\n    span.appendChild(attach);\n    contents.appendChild(span);\n    attach = span;\n  }\n\n  attach.setAttribute(DATA_ATTRS.FRAGMENT, encoded); //  Creates value from only the selected blocks\n  //  Then gets plaintext for clipboard with proper linebreaks for BLOCK elements\n  //  Via Plain serializer\n\n  var valFromSelection = Value.create({\n    document: fragment\n  });\n  var plainText = Plain.serialize(valFromSelection); // Add the phony content to a div element. This is needed to copy the\n  // contents into the html clipboard register.\n\n  var div = window.document.createElement('div');\n  div.appendChild(contents); // For browsers supporting it, we set the clipboard registers manually,\n  // since the result is more predictable.\n  // COMPAT: IE supports the setData method, but only in restricted sense.\n  // IE doesn't support arbitrary MIME types or common ones like 'text/plain';\n  // it only accepts \"Text\" (which gets mapped to 'text/plain') and \"Url\"\n  // (mapped to 'text/url-list'); so, we should only enter block if !IS_IE\n\n  if (event.clipboardData && event.clipboardData.setData && !IS_IE) {\n    event.preventDefault();\n    event.clipboardData.setData(TEXT, plainText);\n    event.clipboardData.setData(FRAGMENT, encoded);\n    event.clipboardData.setData(HTML, div.innerHTML);\n    callback();\n    return;\n  } // COMPAT: For browser that don't support the Clipboard API's setData method,\n  // we must rely on the browser to natively copy what's selected.\n  // So we add the div (containing our content) to the DOM, and select it.\n\n\n  var editorEl = event.target.closest(SELECTORS.EDITOR);\n  div.setAttribute('contenteditable', true);\n  div.style.position = 'absolute';\n  div.style.left = '-9999px';\n  editorEl.appendChild(div);\n\n  _native5.selectAllChildren(div); // Revert to the previous selection right after copying.\n\n\n  window.requestAnimationFrame(function () {\n    editorEl.removeChild(div);\n    removeAllRanges(_native5);\n\n    _native5.addRange(range);\n\n    callback();\n  });\n}\n/**\n * Transfer types.\n *\n * @type {String}\n */\n\n\nvar FRAGMENT$1 = TRANSFER_TYPES.FRAGMENT;\nvar HTML$1 = TRANSFER_TYPES.HTML;\nvar NODE = TRANSFER_TYPES.NODE;\nvar RICH = TRANSFER_TYPES.RICH;\nvar TEXT$1 = TRANSFER_TYPES.TEXT;\n/**\n * Fragment matching regexp for HTML nodes.\n *\n * @type {RegExp}\n */\n\nvar FRAGMENT_MATCHER = / data-slate-fragment=\"([^\\s\"]+)\"/;\n/**\n * Get the transfer data from an `event`.\n *\n * @param {Event} event\n * @return {Object}\n */\n\nfunction getEventTransfer(event) {\n  // COMPAT: IE 11 doesn't populate nativeEvent with either\n  // dataTransfer or clipboardData. We'll need to use the base event\n  // object (2018/14/6)\n  if (!IS_IE && event.nativeEvent) {\n    event = event.nativeEvent;\n  }\n\n  var transfer = event.dataTransfer || event.clipboardData;\n  var fragment = getType(transfer, FRAGMENT$1);\n  var node = getType(transfer, NODE);\n  var html = getType(transfer, HTML$1);\n  var rich = getType(transfer, RICH);\n  var text = getType(transfer, TEXT$1);\n  var files = void 0; // If there isn't a fragment, but there is HTML, check to see if the HTML is\n  // actually an encoded fragment.\n\n  if (!fragment && html && ~html.indexOf(' ' + DATA_ATTRS.FRAGMENT + '=\"')) {\n    var matches = FRAGMENT_MATCHER.exec(html);\n\n    var _matches = slicedToArray(matches, 2),\n        full = _matches[0],\n        encoded = _matches[1]; // eslint-disable-line no-unused-vars\n\n\n    if (encoded) fragment = encoded;\n  } // COMPAT: Edge doesn't handle custom data types\n  // These will be embedded in text/plain in this case (2017/7/12)\n\n\n  if (text) {\n    var embeddedTypes = getEmbeddedTypes(text);\n    if (embeddedTypes[FRAGMENT$1]) fragment = embeddedTypes[FRAGMENT$1];\n    if (embeddedTypes[NODE]) node = embeddedTypes[NODE];\n    if (embeddedTypes[TEXT$1]) text = embeddedTypes[TEXT$1];\n  } // Decode a fragment or node if they exist.\n\n\n  if (fragment) fragment = Base64.deserializeNode(fragment);\n  if (node) node = Base64.deserializeNode(node); // COMPAT: Edge sometimes throws 'NotSupportedError'\n  // when accessing `transfer.items` (2017/7/12)\n\n  try {\n    // Get and normalize files if they exist.\n    if (transfer.items && transfer.items.length) {\n      files = Array.from(transfer.items).map(function (item) {\n        return item.kind === 'file' ? item.getAsFile() : null;\n      }).filter(function (exists) {\n        return exists;\n      });\n    } else if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files);\n    }\n  } catch (err) {\n    if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files);\n    }\n  } // Determine the type of the data.\n\n\n  var data = {\n    files: files,\n    fragment: fragment,\n    html: html,\n    node: node,\n    rich: rich,\n    text: text\n  };\n  data.type = getTransferType(data);\n  return data;\n}\n/**\n * Takes text input, checks whether contains embedded data\n * and returns object with original text +/- additional data\n *\n * @param {String} text\n * @return {Object}\n */\n\n\nfunction getEmbeddedTypes(text) {\n  var prefix = 'SLATE-DATA-EMBED::';\n\n  if (text.substring(0, prefix.length) !== prefix) {\n    return {\n      TEXT: text\n    };\n  } // Attempt to parse, if fails then just standard text/plain\n  // Otherwise, already had data embedded\n\n\n  try {\n    return JSON.parse(text.substring(prefix.length));\n  } catch (err) {\n    throw new Error('Unable to parse custom Slate drag event data.');\n  }\n}\n/**\n * Get the type of a transfer from its `data`.\n *\n * @param {Object} data\n * @return {String}\n */\n\n\nfunction getTransferType(data) {\n  if (data.fragment) return 'fragment';\n  if (data.node) return 'node'; // COMPAT: Microsoft Word adds an image of the selected text to the data.\n  // Since files are preferred over HTML or text, this would cause the type to\n  // be considered `files`. But it also adds rich text data so we can check\n  // for that and properly set the type to `html` or `text`. (2016/11/21)\n\n  if (data.rich && data.html) return 'html';\n  if (data.rich && data.text) return 'text';\n  if (data.files && data.files.length) return 'files';\n  if (data.html) return 'html';\n  if (data.text) return 'text';\n  return 'unknown';\n}\n/**\n * Get one of types `TYPES.FRAGMENT`, `TYPES.NODE`, `text/html`, `text/rtf` or\n * `text/plain` from transfers's `data` if possible, otherwise return null.\n *\n * @param {Object} transfer\n * @param {String} type\n * @return {String}\n */\n\n\nfunction getType(transfer, type) {\n  if (!transfer.types || !transfer.types.length) {\n    // COMPAT: In IE 11, there is no `types` field but `getData('Text')`\n    // is supported`. (2017/06/23)\n    return type === TEXT$1 ? transfer.getData('Text') || null : null;\n  } // COMPAT: In Edge, transfer.types doesn't respond to `indexOf`. (2017/10/25)\n\n\n  var types = Array.from(transfer.types);\n  return types.indexOf(type) !== -1 ? transfer.getData(type) || null : null;\n}\n/**\n * The default plain text transfer type.\n *\n * @type {String}\n */\n\n\nvar TEXT$2 = TRANSFER_TYPES.TEXT;\n/**\n * Set data with `type` and `content` on an `event`.\n *\n * COMPAT: In Edge, custom types throw errors, so embed all non-standard\n * types in text/plain compound object. (2017/7/12)\n *\n * @param {Event} event\n * @param {String} type\n * @param {String} content\n */\n\nfunction setEventTransfer(event, type, content) {\n  var mime = TRANSFER_TYPES[type.toUpperCase()];\n\n  if (!mime) {\n    throw new Error('Cannot set unknown transfer type \"' + mime + '\".');\n  }\n\n  if (event.nativeEvent) {\n    event = event.nativeEvent;\n  }\n\n  var transfer = event.dataTransfer || event.clipboardData;\n\n  try {\n    transfer.setData(mime, content); // COMPAT: Safari needs to have the 'text' (and not 'text/plain') value in dataTransfer\n    // to display the cursor while dragging internally.\n\n    transfer.setData('text', transfer.getData('text'));\n  } catch (err) {\n    var prefix = 'SLATE-DATA-EMBED::';\n    var text = transfer.getData(TEXT$2);\n    var obj = {}; // If the existing plain text data is prefixed, it's Slate JSON data.\n\n    if (text.substring(0, prefix.length) === prefix) {\n      try {\n        obj = JSON.parse(text.substring(prefix.length));\n      } catch (e) {\n        throw new Error('Failed to parse Slate data from `DataTransfer` object.');\n      }\n    } else {\n      // Otherwise, it's just set it as is.\n      obj[TEXT$2] = text;\n    }\n\n    obj[mime] = content;\n    var string = '' + prefix + JSON.stringify(obj);\n    transfer.setData(TEXT$2, string);\n  }\n}\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$4 = Debug('slate:after');\n/**\n * A plugin that adds the \"after\" browser-specific logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction AfterPlugin() {\n  var isDraggingInternally = null;\n  var isMouseDown = false;\n  /**\n   * On before input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBeforeInput(event, editor, next) {\n    var value = editor.value;\n    var isSynthetic = !!event.nativeEvent; // If the event is synthetic, it's React's polyfill of `beforeinput` that\n    // isn't a true `beforeinput` event with meaningful information. It only\n    // gets triggered for character insertions, so we can just insert directly.\n\n    if (isSynthetic) {\n      event.preventDefault();\n      editor.insertText(event.data);\n      return next();\n    } // Otherwise, we can use the information in the `beforeinput` event to\n    // figure out the exact change that will occur, and prevent it.\n\n\n    var _event$getTargetRange = event.getTargetRanges(),\n        _event$getTargetRange2 = slicedToArray(_event$getTargetRange, 1),\n        targetRange = _event$getTargetRange2[0];\n\n    if (!targetRange) return next();\n    debug$4('onBeforeInput', {\n      event: event\n    });\n    event.preventDefault();\n    var document = value.document,\n        selection = value.selection;\n    var range = editor.findRange(targetRange);\n\n    switch (event.inputType) {\n      case 'deleteByDrag':\n      case 'deleteByCut':\n      case 'deleteContent':\n      case 'deleteContentBackward':\n      case 'deleteContentForward':\n        {\n          editor.deleteAtRange(range);\n          break;\n        }\n\n      case 'deleteWordBackward':\n        {\n          editor.deleteWordBackwardAtRange(range);\n          break;\n        }\n\n      case 'deleteWordForward':\n        {\n          editor.deleteWordForwardAtRange(range);\n          break;\n        }\n\n      case 'deleteSoftLineBackward':\n      case 'deleteHardLineBackward':\n        {\n          editor.deleteLineBackwardAtRange(range);\n          break;\n        }\n\n      case 'deleteSoftLineForward':\n      case 'deleteHardLineForward':\n        {\n          editor.deleteLineForwardAtRange(range);\n          break;\n        }\n\n      case 'insertLineBreak':\n      case 'insertParagraph':\n        {\n          var hasVoidParent = document.hasVoidParent(selection.start.path, editor);\n\n          if (hasVoidParent) {\n            editor.moveToStartOfNextText();\n          } else {\n            editor.splitBlockAtRange(range);\n          }\n\n          break;\n        }\n\n      case 'insertFromYank':\n      case 'insertReplacementText':\n      case 'insertText':\n        {\n          // COMPAT: `data` should have the text for the `insertText` input type\n          // and `dataTransfer` should have the text for the\n          // `insertReplacementText` input type, but Safari uses `insertText` for\n          // spell check replacements and sets `data` to `null`. (2018/08/09)\n          var text = event.data == null ? event.dataTransfer.getData('text/plain') : event.data;\n          if (text == null) break;\n          editor.insertTextAtRange(range, text, selection.marks); // If the text was successfully inserted, and the selection had marks\n          // on it, unset the selection's marks.\n\n          if (selection.marks && value.document !== editor.value.document) {\n            editor.select({\n              marks: null\n            });\n          }\n\n          break;\n        }\n    }\n\n    next();\n  }\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onBlur(event, editor, next) {\n    debug$4('onBlur', {\n      event: event\n    });\n    editor.blur();\n    next();\n  }\n  /**\n   * On click.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onClick(event, editor, next) {\n    if (editor.readOnly) return next();\n    var value = editor.value;\n    var document = value.document;\n    var path = editor.findPath(event.target);\n    if (!path) return next();\n    debug$4('onClick', {\n      event: event\n    });\n    var node = document.getNode(path);\n    var ancestors = document.getAncestors(path);\n    var isVoid = node && (editor.isVoid(node) || ancestors.some(function (a) {\n      return editor.isVoid(a);\n    }));\n\n    if (isVoid) {\n      // COMPAT: In Chrome & Safari, selections that are at the zero offset of\n      // an inline node will be automatically replaced to be at the last offset\n      // of a previous inline node, which screws us up, so we always want to set\n      // it to the end of the node. (2016/11/29)\n      editor.focus().moveToEndOfNode(node);\n    }\n\n    next();\n  }\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onCopy(event, editor, next) {\n    debug$4('onCopy', {\n      event: event\n    });\n    cloneFragment(event, editor);\n    next();\n  }\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onCut(event, editor, next) {\n    debug$4('onCut', {\n      event: event\n    }); // Once the fake cut content has successfully been added to the clipboard,\n    // delete the content in the current selection.\n\n    cloneFragment(event, editor, function () {\n      // If user cuts a void block node or a void inline node,\n      // manually removes it since selection is collapsed in this case.\n      var value = editor.value;\n      var document = value.document,\n          selection = value.selection;\n      var end = selection.end,\n          isCollapsed = selection.isCollapsed;\n      var voidPath = void 0;\n\n      if (isCollapsed) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = document.ancestors(end.path)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref = _step.value;\n\n            var _ref2 = slicedToArray(_ref, 2);\n\n            var node = _ref2[0];\n            var path = _ref2[1];\n\n            if (editor.isVoid(node)) {\n              voidPath = path;\n              break;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      if (voidPath) {\n        editor.removeNodeByKey(voidPath);\n      } else {\n        editor.delete();\n      }\n    });\n    next();\n  }\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragEnd(event, editor, next) {\n    debug$4('onDragEnd', {\n      event: event\n    });\n    isDraggingInternally = null;\n    next();\n  }\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragStart(event, editor, next) {\n    debug$4('onDragStart', {\n      event: event\n    });\n    isDraggingInternally = true;\n    var value = editor.value;\n    var document = value.document;\n    var path = editor.findPath(event.target);\n    var node = document.getNode(path);\n    var ancestors = document.getAncestors(path);\n    var isVoid = node && (editor.isVoid(node) || ancestors.some(function (a) {\n      return editor.isVoid(a);\n    }));\n    var selectionIncludesNode = value.blocks.some(function (block) {\n      return block === node;\n    }); // If a void block is dragged and is not selected, select it (necessary for local drags).\n\n    if (isVoid && !selectionIncludesNode) {\n      editor.moveToRangeOfNode(node);\n    }\n\n    var fragment = editor.value.fragment;\n    var encoded = Base64.serializeNode(fragment);\n    setEventTransfer(event, 'fragment', encoded);\n    next();\n  }\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDrop(event, editor, next) {\n    var value = editor.value;\n    var document = value.document,\n        selection = value.selection;\n    var window = getWindow(event.target);\n    var target = editor.findEventRange(event);\n\n    if (!target) {\n      return next();\n    }\n\n    debug$4('onDrop', {\n      event: event\n    });\n    var transfer = getEventTransfer(event);\n    var type = transfer.type,\n        fragment = transfer.fragment,\n        text = transfer.text;\n    editor.focus(); // If the drag is internal and the target is after the selection, it\n    // needs to account for the selection's content being deleted.\n\n    if (isDraggingInternally && selection.end.offset < target.end.offset && selection.end.path.equals(target.end.path)) {\n      target = target.moveForward(selection.start.path.equals(selection.end.path) ? 0 - selection.end.offset + selection.start.offset : 0 - selection.end.offset);\n    }\n\n    if (isDraggingInternally) {\n      editor.delete();\n    }\n\n    editor.select(target);\n\n    if (type === 'text' || type === 'html') {\n      var _target = target,\n          anchor = _target.anchor;\n      var hasVoidParent = document.hasVoidParent(anchor.path, editor);\n\n      if (hasVoidParent) {\n        var p = anchor.path;\n        var n = document.getNode(anchor.path);\n\n        while (hasVoidParent) {\n          var _document$texts = document.texts({\n            path: p\n          }),\n              _document$texts2 = slicedToArray(_document$texts, 1),\n              nxt = _document$texts2[0];\n\n          if (!nxt) {\n            break;\n          }\n\n          var _nxt = slicedToArray(nxt, 2);\n\n          n = _nxt[0];\n          p = _nxt[1];\n          hasVoidParent = document.hasVoidParent(p, editor);\n        }\n\n        if (n) editor.moveToStartOfNode(n);\n      }\n\n      if (text) {\n        text.split('\\n').forEach(function (line, i) {\n          if (i > 0) editor.splitBlock();\n          editor.insertText(line);\n        });\n      }\n    }\n\n    if (type === 'fragment') {\n      editor.insertFragment(fragment);\n    } // COMPAT: React's onSelect event breaks after an onDrop event\n    // has fired in a node: https://github.com/facebook/react/issues/11379.\n    // Until this is fixed in React, we dispatch a mouseup event on that\n    // DOM node, since that will make it go back to normal.\n\n\n    var el = editor.findDOMNode(target.focus.path);\n\n    if (el) {\n      el.dispatchEvent(new MouseEvent('mouseup', {\n        view: window,\n        bubbles: true,\n        cancelable: true\n      }));\n    }\n\n    next();\n  }\n  /**\n   * On focus.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onFocus(event, editor, next) {\n    debug$4('onFocus', {\n      event: event\n    }); // COMPAT: If the focus event is a mouse-based one, it will be shortly\n    // followed by a `selectionchange`, so we need to deselect here to prevent\n    // the old selection from being set by the `updateSelection` of `<Content>`,\n    // preventing the `selectionchange` from firing. (2018/11/07)\n\n    if (isMouseDown && !IS_IE && !IS_EDGE) {\n      editor.deselect().focus();\n    } else {\n      editor.focus();\n    }\n\n    next();\n  }\n  /**\n   * On input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onInput(event, editor, next) {\n    debug$4('onInput');\n    var window = getWindow(event.target);\n    var domSelection = window.getSelection();\n    var selection = editor.findSelection(domSelection);\n\n    if (selection) {\n      editor.select(selection);\n    } else {\n      editor.blur();\n    }\n\n    var anchorNode = domSelection.anchorNode;\n    setTextFromDomNode(window, editor, anchorNode);\n    next();\n  }\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onKeyDown(event, editor, next) {\n    debug$4('onKeyDown', {\n      event: event\n    });\n    var value = editor.value;\n    var document = value.document,\n        selection = value.selection;\n    var start = selection.start;\n    var hasVoidParent = document.hasVoidParent(start.path, editor); // COMPAT: In iOS, some of these hotkeys are handled in the\n    // `onNativeBeforeInput` handler of the `<Content>` component in order to\n    // preserve native autocorrect behavior, so they shouldn't be handled here.\n\n    if (Hotkeys.isSplitBlock(event) && !IS_IOS) {\n      return hasVoidParent ? editor.moveToStartOfNextText() : editor.splitBlock();\n    }\n\n    if (Hotkeys.isDeleteBackward(event) && !IS_IOS) {\n      return editor.deleteCharBackward();\n    }\n\n    if (Hotkeys.isDeleteForward(event) && !IS_IOS) {\n      return editor.deleteCharForward();\n    }\n\n    if (Hotkeys.isDeleteLineBackward(event)) {\n      return editor.deleteLineBackward();\n    }\n\n    if (Hotkeys.isDeleteLineForward(event)) {\n      return editor.deleteLineForward();\n    }\n\n    if (Hotkeys.isDeleteWordBackward(event)) {\n      return editor.deleteWordBackward();\n    }\n\n    if (Hotkeys.isDeleteWordForward(event)) {\n      return editor.deleteWordForward();\n    }\n\n    if (Hotkeys.isRedo(event)) {\n      return editor.redo();\n    }\n\n    if (Hotkeys.isUndo(event)) {\n      return editor.undo();\n    } // COMPAT: Certain browsers don't handle the selection updates properly. In\n    // Chrome, the selection isn't properly extended. And in Firefox, the\n    // selection isn't properly collapsed. (2017/10/17)\n\n\n    if (Hotkeys.isMoveLineBackward(event)) {\n      event.preventDefault();\n      return editor.moveToStartOfBlock();\n    }\n\n    if (Hotkeys.isMoveLineForward(event)) {\n      event.preventDefault();\n      return editor.moveToEndOfBlock();\n    }\n\n    if (Hotkeys.isExtendLineBackward(event)) {\n      event.preventDefault();\n      return editor.moveFocusToStartOfBlock();\n    }\n\n    if (Hotkeys.isExtendLineForward(event)) {\n      event.preventDefault();\n      return editor.moveFocusToEndOfBlock();\n    } // COMPAT: If a void node is selected, or a zero-width text node adjacent to\n    // an inline is selected, we need to handle these hotkeys manually because\n    // browsers won't know what to do.\n\n\n    if (Hotkeys.isMoveBackward(event)) {\n      event.preventDefault();\n\n      if (!selection.isCollapsed) {\n        return editor.moveToStart();\n      }\n\n      return editor.moveBackward();\n    }\n\n    if (Hotkeys.isMoveForward(event)) {\n      event.preventDefault();\n\n      if (!selection.isCollapsed) {\n        return editor.moveToEnd();\n      }\n\n      return editor.moveForward();\n    }\n\n    if (Hotkeys.isMoveWordBackward(event)) {\n      event.preventDefault();\n      return editor.moveWordBackward();\n    }\n\n    if (Hotkeys.isMoveWordForward(event)) {\n      event.preventDefault();\n      return editor.moveWordForward();\n    }\n\n    if (Hotkeys.isExtendBackward(event)) {\n      var startText = document.getNode(start.path);\n\n      var _document$texts3 = document.texts({\n        path: start.path,\n        direction: 'backward'\n      }),\n          _document$texts4 = slicedToArray(_document$texts3, 1),\n          prevEntry = _document$texts4[0];\n\n      var isPrevInVoid = false;\n\n      if (prevEntry) {\n        var _prevEntry = slicedToArray(prevEntry, 2),\n            prevPath = _prevEntry[1];\n\n        isPrevInVoid = document.hasVoidParent(prevPath, editor);\n      }\n\n      if (hasVoidParent || isPrevInVoid || startText.text === '') {\n        event.preventDefault();\n        return editor.moveFocusBackward();\n      }\n    }\n\n    if (Hotkeys.isExtendForward(event)) {\n      var _startText = document.getNode(start.path);\n\n      var _document$texts5 = document.texts({\n        path: start.path\n      }),\n          _document$texts6 = slicedToArray(_document$texts5, 1),\n          nextEntry = _document$texts6[0];\n\n      var isNextInVoid = false;\n\n      if (nextEntry) {\n        var _nextEntry = slicedToArray(nextEntry, 2),\n            nextPath = _nextEntry[1];\n\n        isNextInVoid = document.hasVoidParent(nextPath, editor);\n      }\n\n      if (hasVoidParent || isNextInVoid || _startText.text === '') {\n        event.preventDefault();\n        return editor.moveFocusForward();\n      }\n    }\n\n    next();\n  }\n  /**\n   * On mouse down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onMouseDown(event, editor, next) {\n    debug$4('onMouseDown', {\n      event: event\n    });\n    isMouseDown = true;\n    next();\n  }\n  /**\n   * On mouse up.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onMouseUp(event, editor, next) {\n    debug$4('onMouseUp', {\n      event: event\n    });\n    isMouseDown = false;\n    next();\n  }\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onPaste(event, editor, next) {\n    debug$4('onPaste', {\n      event: event\n    });\n    var value = editor.value;\n    var transfer = getEventTransfer(event);\n    var type = transfer.type,\n        fragment = transfer.fragment,\n        text = transfer.text;\n\n    if (type === 'fragment') {\n      editor.insertFragment(fragment);\n    }\n\n    if (type === 'text' || type === 'html') {\n      if (!text) return next();\n      var document = value.document,\n          selection = value.selection,\n          startBlock = value.startBlock;\n      if (editor.isVoid(startBlock)) return next();\n      var defaultBlock = startBlock;\n      var defaultMarks = document.getInsertMarksAtRange(selection);\n      var frag = Plain.deserialize(text, {\n        defaultBlock: defaultBlock,\n        defaultMarks: defaultMarks\n      }).document;\n      editor.insertFragment(frag);\n    }\n\n    next();\n  }\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onSelect(event, editor, next) {\n    debug$4('onSelect', {\n      event: event\n    });\n    var window = getWindow(event.target);\n    var domSelection = window.getSelection();\n    var selection = editor.findSelection(domSelection);\n\n    if (selection) {\n      editor.select(selection);\n    } else {\n      editor.blur();\n    } // COMPAT: reset the `isMouseDown` state here in case a `mouseup` event\n    // happens outside the editor. This is needed for `onFocus` handling.\n\n\n    isMouseDown = false;\n    next();\n  }\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n\n  return {\n    onBeforeInput: onBeforeInput,\n    onBlur: onBlur,\n    onClick: onClick,\n    onCopy: onCopy,\n    onCut: onCut,\n    onDragEnd: onDragEnd,\n    onDragStart: onDragStart,\n    onDrop: onDrop,\n    onFocus: onFocus,\n    onInput: onInput,\n    onKeyDown: onKeyDown,\n    onMouseDown: onMouseDown,\n    onMouseUp: onMouseUp,\n    onPaste: onPaste,\n    onSelect: onSelect\n  };\n}\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$5 = Debug('slate:before');\n/**\n * A plugin that adds the \"before\" browser-specific logic to the editor.\n *\n * @return {Object}\n */\n\nfunction BeforePlugin() {\n  var activeElement = null;\n  var compositionCount = 0;\n  var isComposing = false;\n  var isCopying = false;\n  var isDragging = false;\n  /**\n   * On before input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBeforeInput(event, editor, next) {\n    var isSynthetic = !!event.nativeEvent;\n    if (editor.readOnly) return; // COMPAT: If the browser supports Input Events Level 2, we will have\n    // attached a custom handler for the real `beforeinput` events, instead of\n    // allowing React's synthetic polyfill, so we need to ignore synthetics.\n\n    if (isSynthetic && HAS_INPUT_EVENTS_LEVEL_2) return;\n    debug$5('onBeforeInput', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onBlur(event, editor, next) {\n    if (isCopying) return;\n    if (editor.readOnly) return;\n    var relatedTarget = event.relatedTarget,\n        target = event.target;\n    var window = getWindow(target); // COMPAT: If the current `activeElement` is still the previous one, this is\n    // due to the window being blurred when the tab itself becomes unfocused, so\n    // we want to abort early to allow to editor to stay focused when the tab\n    // becomes focused again.\n\n    if (activeElement === window.document.activeElement) return; // COMPAT: The `relatedTarget` can be null when the new focus target is not\n    // a \"focusable\" element (eg. a `<div>` without `tabindex` set).\n\n    if (relatedTarget) {\n      var el = editor.findDOMNode([]); // COMPAT: The event should be ignored if the focus is returning to the\n      // editor from an embedded editable element (eg. an <input> element inside\n      // a void node).\n\n      if (relatedTarget === el) return; // COMPAT: The event should be ignored if the focus is moving from the\n      // editor to inside a void node's spacer element.\n\n      if (relatedTarget.hasAttribute(DATA_ATTRS.SPACER)) return; // COMPAT: The event should be ignored if the focus is moving to a non-\n      // editable section of an element that isn't a void node (eg. a list item\n      // of the check list example).\n\n      var node = editor.findNode(relatedTarget);\n\n      if (el.contains(relatedTarget) && node && !editor.isVoid(node)) {\n        return;\n      }\n    }\n\n    debug$5('onBlur', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On composition end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onCompositionEnd(event, editor, next) {\n    var n = compositionCount; // The `count` check here ensures that if another composition starts\n    // before the timeout has closed out this one, we will abort unsetting the\n    // `isComposing` flag, since a composition is still in affect.\n\n    window.requestAnimationFrame(function () {\n      if (compositionCount > n) return;\n      isComposing = false;\n    });\n    debug$5('onCompositionEnd', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On click.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onClick(event, editor, next) {\n    debug$5('onClick', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On composition start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onCompositionStart(event, editor, next) {\n    isComposing = true;\n    compositionCount++;\n    var value = editor.value;\n    var selection = value.selection;\n\n    if (!selection.isCollapsed) {\n      // https://github.com/ianstormtaylor/slate/issues/1879\n      // When composition starts and the current selection is not collapsed, the\n      // second composition key-down would drop the text wrapping <spans> which\n      // resulted on crash in content.updateSelection after composition ends\n      // (because it cannot find <span> nodes in DOM). This is a workaround that\n      // erases selection as soon as composition starts and preventing <spans>\n      // to be dropped.\n      editor.delete();\n    }\n\n    debug$5('onCompositionStart', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onCopy(event, editor, next) {\n    var window = getWindow(event.target);\n    isCopying = true;\n    window.requestAnimationFrame(function () {\n      return isCopying = false;\n    });\n    debug$5('onCopy', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onCut(event, editor, next) {\n    if (editor.readOnly) return;\n    var window = getWindow(event.target);\n    isCopying = true;\n    window.requestAnimationFrame(function () {\n      return isCopying = false;\n    });\n    debug$5('onCut', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragEnd(event, editor, next) {\n    isDragging = false;\n    debug$5('onDragEnd', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On drag enter.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragEnter(event, editor, next) {\n    debug$5('onDragEnter', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On drag exit.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragExit(event, editor, next) {\n    debug$5('onDragExit', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On drag leave.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragLeave(event, editor, next) {\n    debug$5('onDragLeave', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On drag over.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragOver(event, editor, next) {\n    // If the target is inside a void node, and only in this case,\n    // call `preventDefault` to signal that drops are allowed.\n    // When the target is editable, dropping is already allowed by\n    // default, and calling `preventDefault` hides the cursor.\n    var node = editor.findNode(event.target);\n\n    if (editor.isVoid(node)) {\n      event.preventDefault();\n    } // COMPAT: IE won't call onDrop on contentEditables unless the\n    // default dragOver is prevented:\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/913982/\n    // (2018/07/11)\n\n\n    if (IS_IE) {\n      event.preventDefault();\n    } // If a drag is already in progress, don't do this again.\n\n\n    if (!isDragging) {\n      isDragging = true; // COMPAT: IE will raise an `unspecified error` if dropEffect is\n      // set. (2018/07/11)\n\n      if (!IS_IE) {\n        event.nativeEvent.dataTransfer.dropEffect = 'move';\n      }\n    }\n\n    debug$5('onDragOver', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragStart(event, editor, next) {\n    isDragging = true;\n    debug$5('onDragStart', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDrop(event, editor, next) {\n    if (editor.readOnly) return; // Prevent default so the DOM's value isn't corrupted.\n\n    event.preventDefault();\n    debug$5('onDrop', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On focus.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onFocus(event, editor, next) {\n    if (isCopying) return;\n    if (editor.readOnly) return;\n    var el = editor.findDOMNode([]); // Save the new `activeElement`.\n\n    var window = getWindow(event.target);\n    activeElement = window.document.activeElement; // COMPAT: If the editor has nested editable elements, the focus can go to\n    // those elements. In Firefox, this must be prevented because it results in\n    // issues with keyboard navigation. (2017/03/30)\n\n    if (IS_FIREFOX && event.target !== el) {\n      el.focus();\n      return;\n    }\n\n    debug$5('onFocus', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onInput(event, editor, next) {\n    if (isComposing) return;\n    if (editor.value.selection.isBlurred) return;\n    debug$5('onInput', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onKeyDown(event, editor, next) {\n    if (editor.readOnly) return; // When composing, we need to prevent all hotkeys from executing while\n    // typing. However, certain characters also move the selection before\n    // we're able to handle it, so prevent their default behavior.\n\n    if (isComposing) {\n      if (Hotkeys.isCompose(event)) event.preventDefault();\n      return;\n    } // Certain hotkeys have native editing behaviors in `contenteditable`\n    // elements which will editor the DOM and cause our value to be out of sync,\n    // so they need to always be prevented.\n\n\n    if (!IS_IOS && (Hotkeys.isBold(event) || Hotkeys.isDeleteBackward(event) || Hotkeys.isDeleteForward(event) || Hotkeys.isDeleteLineBackward(event) || Hotkeys.isDeleteLineForward(event) || Hotkeys.isDeleteWordBackward(event) || Hotkeys.isDeleteWordForward(event) || Hotkeys.isItalic(event) || Hotkeys.isRedo(event) || Hotkeys.isSplitBlock(event) || Hotkeys.isTransposeCharacter(event) || Hotkeys.isUndo(event))) {\n      event.preventDefault();\n    }\n\n    debug$5('onKeyDown', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onPaste(event, editor, next) {\n    if (editor.readOnly) return; // Prevent defaults so the DOM state isn't corrupted.\n\n    event.preventDefault();\n    debug$5('onPaste', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onSelect(event, editor, next) {\n    if (isCopying) return;\n    if (isComposing) return;\n    if (editor.readOnly) return; // Save the new `activeElement`.\n\n    var window = getWindow(event.target);\n    activeElement = window.document.activeElement;\n    debug$5('onSelect', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n\n  return {\n    onBeforeInput: onBeforeInput,\n    onBlur: onBlur,\n    onClick: onClick,\n    onCompositionEnd: onCompositionEnd,\n    onCompositionStart: onCompositionStart,\n    onCopy: onCopy,\n    onCut: onCut,\n    onDragEnd: onDragEnd,\n    onDragEnter: onDragEnter,\n    onDragExit: onDragExit,\n    onDragLeave: onDragLeave,\n    onDragOver: onDragOver,\n    onDragStart: onDragStart,\n    onDrop: onDrop,\n    onFocus: onFocus,\n    onInput: onInput,\n    onKeyDown: onKeyDown,\n    onPaste: onPaste,\n    onSelect: onSelect\n  };\n}\n/**\n * A plugin that adds the browser-specific logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\n\nfunction DOMPlugin() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _options$plugins = options.plugins,\n      plugins = _options$plugins === undefined ? [] : _options$plugins;\n  var beforePlugin = BeforePlugin();\n  var afterPlugin = AfterPlugin(); // COMPAT: Add Android specific handling separately before it gets to the\n  // other plugins because it is specific (other browser don't need it) and\n  // finicky (it has to come before other plugins to work).\n\n  var beforeBeforePlugins = IS_ANDROID ? [AndroidPlugin()] : [];\n  return [].concat(beforeBeforePlugins, [beforePlugin], toConsumableArray(plugins), [afterPlugin]);\n}\n\nfunction RestoreDOMPlugin() {\n  /**\n   * Makes sure that on the next Content `render` the DOM is restored.\n   * This gets us around issues where the DOM is in a different state than\n   * React's virtual DOM and would crash.\n   *\n   * @param {Editor} editor\n   */\n  function restoreDOM(editor) {\n    editor.setState({\n      contentKey: editor.state.contentKey + 1\n    });\n  }\n\n  return {\n    commands: {\n      restoreDOM: restoreDOM\n    }\n  };\n}\n/**\n * A plugin that adds the React-specific rendering logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\n\nfunction ReactPlugin() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _options$placeholder = options.placeholder,\n      placeholder = _options$placeholder === undefined ? '' : _options$placeholder,\n      _options$plugins = options.plugins,\n      plugins = _options$plugins === undefined ? [] : _options$plugins;\n  var renderingPlugin = Rendering(options);\n  var queriesPlugin = QueriesPlugin(options);\n  var editorPropsPlugin = EditorPropsPlugin(options);\n  var domPlugin = DOMPlugin({\n    plugins: [editorPropsPlugin].concat(toConsumableArray(plugins))\n  });\n  var restoreDomPlugin = RestoreDOMPlugin();\n  var placeholderPlugin = PlaceholderPlugin({\n    placeholder: placeholder,\n    when: function when(editor, node) {\n      return node.object === 'document' && node.text === '' && node.nodes.size === 1 && Array.from(node.texts()).length === 1;\n    }\n  });\n  return [domPlugin, restoreDomPlugin, placeholderPlugin, renderingPlugin, queriesPlugin];\n}\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$6 = Debug('slate:editor');\n/**\n * Editor.\n *\n * @type {Component}\n */\n\nvar Editor$1 = function (_React$Component) {\n  inherits(Editor$$1, _React$Component);\n\n  function Editor$$1() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Editor$$1);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Editor$$1.__proto__ || Object.getPrototypeOf(Editor$$1)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      value: _this.props.defaultValue,\n      contentKey: 0\n      /**\n       * Temporary values.\n       *\n       * @type {Object}\n       */\n\n    }, _this.tmp = {\n      mounted: false,\n      change: null,\n      resolves: 0,\n      updates: 0,\n      contentRef: React.createRef()\n      /**\n       * When the component first mounts, flush a queued change if one exists.\n       */\n\n    }, _this.resolveController = memoizeOne(function () {\n      warning(_this.tmp.resolves < 5 || _this.tmp.resolves !== _this.tmp.updates, 'A Slate <Editor> component is re-resolving the `plugins`, `schema`, `commands`, `queries` or `placeholder` prop on each update, which leads to poor performance. This is often due to passing in a new references for these props with each render by declaring them inline in your render function. Do not do this! Declare them outside your render function, or memoize them instead.');\n      _this.tmp.resolves++;\n      var react = ReactPlugin(_extends({}, _this.props, {\n        value: _this.props.value || _this.state.value\n      }));\n\n      var onChange = function onChange(change) {\n        if (_this.tmp.mounted) {\n          _this.handleChange(change);\n        } else {\n          _this.tmp.change = change;\n        }\n      };\n\n      _this.controller = new Editor({\n        plugins: [react],\n        onChange: onChange\n      }, {\n        controller: _this,\n        construct: false\n      });\n\n      _this.controller.run('onConstruct');\n    }), _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Initial state.\n   *\n   * @type {Object}\n   */\n\n\n  createClass(Editor$$1, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.tmp.mounted = true;\n      this.tmp.updates++;\n\n      if (this.props.autoFocus) {\n        this.focus();\n      }\n\n      if (this.tmp.change) {\n        this.handleChange(this.tmp.change);\n        this.tmp.change = null;\n      }\n    }\n    /**\n     * When the component updates, flush a queued change if one exists.\n     */\n\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      this.tmp.updates++;\n\n      if (this.tmp.change) {\n        this.handleChange(this.tmp.change);\n        this.tmp.change = null;\n      }\n    }\n    /**\n     * When the component unmounts, make sure async commands don't trigger react updates.\n     */\n\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      this.tmp.mounted = false;\n    }\n    /**\n     * Render the editor.\n     *\n     * @return {Element}\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      debug$6('render', this); // Re-resolve the controller if needed based on memoized props.\n\n      var _props = this.props,\n          commands = _props.commands,\n          placeholder = _props.placeholder,\n          plugins = _props.plugins,\n          queries = _props.queries,\n          schema = _props.schema;\n      this.resolveController(plugins, schema, commands, queries, placeholder); // Set the current props on the controller.\n\n      var _props2 = this.props,\n          options = _props2.options,\n          readOnly = _props2.readOnly,\n          valueFromProps = _props2.value;\n      var valueFromState = this.state.value;\n      var value = valueFromProps || valueFromState;\n      var contentKey = this.state.contentKey;\n      this.controller.setReadOnly(readOnly);\n      this.controller.setValue(value, options);\n      var _props3 = this.props,\n          autoCorrect = _props3.autoCorrect,\n          className = _props3.className,\n          id = _props3.id,\n          role = _props3.role,\n          spellCheck = _props3.spellCheck,\n          tabIndex = _props3.tabIndex,\n          style = _props3.style,\n          tagName = _props3.tagName;\n      var children = React.createElement(Content, {\n        ref: this.tmp.contentRef,\n        autoCorrect: autoCorrect,\n        className: className,\n        contentKey: contentKey,\n        editor: this,\n        id: id,\n        onEvent: function onEvent(handler, event) {\n          return _this2.run(handler, event);\n        },\n        readOnly: readOnly,\n        role: role,\n        spellCheck: spellCheck,\n        style: style,\n        tabIndex: tabIndex,\n        tagName: tagName\n      }); // Render the editor's children with the controller.\n\n      var element = this.controller.run('renderEditor', _extends({}, this.props, {\n        editor: this,\n        children: children\n      }));\n      return element;\n    }\n    /**\n     * Resolve an editor controller from the passed-in props. This method takes\n     * all of the props as individual arguments to be able to properly memoize\n     * against anything that could change and invalidate the old editor.\n     *\n     * @param {Array} plugins\n     * @param {Object} schema\n     * @param {Object} commands\n     * @param {Object} queries\n     * @param {String} placeholder\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'handleChange',\n    value: function handleChange(change) {\n      var onChange = this.props.onChange;\n      var value = this.state.value;\n\n      if (value) {\n        // Syncing value inside this component since parent does not want control of it (defaultValue was used)\n        this.setState({\n          value: change.value\n        });\n      }\n\n      onChange(change);\n    }\n    /**\n     * Mimic the API of the `Editor` controller, so that this component instance\n     * can be passed in its place to plugins.\n     */\n\n  }, {\n    key: 'applyOperation',\n    value: function applyOperation() {\n      var _controller;\n\n      return (_controller = this.controller).applyOperation.apply(_controller, arguments);\n    }\n  }, {\n    key: 'command',\n    value: function command() {\n      var _controller2;\n\n      return (_controller2 = this.controller).command.apply(_controller2, arguments);\n    }\n  }, {\n    key: 'hasCommand',\n    value: function hasCommand() {\n      var _controller3;\n\n      return (_controller3 = this.controller).hasCommand.apply(_controller3, arguments);\n    }\n  }, {\n    key: 'hasQuery',\n    value: function hasQuery() {\n      var _controller4;\n\n      return (_controller4 = this.controller).hasQuery.apply(_controller4, arguments);\n    }\n  }, {\n    key: 'normalize',\n    value: function normalize() {\n      var _controller5;\n\n      return (_controller5 = this.controller).normalize.apply(_controller5, arguments);\n    }\n  }, {\n    key: 'query',\n    value: function query() {\n      var _controller6;\n\n      return (_controller6 = this.controller).query.apply(_controller6, arguments);\n    }\n  }, {\n    key: 'registerCommand',\n    value: function registerCommand() {\n      var _controller7;\n\n      return (_controller7 = this.controller).registerCommand.apply(_controller7, arguments);\n    }\n  }, {\n    key: 'registerQuery',\n    value: function registerQuery() {\n      var _controller8;\n\n      return (_controller8 = this.controller).registerQuery.apply(_controller8, arguments);\n    }\n  }, {\n    key: 'run',\n    value: function run() {\n      var _controller9;\n\n      return (_controller9 = this.controller).run.apply(_controller9, arguments);\n    }\n  }, {\n    key: 'withoutNormalizing',\n    value: function withoutNormalizing() {\n      var _controller10;\n\n      return (_controller10 = this.controller).withoutNormalizing.apply(_controller10, arguments);\n    }\n    /**\n     * Deprecated.\n     */\n\n  }, {\n    key: 'call',\n    value: function call() {\n      var _controller11;\n\n      return (_controller11 = this.controller).call.apply(_controller11, arguments);\n    }\n  }, {\n    key: 'change',\n    value: function change() {\n      var _controller12;\n\n      return (_controller12 = this.controller).change.apply(_controller12, arguments);\n    }\n  }, {\n    key: 'onChange',\n    value: function onChange() {\n      var _controller13;\n\n      return (_controller13 = this.controller).onChange.apply(_controller13, arguments);\n    }\n  }, {\n    key: 'applyOperations',\n    value: function applyOperations() {\n      var _controller14;\n\n      return (_controller14 = this.controller).applyOperations.apply(_controller14, arguments);\n    }\n  }, {\n    key: 'setOperationFlag',\n    value: function setOperationFlag() {\n      var _controller15;\n\n      return (_controller15 = this.controller).setOperationFlag.apply(_controller15, arguments);\n    }\n  }, {\n    key: 'getFlag',\n    value: function getFlag() {\n      var _controller16;\n\n      return (_controller16 = this.controller).getFlag.apply(_controller16, arguments);\n    }\n  }, {\n    key: 'unsetOperationFlag',\n    value: function unsetOperationFlag() {\n      var _controller17;\n\n      return (_controller17 = this.controller).unsetOperationFlag.apply(_controller17, arguments);\n    }\n  }, {\n    key: 'withoutNormalization',\n    value: function withoutNormalization() {\n      var _controller18;\n\n      return (_controller18 = this.controller).withoutNormalization.apply(_controller18, arguments);\n    }\n  }, {\n    key: 'operations',\n    get: function get$$1() {\n      return this.controller.operations;\n    }\n  }, {\n    key: 'readOnly',\n    get: function get$$1() {\n      return this.controller.readOnly;\n    }\n  }, {\n    key: 'value',\n    get: function get$$1() {\n      return this.controller.value;\n    }\n  }, {\n    key: 'editor',\n    get: function get$$1() {\n      return this.controller.editor;\n    }\n  }, {\n    key: 'schema',\n    get: function get$$1() {\n      invariant(false, 'As of Slate 0.42, the `editor.schema` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.');\n    }\n  }, {\n    key: 'stack',\n    get: function get$$1() {\n      invariant(false, 'As of Slate 0.42, the `editor.stack` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.');\n    }\n  }]);\n  return Editor$$1;\n}(React.Component);\n/**\n * Export.\n *\n * @type {Component}\n */\n\n\nEditor$1.propTypes = _extends({\n  autoCorrect: Types.bool,\n  autoFocus: Types.bool,\n  className: Types.string,\n  defaultValue: SlateTypes.value,\n  id: Types.string,\n  onChange: Types.func,\n  options: Types.object,\n  placeholder: Types.any,\n  plugins: Types.array,\n  readOnly: Types.bool,\n  role: Types.string,\n  schema: Types.object,\n  spellCheck: Types.bool,\n  style: Types.object,\n  tabIndex: Types.number,\n  value: SlateTypes.value\n}, EVENT_HANDLERS.reduce(function (obj, handler) {\n  obj[handler] = Types.func;\n  return obj;\n}, {}));\nEditor$1.defaultProps = {\n  autoFocus: false,\n  autoCorrect: true,\n  onChange: function onChange() {},\n  options: {},\n  placeholder: '',\n  plugins: [],\n  readOnly: false,\n  schema: {},\n  spellCheck: true\n};\n/**\n * Find a native DOM selection point from a Slate `point`.\n *\n * @param {Point} point\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\nfunction findDOMPoint(point) {\n  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n  warning(false, 'As of slate-react@0.22 the `findDOMPoint(point)` helper is deprecated in favor of `editor.findDOMPoint(point)`.');\n  var el = findDOMNode(point.key, win);\n  var start = 0; // For each leaf, we need to isolate its content, which means filtering to its\n  // direct text and zero-width spans. (We have to filter out any other siblings\n  // that may have been rendered alongside them.)\n\n  var texts = Array.from(el.querySelectorAll(SELECTORS.STRING + ', ' + SELECTORS.ZERO_WIDTH));\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = texts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var text = _step.value;\n      var node = text.childNodes[0];\n      var domLength = node.textContent.length;\n      var slateLength = domLength;\n\n      if (text.hasAttribute(DATA_ATTRS.LENGTH)) {\n        slateLength = parseInt(text.getAttribute(DATA_ATTRS.LENGTH), 10);\n      }\n\n      var end = start + slateLength;\n\n      if (point.offset <= end) {\n        var offset = Math.min(domLength, Math.max(0, point.offset - start));\n        return {\n          node: node,\n          offset: offset\n        };\n      }\n\n      start = end;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return null;\n}\n/**\n * Find a native DOM range Slate `range`.\n *\n * @param {Range} range\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\n\nfunction findDOMRange(range) {\n  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n  warning(false, 'As of slate-react@0.22 the `findDOMRange(range)` helper is deprecated in favor of `editor.findDOMRange(range)`.');\n  var anchor = range.anchor,\n      focus = range.focus,\n      isBackward$$1 = range.isBackward,\n      isCollapsed = range.isCollapsed;\n  var domAnchor = findDOMPoint(anchor, win);\n  var domFocus = isCollapsed ? domAnchor : findDOMPoint(focus, win);\n  if (!domAnchor || !domFocus) return null;\n  var r = win.document.createRange();\n  var start = isBackward$$1 ? domFocus : domAnchor;\n  var end = isBackward$$1 ? domAnchor : domFocus;\n  r.setStart(start.node, start.offset);\n  r.setEnd(end.node, end.offset);\n  return r;\n}\n/**\n * Find a Slate node from a DOM `element`.\n *\n * @param {Element} element\n * @param {Editor} editor\n * @return {Node|Null}\n */\n\n\nfunction findNode(element, editor) {\n  warning(false, 'As of slate-react@0.22 the `findNode(element)` helper is deprecated in favor of `editor.findNode(element)`.');\n  invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.');\n  var closest = element.closest(SELECTORS.KEY);\n  if (!closest) return null;\n  var key = closest.getAttribute(DATA_ATTRS.KEY);\n  if (!key) return null;\n  var value = editor.value;\n  var document = value.document;\n  var node = document.getNode(key);\n  return node || null;\n}\n/**\n * Find a Slate path from a DOM `element`.\n *\n * @param {Element} element\n * @param {Editor} editor\n * @return {List|Null}\n */\n\n\nfunction findPath$1(element, editor) {\n  warning(false, 'As of slate-react@0.22 the `findPath(element)` helper is deprecated in favor of `editor.findPath(element)`.');\n  var node = findNode(element, editor);\n\n  if (!node) {\n    return null;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var path = document.getPath(node);\n  return path;\n}\n/**\n * Get the target range from a DOM `event`.\n *\n * @param {Event} event\n * @param {Editor} editor\n * @return {Range}\n */\n\n\nfunction getEventRange(event, editor) {\n  warning(false, 'As of slate-react@0.22 the `getEventRange(event, editor)` helper is deprecated in favor of `editor.findEventRange(event)`.');\n  invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.');\n\n  if (event.nativeEvent) {\n    event = event.nativeEvent;\n  }\n\n  var _event = event,\n      x = _event.clientX,\n      y = _event.clientY,\n      target = _event.target;\n  if (x == null || y == null) return null;\n  var value = editor.value;\n  var document = value.document;\n  var path = findNode(event.target, editor);\n  if (!path) return null;\n  var node = document.getNode(path); // If the drop target is inside a void node, move it into either the next or\n  // previous node, depending on which side the `x` and `y` coordinates are\n  // closest to.\n\n  if (editor.isVoid(node)) {\n    var rect = target.getBoundingClientRect();\n    var isPrevious = node.object === 'inline' ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n\n    var _range = document.createRange();\n\n    var iterable = isPrevious ? 'previousTexts' : 'nextTexts';\n    var move = isPrevious ? 'moveToEndOfNode' : 'moveToStartOfNode';\n    var entry = document[iterable](path);\n\n    if (entry) {\n      var _entry = slicedToArray(entry, 1),\n          n = _entry[0];\n\n      return _range[move](n);\n    }\n\n    return null;\n  } // Else resolve a range from the caret position where the drop occured.\n\n\n  var window = getWindow(target);\n\n  var _native6 = void 0; // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n\n\n  if (window.document.caretRangeFromPoint) {\n    _native6 = window.document.caretRangeFromPoint(x, y);\n  } else if (window.document.caretPositionFromPoint) {\n    var position = window.document.caretPositionFromPoint(x, y);\n    _native6 = window.document.createRange();\n\n    _native6.setStart(position.offsetNode, position.offset);\n\n    _native6.setEnd(position.offsetNode, position.offset);\n  } else if (window.document.body.createTextRange) {\n    // COMPAT: In IE, `caretRangeFromPoint` and\n    // `caretPositionFromPoint` don't exist. (2018/07/11)\n    _native6 = window.document.body.createTextRange();\n\n    try {\n      _native6.moveToPoint(x, y);\n    } catch (error) {\n      // IE11 will raise an `unspecified error` if `moveToPoint` is\n      // called during a dropEvent.\n      return null;\n    }\n  } // Resolve a Slate range from the DOM range.\n\n\n  var range = findRange(_native6, editor);\n  if (!range) return null;\n  return range;\n}\n\nvar index = {\n  Editor: Editor$1,\n  cloneFragment: cloneFragment,\n  findDOMNode: findDOMNode,\n  findDOMPoint: findDOMPoint,\n  findDOMRange: findDOMRange,\n  findNode: findNode,\n  findPath: findPath$1,\n  findPoint: findPoint,\n  findRange: findRange,\n  getEventRange: getEventRange,\n  getEventTransfer: getEventTransfer,\n  setEventTransfer: setEventTransfer,\n  ReactPlugin: ReactPlugin\n};\nexport default index;\nexport { Editor$1 as Editor, cloneFragment, findDOMNode, findDOMPoint, findDOMRange, findNode, findPath$1 as findPath, findPoint, findRange, getEventRange, getEventTransfer, setEventTransfer, ReactPlugin };","import React from \"react\";\n\nexport const ANNOTATION_TYPES = {\n  cursor: \"cursor\"\n};\n\nconst renderAnnotation = (props, editor, next) => {\n  const { children, annotation, attributes } = props;\n  const { type, data } = annotation;\n  const { color, name } = data.toJS();\n\n  switch (type) {\n    case ANNOTATION_TYPES.cursor:\n      return (\n        <span\n          {...attributes}\n          style={{\n            backgroundColor: color\n          }}\n        >\n          {children}\n          <span\n            style={{\n              backgroundColor: color,\n              paddingRight: \"2px\",\n              position: \"relative\"\n            }}\n          >\n            <span\n              style={{\n                position: \"absolute\",\n                bottom: \"100%\",\n                left: \"100%\",\n                color: color,\n                fontSize: \"5px\"\n              }}\n            >\n              {name}\n            </span>\n          </span>\n        </span>\n      );\n    default:\n      return next();\n  }\n};\n\nexport default renderAnnotation;\n","import React from \"react\";\nimport { Value } from \"slate\";\nimport { Editor } from \"slate-react\";\nimport io from \"socket.io-client\";\nimport renderAnnotation, { ANNOTATION_TYPES } from \"./slate/renderAnnotation\";\n\n/** Class representing a collaboration client. */\nclass Client extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      value: null,\n      syncing: false\n    };\n    this.editor = null;\n    this.socket = null;\n  }\n\n  /** When client mounts, initialize socket connection. */\n  componentDidMount() {\n    this.socket = io();\n    console.log('Client socket connected: ', this.socket);\n    this.socket.on(\"change\", this.onChangeServer);\n  }\n\n  onChangeServer = change => {\n    const { value } = change;\n    // If client has no value yet, initialize current server value\n    if (!this.state.value) {\n      this.setState({ value: Value.create(value) }, () => {\n        this.applyServerChange(change);\n      });\n    } else {\n      this.applyServerChange(change);\n    }\n  };\n\n  /** Apply new operations and update annotations. */\n  applyServerChange = ({ value, operations = [], annotations = [] }) => {\n    const documentKey = this.editor.value.document.key;\n\n    this.syncEditor(() => {\n      // Apply operations\n      if (operations.length) {\n        this.editor.withoutSaving(() => {\n          operations.forEach(op => {\n            this.editor.applyOperation(op);\n          });\n        });\n      }\n\n      // Update all annotations\n      this.editor.value.annotations.forEach(annotation => {\n        if (annotation.type === ANNOTATION_TYPES.cursor) {\n          this.editor.removeAnnotation(annotation)\n        }\n      });\n\n      annotations.forEach(annotation => {\n        // Skip this client's annotation\n        if (annotation.key === this.socket.id) return;\n\n        // Update the annotation key to match the client's document key\n        annotation.anchor.key = documentKey;\n        annotation.focus.key = documentKey;\n\n        this.editor.addAnnotation({\n          ...annotation,\n          type: ANNOTATION_TYPES.cursor\n        });\n      });\n    });\n  };\n\n  /** Send change to the server. */\n  emitChange({ operations, value }) {\n    this.socket.emit(\"change\", {\n      operations,\n      // Send current selection as well so we can update annotations\n      value: value.toJSON({ preserveSelection: true })\n    });\n  }\n\n  editorRef = node => (this.editor = node);\n\n  /** This wrapper allows us to update value without emitting to the server. */\n  syncEditor = fn => {\n    this.setState({ syncing: true }, fn);\n  };\n\n  onChange = change => {\n    const { syncing } = this.state;\n    const { value } = change;\n\n    if (syncing) {\n      this.setState({ value, syncing: false });\n    } else {\n      this.setState({ value });\n      this.emitChange(change);\n    }\n  };\n\n  render() {\n    const { value } = this.state;\n    return (\n      <div className=\"Client\">\n        {value ? (\n          <Editor\n            value={value}\n            onChange={this.onChange}\n            ref={this.editorRef}\n            renderAnnotation={renderAnnotation}\n            className=\"Editor\"\n            placeholder=\"Type something together ...\"\n          />\n        ) : (\n          \"Loading ...\"\n        )}\n      </div>\n    );\n  }\n}\n\nexport default Client;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport Client from \"./Client\";\n\nReactDOM.render(<Client />, document.getElementById(\"root\"));\n"],"sourceRoot":""}